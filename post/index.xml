<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zea&#39;s</title>
    <link>/post/</link>
    <description>Recent content in Posts on Zea&#39;s</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 06 Jul 2014 10:59:17 -0700</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Windows 下使用 Cocos2d-x 3.x &#43; Lua 开发基础</title>
      <link>/post/2014-07-06-cocos2d-lua-basic/</link>
      <pubDate>Sun, 06 Jul 2014 10:59:17 -0700</pubDate>
      
      <guid>/post/2014-07-06-cocos2d-lua-basic/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://cocos2d-x.org/&#34;&gt;Cocos2d-x&lt;/a&gt; 是国内非常成熟的 2d 游戏开发引擎了，拥有非常广大的开发者群体和活跃的社区，支持 Windows、Linux、Mac OS、iOS、Android 和 Window Phone 等各个平台，其本身是用 C++ 语言实现的，主要提供了面向 C++ 的接口，也提供了对 Lua、object-c 和 JavaScript 的支持。我们的 minigame 要基于 Cocos（为简单起见，我就把 Cocos2d-x 称为 Cocos 了） 和 Lua 实现，这有好处也有弊端，Lua 作为一门脚本语言，开发起来确实非常快捷，不过 Cocos 社区 Lua 相关的文档和资料并不如 C++ 那么完备，使得上手的难度增加，而且 Lua 本质并不是面向对象的编程语言，我们编码时的一些 OO 的思想也要需要转变。&lt;/p&gt;

&lt;p&gt;出于对自己记忆力的极端不信任，决定把实习期遇到的关于 Cocos + Lua 的种种问题都记录下来，希望也能成为实习的成果之一吧！&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;开发系统和工具:f65ecc8223ad2073eb0df747275b447c&#34;&gt;开发系统和工具&lt;/h2&gt;

&lt;p&gt;首先是环境的搭建，Cocos 的使用方法挺多的，取决于你的开发系统和开发工具，刚开始看的时候我自己也有些被搞乱了，说来搞笑，我基本上按照 Cocos 的安装说明文档去配置的，到最后用的最多的却是 Cocos-console。官方网站上各种开发工具环境搭建相关的文档还是很详细的，我在这里就不再重复了，主要是简单介绍一下用到的各种工具是干嘛的，还有就是不同的 Cocos 开发环境如何抉择的问题。&lt;/p&gt;

&lt;p&gt;我自己的系统是 Windows 7，目标平台是 Android，因此本文主要讨论的问题是 &lt;strong&gt;Windows 平台下开发 Android 游戏的环境选择&lt;/strong&gt;。官方网站上有比较详细的搭建 Cocos + Android 开发环境的文档，可以参考 &lt;a href=&#34;http://cocos2d-x.org/wiki/How_to_run_cpp-tests_on_Android&#34;&gt;How to run cpp-tests on Android (Terminal)&lt;/a&gt; 和 &lt;a href=&#34;http://cocos2d-x.org/wiki/How_to_Build_an_Android_Project_with_Eclipse&#34;&gt;How to run cpp-tests on Android (Eclipse)&lt;/a&gt; 这两份文档，分别是在命令行下和 Eclipse 下开发 Android 游戏的环境配置步骤。总的来说，要在 Windows 上开发 Cocos + Lua 的 Android 游戏，我们需要准备如下东西，有点多，附上对每个工具的简单解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Cocos2d-x&lt;/strong&gt; 也就是 Cocos 的源代码，包含 Cocos 用到的各种脚本文件、 C++ 类、各平台工程文件等，可从 &lt;a href=&#34;http://cocos2d-x.org/download&#34;&gt;此处&lt;/a&gt; 下载，我选择的是 3.1.1 的版本，需要说明的一点是 Cocos 的 API 接口在一个大版本中是不会变的，也就是 3.x 的版本共享一套 API，但和 2.x 的 API 差别较大，目前我在网上找到资料 2.x 的比较多&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Visual Studio&lt;/strong&gt; 如果是 Windows 开发环境的话 VS 是一定少不了的，编译 Cocos 的源代码就全依赖它了，这个木有源码链接，请大家自行搜索吧……&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;JDK 1.6+&lt;/strong&gt; Java 虚拟机，可以从 &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/index.html&#34;&gt;Oracle 官网&lt;/a&gt; 上下载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;ADT Bundle&lt;/strong&gt; 是一个集成了 Android SDK + Eclipse + ADT（Eclipse 开发 Android 使用到的插件）的压缩包，使得配置 Android 开发环境变得非常方便，可从 &lt;a href=&#34;http://developer.android.com/sdk/index.html&#34;&gt;Android Developer&lt;/a&gt; 下载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Android NDK&lt;/strong&gt;，提供使用 Native Code 开发 Android 应用程序的支持，可从 &lt;a href=&#34;http://developer.android.com/tools/sdk/ndk/index.html&#34;&gt;Android Developer&lt;/a&gt; 下载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Ant 1.9.4&lt;/strong&gt; 根据 build.xml 编译 Android 项目的命令行工具，可从 &lt;a href=&#34;http://ant.apache.org/bindownload.cgi&#34;&gt;apache.org&lt;/a&gt; 下载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Python 2.7&lt;/strong&gt; 脚本语言，Cocos 的安装、运行脚本是用 Python 写的，地址 &lt;a href=&#34;https://www.python.org/download/&#34;&gt;python.org&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Lua 5.2&lt;/strong&gt; Lua 脚本虚拟机，可执行程序下载地址 &lt;a href=&#34;http://joedf.users.sourceforge.net/luabuilds/&#34;&gt;Lua 5.2.3&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cocos-项目结构:f65ecc8223ad2073eb0df747275b447c&#34;&gt;Cocos 项目结构&lt;/h2&gt;

&lt;p&gt;分两个部分说下，一个是 Cocos C++，一个是 Cocos Lua。&lt;/p&gt;

&lt;p&gt;Cocos C++ 项目根目录如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/blog/cocos-basic-cpp.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;其中 &lt;code&gt;/Classes&lt;/code&gt; 文件夹是主要的代码文件夹，开发者所需要写的全部代码文件都包含在这个文件夹中，&lt;code&gt;/Resources&lt;/code&gt; 则是资源文件夹，开发者的资源都存储在这个文件夹中，&lt;code&gt;/cocos2d&lt;/code&gt; 文件夹则包扩了 Cocos 完整的源代码。除此之外我们看到还有大量的 &lt;code&gt;/proj.xxxx&lt;/code&gt; 文件夹，这是 Cocos 为不同平台、不同编辑器生成的项目文件夹，所有这些项目均使用 &lt;code&gt;/Classes&lt;/code&gt; 中的源代码和 &lt;code&gt;/Resources&lt;/code&gt; 中的资源文件。&lt;/p&gt;

&lt;p&gt;而 Cocos Lua 项目目录如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/blog/cocos-basic-lua.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;与 C++ 项目结构类似，Lua 项目所有的程序文件都在 &lt;code&gt;/src&lt;/code&gt; 文件夹下，资源文件都在 &lt;code&gt;/res&lt;/code&gt; 文件夹下，&lt;code&gt;/frameworks&lt;/code&gt; 包含了 Cocos 的完整源代码以及各个项目文件夹， 如下图所示为 &lt;code&gt;/frameworks/runtime-src&lt;/code&gt; 文件夹的结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/blog/cocos-basic-lua-runtime-src.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;而 &lt;code&gt;/runtime&lt;/code&gt; 文件夹内则包含了生成的个平台的可执行代码。&lt;/p&gt;

&lt;h2 id=&#34;console-vs-eclipse-vs-visual-studio:f65ecc8223ad2073eb0df747275b447c&#34;&gt;Console vs. Eclipse vs. Visual Studio&lt;/h2&gt;

&lt;p&gt;这是个让人比较纠结的话题，我们到底应该配置哪种环境，使用哪种工具进行 Cocos 开发呢？其实根据上一节的介绍，大家应该已经明白了，Cocos 项目可以&lt;strong&gt;方便的在各个工具之间切换&lt;/strong&gt;，你可以使用 Visual Studio 写 C++ 代码，生成 Windows 程序进行调试，然后跑到 Eclipse 里去生成一个 APK 部署到自己的手机上。所以大家对工具其实不用太在意，用自己喜欢的就行。&lt;/p&gt;

&lt;p&gt;目前我知道的可选方案有四种，简单介绍一下他们用法上的区别，以及我对这些方法的感受。&lt;/p&gt;

&lt;h3 id=&#34;cocos-console:f65ecc8223ad2073eb0df747275b447c&#34;&gt;Cocos Console&lt;/h3&gt;

&lt;p&gt;纯粹使用命令行来进行 Cocos 项目的新建、编译、运行等操作，代码使用纯文本编辑器比如 Sublime Text 编写。这种方法比较轻量级，不需要运行 VS 或 Eclipse 等消耗系统资源的编辑器，可以更方便的认识整个项目的架构，了解每个文件夹是干嘛的，不论是 C++ 项目还是 Lua 项目，这种模式都可以胜任，Linux 程序员的首选；缺点就是没有代码提示，也不是很方便调试，上手写代码比较困难，编码效率不够高。&lt;/p&gt;

&lt;h3 id=&#34;cocos-eclipse:f65ecc8223ad2073eb0df747275b447c&#34;&gt;Cocos + Eclipse&lt;/h3&gt;

&lt;p&gt;使用 ADT 可方便的对 Android 游戏进行开发、部署与调试，熟悉 ADT 的 Android 开发人员的首选，开发 Cocos + C++ 会比较方便，相应的写 Lua 脚本就不很方便，需要另装插件。&lt;/p&gt;

&lt;h3 id=&#34;cocos-visual-studio:f65ecc8223ad2073eb0df747275b447c&#34;&gt;Cocos + Visual Studio&lt;/h3&gt;

&lt;p&gt;Visual Studio 真是 Windows 程序员的专有福利，其功能简直不能更强大，使用 Visual Studio 开发 C++ 简直是件幸福的事，如果要用 Cocos + C++ 开发 Win32 游戏，那 Visual Studio 绝对算是首选了。要说美中不足，就是写 Lua 需要另装插件，而且如果要生成 Android 游戏需要使用 Eclipse 或 Console 去编译部署。&lt;/p&gt;

&lt;h3 id=&#34;cocos-code-ide:f65ecc8223ad2073eb0df747275b447c&#34;&gt;Cocos Code IDE&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cocos2d-x.org/wiki/Code_Editor&#34;&gt;Cocos Code Ide&lt;/a&gt; 这个工具刚才我没有列在必备工具里，因为其本身只提供了 Cocos + Lua/JS 的开发环境，也是基于 Eclipse 包装的，针对 Lua 语言提供了 Cocos API 的&lt;strong&gt;代码提示&lt;/strong&gt;功能，这一点上来看非常方便，而且开发环境搭建起来也非常方便，不过我试用的时候 debug 信息老是打不出来……另外需要注意的是，用 Cocos Code IDE 生成的项目文件夹跟 Console 生成的 Cocos Lua 项目文件夹稍有不同，并没有包含完成的 Cocos 源文件，因此大小要小很多（大概60+MB），而且在 &lt;code&gt;runtime-src&lt;/code&gt; 中只包含了 Eclipse 项目。&lt;/p&gt;

&lt;p&gt;总结一下，我觉得如果使用 C++，目标平台 Windows，那么 Visual Studio 无疑；如果目标平台是 Android，也可以使用 Visual Studio 进行编码和调试（生成 exe 进行调试），最后使用 Eclipse 部署；对于 Lua 开发者，Code IDE 是个不错的选择，支持断点、单步、watch 等调试手段，而且自动生成各平台的二进制文件，的缺点就是目前还有 bug，如果打印语句没有问题的话就好了，另外一点就是 Code IDE 完全不能写任何 C++ 代码，对于项目中既需要写 C++ 也需要写 Lua 的高级开发者而言就显得不够灵活了；最后如果你之前是 Linux 开发者或是希望对项目有更直接更灵活的控制，请选择命令行。&lt;/p&gt;

&lt;h2 id=&#34;命令行-文本编辑器开发:f65ecc8223ad2073eb0df747275b447c&#34;&gt;命令行 + 文本编辑器开发&lt;/h2&gt;

&lt;p&gt;前边多次提到我自己使用的是 Cocos Console + Sublime Text 来编写 Cocos 项目的，这里就谈一些使用上的经验技巧吧！一开始之所以选择 Console 是因为安装部署起来稍微方便一点点，后来我发现还有另一个好处（以至于现在连 Console 都不用了）。&lt;/p&gt;

&lt;h3 id=&#34;创建项目:f65ecc8223ad2073eb0df747275b447c&#34;&gt;创建项目&lt;/h3&gt;

&lt;p&gt;使用如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cocos new MyCCLua -p com.test.hjc -l lua -d ./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;MyCCLua&lt;/code&gt; 是项目名，&lt;code&gt;-p com.test.hjc&lt;/code&gt; 指定生成的 Android 项目的包名，&lt;code&gt;-l lua&lt;/code&gt; 指定生成项目的语言种类，合法项包括 &lt;code&gt;cpp&lt;/code&gt;，&lt;code&gt;lua&lt;/code&gt; 和 &lt;code&gt;js&lt;/code&gt;，&lt;code&gt;-d ./&lt;/code&gt; 是新建项目所在文件夹，默认是当前文件夹。&lt;/p&gt;

&lt;h3 id=&#34;编译-运行项目:f65ecc8223ad2073eb0df747275b447c&#34;&gt;编译/运行项目&lt;/h3&gt;

&lt;p&gt;使用如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cocos compile/run -p platform
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;compile&lt;/code&gt; 是单纯编译，&lt;code&gt;run&lt;/code&gt; 是编译且运行，&lt;code&gt;-p win32&lt;/code&gt; 是编译生成的目标平台可选项为 ios、mac、android、web 以及 win32，&lt;code&gt;-s source&lt;/code&gt; 项目文件夹路径，如不指定则为当前目录，&lt;code&gt;-q&lt;/code&gt; 安静模式，不输出日志系信息，&lt;code&gt;-m mode&lt;/code&gt; 控制编译生成模式，可以是 &lt;code&gt;debug&lt;/code&gt; 或 &lt;code&gt;release&lt;/code&gt;，默认是 &lt;code&gt;debug&lt;/code&gt; 模式。&lt;/p&gt;

&lt;p&gt;如果要编译运行 Cocos 自带的 lua-tests，可以直接去 &lt;code&gt;cocos2d-x-3.1.1/tests/lua-tests&lt;/code&gt; 下执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cocos run -p win32
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;编写与调试:f65ecc8223ad2073eb0df747275b447c&#34;&gt;编写与调试&lt;/h3&gt;

&lt;p&gt;我的目标平台是 Android，不过平时都是在 Windows 上进行调试，部署、调试起来会方便很多，对于 Lua 开发者而言，还有一个好处就是 Lua 作为一门脚本语言，代码修改之后实际上是&lt;strong&gt;不需要重新编译&lt;/strong&gt;的，&lt;strong&gt;重启 exe 就可以看到最新的代码效果&lt;/strong&gt;了！&lt;/p&gt;

&lt;p&gt;我平时编写、调试的步骤为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;新建一个名为 &lt;code&gt;MyCCLua&lt;/code&gt; Cocos Lua 项目之后，使用 &lt;code&gt;cocos compile -p win32&lt;/code&gt; 编译此新建项目，完成后可以在 &lt;code&gt;MyCCLua/runtime&lt;/code&gt; 下找到一个名为 &lt;code&gt;win32&lt;/code&gt; 的文件夹，此文件夹包含了编译生成的 Windows 可执行程序、所有的资源文件和所有用到的 Lua 脚本；&lt;/li&gt;
&lt;li&gt;把 &lt;code&gt;MyCCLua/runtime/win32&lt;/code&gt; 文件夹单独拷贝出来，命名为 &lt;code&gt;MyCCLua-win32&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;使用 Sublime Text 修改 &lt;code&gt;MyCCLua-win32/src&lt;/code&gt; 下的 Lua 脚本，执行 &lt;code&gt;MyCCLua-win32/MyCCLua.exe&lt;/code&gt; 查看最新效果，由于免去了事实上无用的编译环节，所以可以加快调试的速度；&lt;/li&gt;
&lt;li&gt;如果脚本产生错误闪退，则使用 &lt;a href=&#34;http://unknownworlds.com/decoda/&#34;&gt;Decoda&lt;/a&gt; 工具加载 &lt;code&gt;MyCCLua.exe&lt;/code&gt;，该工具可以捕获 Lua 异常，设置断点和 watch，是我调试过程中不可或缺的利器；&lt;/li&gt;
&lt;li&gt;如果需要生成 APK，则把 &lt;code&gt;MyCCLua-win32&lt;/code&gt; 下的 &lt;code&gt;res&lt;/code&gt; 和 &lt;code&gt;src&lt;/code&gt; （取决于你做了哪些修改）两个文件夹拷回到 &lt;code&gt;MyCCLua&lt;/code&gt; 内，执行 &lt;code&gt;cocos compile -p android&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>暑期实习开始</title>
      <link>/post/2014-07-05-summer-intern/</link>
      <pubDate>Sat, 05 Jul 2014 21:44:53 -0700</pubDate>
      
      <guid>/post/2014-07-05-summer-intern/</guid>
      <description>&lt;p&gt;记得很清楚，拿到网易暑期实习 offer 是 4 月 30 号，正好是劳动节放假前一天，当时真的是很开心，感觉实习终于有着落了，而且还是我的首选网易游戏，所以那个劳动节过的格外开心。实习从 7 月开始，6 月末收到公司邮件通知，从 6 月 29 号开始就可以去杭州报道了，这点不得不称赞网易，对实习生的待遇非常不错，公司食堂免费吃，还提供住宿，不过因为实习生较多，公司的宿舍不够用了，所以我被分在了公司附近的乐通酒店。去之前特意查了下地图，发现公司提供住宿的几家酒店里乐通是离得最近的，跟公司只隔了一个街区，走路 10 分钟妥妥儿的，这一点还是非常方便的。&lt;/p&gt;

&lt;p&gt;我跟几个朋友一起，乘坐 29 号的火车来杭州，出了火车站几个人做的第一件事就是去办了张杭州一卡通，可以租自行车的那种，后来证明这个举动真是太明智了，因为我跟老缪出了地铁站之后就是租量小车慢慢悠悠骑到乐通的。我们就这样，骑着租来的橘黄色的小破车，拖着的拉杆箱，慢慢悠悠的开始了暑期杭州的日子。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;初到乐通，一种大张江的即视感瞬间就让我泪流满面了，这环境，这布局，这没一个人影的大马路，还真是熟悉的场景，熟悉的味道。我们一行人中，只有我跟老缪住乐通，另外几个住另外一个酒店，虽然离公司较远，但是居然毗邻商圈，简直不能更惬意，于是当晚大家就约定去那个名叫“星光大道”的地方转一转。我跟老缪再次利用了杭州的自行车，一边拍大腿感慨真他妈方便一边来到了目的地，也就十几分钟，算不得很远。星光大道吃饭的地方还是不少的，还有之前跟蔚蔚一起吃过的非常好吃的老头儿油爆虾，感觉住在这边的孩子的生活质量真比我们高了好多，有点像张江和世纪大道的差别了。&lt;/p&gt;

&lt;p&gt;6 月 30 号下暴雨，在宾馆闲着，顺便看看 cocos2d，毕竟马上实习开始就要用到，完全不会也说不过去。中午在宾馆门口发现大批黑暗料理，就吃了份鸡肉饭，晚上偷溜进公司食堂愉快的蹭了一顿饭，同时也从食堂门口的通告得知因为实习生和新员工入职，从 7 月 1 日起食堂二楼小锅菜临时改成大众餐厅了，当天是最后一天，很遗憾不能品尝一下网易的特色菜。吃完饭跑去食堂二楼参观，时候发现大家居然都在吃火锅，而且貌似是老北京涮羊肉那种铜锅！当时瞬间给网易加了一百分啊卧槽，可惜这些我们也是无缘享受的……吃完饭还去参观了篮球场，不得不说网易的木地板真心不错，比张江的好太多了，恨不得当时就上去打一场。&lt;/p&gt;

&lt;p&gt;7 月 1 号正式开始在网易的暑期实习，头两天都没做什么事情，基本上就是入职讲座啊，认识一下导师啊，配配环境什么的，我做的主要事情就是在公司转了转，看看都有哪些玩儿的。体育馆、健身房、游戏室、射箭馆以及桌球房这些地方基本上都去了一遍，感觉公司活动还是蛮多的，到了周五晚上还会有分部门的烧烤、啤酒活动。
公司内部环境的话感觉还不错啦，座位跟实验室相比的话还是不如的，不过公共空间非常宽敞，来公司几天之后就发现游戏公司男女比例非常均衡，而且质量都不错，连平时专打 2 分和 3 分的老缪都给了好几个 7、8 分了，我们几个都在教唆他抓住实习机遇把个人问题解决了 (=&lt;/p&gt;

&lt;p&gt;工作的话，我实习被分到了 minigame 项目，六人组队做一个小游戏出来，组内两名策划，三名程序，一名 QA，使用 cocos2d + lua 来实现。被分到这个项目组还是挺开心的，相当于提前感受了一把公司里面游戏项目迭代的过程，也有一些挑战性，毕竟 cocos2d 和 lua 我都不是很熟，两个月的时间要从头学起并做出一个实际的东西来，而且要和策划、QA 一起合作，挺新鲜好玩儿的。&lt;/p&gt;

&lt;p&gt;加油！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何写 Ubuntu 的 Framebuffer</title>
      <link>/post/2014-05-20-ubuntu-fbvnc/</link>
      <pubDate>Tue, 20 May 2014 20:26:25 +0800</pubDate>
      
      <guid>/post/2014-05-20-ubuntu-fbvnc/</guid>
      <description>

&lt;p&gt;最近有个小项目，想在 Android 上跑一个通过直接读写 framebuffer 实现的 vnc 客户端，
所以发现了这个 &lt;a href=&#34;https://github.com/zohead/fbvnc&#34;&gt;fbvnc&lt;/a&gt;， 是 github 上一个小哥儿捣鼓的，基于现有的一个同名项目开发，专为嵌入式设备使用。这个小的 vnc 客户端的不足当然有很多，比如连基本的窗口都木有，直接占用了你整个 framebuffer，不能调整分辨率，巨慢无比，卡的紧了就直接挂，但是它有一个最大的优点，就是真的非常简单，除了一些基本的 Linux 库之外没有任何第三方的依赖。&lt;/p&gt;

&lt;p&gt;以上算是个小广告吧 (=&lt;/p&gt;

&lt;p&gt;但是一个很大的问题是，这货在 ubuntu 上不 work……什么原因呢，做个小测试看一看。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;ubuntu-下修改-framebuffer:821a63a0b482335aab43dab9792305ca&#34;&gt;Ubuntu 下修改 Framebuffer&lt;/h2&gt;

&lt;p&gt;其实之前我写过小程序测试直接写 ubuntu 下的 &lt;a href=&#34;https://wiki.ubuntu.com/FrameBuffer&#34;&gt;framebuffer&lt;/a&gt; 的，当时也是神马效果都木有，当时只是猜测和 x11 或 unity 有关，也没深究，这次为了跑 fbvnc，特意去搜了下，后来在 &lt;a href=&#34;http://unix.stackexchange.com/questions/58420/writes-to-framebuffer-dev-fb0-do-not-seem-to-change-graphics-screen&#34;&gt;这里&lt;/a&gt; 找到了&lt;strong&gt;解决方法&lt;/strong&gt;：需要置上 &lt;code&gt;FB_ACTIVATE_NOW&lt;/code&gt; 和 &lt;code&gt;FB_ACTIVATE_FORCE&lt;/code&gt; 属性，具体代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;vinfo.activate |= FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
ioctl(fbfd, FBIOPUT_VSCREENINFO, &amp;amp;vinfo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加上这段代码之后，我写的测试程序终于可以看到修改屏幕的效果了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;linux/fb.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;

int main()
{
    int fbfd = 0;
    struct fb_var_screeninfo vinfo;
    struct fb_fix_screeninfo finfo;
    long int screensize = 0;
    char *fbp = 0;
    int x = 0, y = 0，color = 255;
    long int location = 0;

    /* 打开 fb 设备文件 */
    fbfd = open(&amp;quot;/dev/fb0&amp;quot;, O_RDWR);
    ioctl(fbfd, FBIOGET_FSCREENINFO, &amp;amp;finfo);
    ioctl(fbfd, FBIOGET_VSCREENINFO, &amp;amp;vinfo);
    /* 把 fb 映射到内存 */
    screensize = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / 8;
    fbp = (char *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED,fbfd, 0);
    /* 置上FB_ACTIVATE_NOW 和 FB_ACTIVATE_FORCE */
    vinfo.activate |= FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
    ioctl(fbfd, FBIOPUT_VSCREENINFO, &amp;amp;vinfo);
    /* 渐变修改 fb */
    for(color = 255; color &amp;gt; 0 ; color --) {
        for(x = 100 ;x &amp;lt; 200 ;x++) {
            for(y = 100; y &amp;lt; 200; y++) {
                location = (x+vinfo.xoffset) * (vinfo.bits_per_pixel/8) + (y+vinfo.yoffset) * finfo.line_length;
                *(fbp + location) = color; /* B */
                *(fbp + location + 1) = 0; /* G */
                *(fbp + location + 2) = 0; /* R */
                *(fbp + location + 3) = 0; /* A */
            }
        }

        usleep(5000);
    }    
    munmap(fbp, screensize);
    close(fbfd);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过我预期中的效果是直接在当前屏幕上多出一个渐变的蓝色色块，实际效果是在一个纯黑背景上。看来还是和 x11 的实现有关，不过我不了解 x11，所以并不清楚具体的原因是什么，仿佛 x11 并没有这么简单的使用 fb。&lt;/p&gt;

&lt;p&gt;除此之外，其实还有&lt;strong&gt;另一个&lt;/strong&gt;更加方便和人畜无害的方法去直接操作 framebuffer，那就是切到其他的 tty 去执行。&lt;/p&gt;

&lt;h2 id=&#34;ubuntu-下运行-fbvnc:821a63a0b482335aab43dab9792305ca&#34;&gt;Ubuntu 下运行 fbvnc&lt;/h2&gt;

&lt;p&gt;根据 fbvnc 的 Readme，在 Ubuntu 下运行需要修改 fbvnc.c 下的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef unsigned short fbval_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef unsigned int fbval_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 fbvnc 的源码中加入了修改 activate 属性的代码之后，执行成功！&lt;/p&gt;

&lt;p&gt;等等，怎么退出……不得已 ssh 上去强制 kill 了 fbvnc 进程，结果我擦整个桌面都不好了，完全黑屏没有反映啊，切换到 tty6 关闭了很多工作的 tmux 窗口之后，回到 tty7 发现又好了，果然会有奇怪的问题，怪不得大家建议在 Linux 下不要直接修改 framebuffer，而是利用 X window 接口。&lt;/p&gt;

&lt;p&gt;如果直接在 tty6 中执行 fbvnc 就正常多了，可惜性能实在太差，几乎不能用，而且还容易挂。&lt;/p&gt;

&lt;h2 id=&#34;android-下编译运行-fbvnc:821a63a0b482335aab43dab9792305ca&#34;&gt;Android 下编译运行 fbvnc&lt;/h2&gt;

&lt;p&gt;简单写个 Android 应用然后把 fbvnc 代码拷进去这种方法肯定不够，普通应用没有操作 framebuffer 的权限。我把 fbvnc 放到了 Android 源码 external 目录下，然后重新编译了 android 镜像。为了成功编译，需要做如下修改：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;注释掉 fbvnc.c 中所有的 dprintf，bionic 不支持此函数；&lt;/li&gt;
&lt;li&gt;在 fbvnc.c 中把调用 getpass 函数那一行改成硬编码，或者自己实现个 getpass，bionic 也不支持此函数；&lt;/li&gt;
&lt;li&gt;修改 draw.h 中的 FBDEV_PATH 为 &amp;ldquo;/dev/graphics/fb0&amp;rdquo;，Android 中 fb 设备路径和 Linux 默认路径不同；&lt;/li&gt;
&lt;li&gt;在 fbvnc/ 下添加如下文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;``` text Android.mk
LOCAL_PATH:= $(call my-dir)&lt;/p&gt;

&lt;p&gt;include $(CLEAR_VARS)
LOCAL_CFLAGS:= -Wall -Os
LOCAL_MODULE_TAGS:= debug eng
LOCAL_MODULE:= fbvnc
LOCAL_SRC_FILES:= d3des.c draw.c vncauth.c fbvnc.c
LOCAL_C_INCLUDES := $(LOCAL_PATH)
LOCAL_SHARED_LIBRARIES := \
        libcutils
include $(BUILD_EXECUTABLE)
```&lt;/p&gt;

&lt;p&gt;OK，编译！好了之后 adb shell 上去，用 root 权限执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fbenv myhostname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;成功显示了远程 vnc 桌面，不过并不持久，很快就会被 Android 自己的界面刷掉。如果要解决这个问题，需要对 Android 系统进行更多的修改，以后有时间再写一篇吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.824 Lab1 MapReduce Notes</title>
      <link>/post/2014-04-09-6-dot-824-mapreduce-notes/</link>
      <pubDate>Wed, 09 Apr 2014 22:01:37 +0800</pubDate>
      
      <guid>/post/2014-04-09-6-dot-824-mapreduce-notes/</guid>
      <description>

&lt;p&gt;作为 MIT 6.824 &lt;em&gt;分布式系统&lt;/em&gt; 这门课的第一个 Lab，其主要的目的是让学生熟悉下 Go 语言，因此不是特别难。事实上，2013 年的 Lab1 是做一个 P/B 架构的 LockService，感觉今年的这个 MapReduce 难度上有所下降，更加适合上手，而内容方面涉及了 MapReduce 的简单应用和实现，做完之后收获更大，总的来说整体水准高于去年的 LockService。&lt;/p&gt;

&lt;p&gt;Lab 共分为三个部分，Part I 要求在 MapReduce 上实现一个 WordCount，因为大部分的 MapReduce 框架都已经实现好了，所以这部分非常简单；支持代码（ Support code ）中的 MapReduce 是个非常简化的版本，没有 Master，顺序执行每一个 Map 和 Reduce 操作，Part II 的要求是实现一个简单的 Master； Part III 要在 Part II 的基础之上实现容忍客户端失败的情况。&lt;/p&gt;

&lt;p&gt;总的来讲，这个 Lab 中我们只需要实现一个简化版的 MapReduce 中的 Master Node 的逻辑部分。&lt;/p&gt;

&lt;h3 id=&#34;part-i:9d64eb79111af9673b332797623c91f4&#34;&gt;Part I&lt;/h3&gt;

&lt;p&gt;只有一点点代码要写，不过在动手之前还是要认真阅读支持代码，主要需要搞明白的是 Map 和 Reduce 函数的输入输出分别是什么：&lt;/p&gt;

&lt;p&gt;``` go wc.go
func Map(value string) *list.List {}&lt;/p&gt;

&lt;p&gt;func Reduce(key string, values *list.List) string {}
```&lt;/p&gt;

&lt;p&gt;为此需要看一看 mapreduce.go 中 DoMap 和 DoReduce 这两个方法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>简单的递归和动态规划</title>
      <link>/post/2014-04-05-recursion-and-dp/</link>
      <pubDate>Sat, 05 Apr 2014 13:31:50 +0800</pubDate>
      
      <guid>/post/2014-04-05-recursion-and-dp/</guid>
      <description>

&lt;h3 id=&#34;题目-wordbreak:53826fc2dcb894551367a127137aed4e&#34;&gt;题目：WordBreak&lt;/h3&gt;

&lt;p&gt;首先定义如下表示&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;str[n:m]&lt;/strong&gt;为字符串 str 从下标 n 开始到下标 m-1 的字串&lt;/p&gt;

&lt;p&gt;例如 str = &amp;ldquo;abcdef&amp;rdquo; str[4:6] = &amp;ldquo;ef&amp;rdquo;，str[1:3] = &amp;ldquo;bc&amp;rdquo;，str[3:4] = &amp;ldquo;d&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;str[n:]&lt;/strong&gt;为字符串从下标 n 开始直到字符串结束的子串&lt;/p&gt;

&lt;p&gt;例如 str = &amp;ldquo;abcdef&amp;rdquo; str[2:] = ”cdef“&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;str[:m]&lt;/strong&gt;为字符串从头开始直到下标 m-1 的子串&lt;/p&gt;

&lt;p&gt;例如 str = &amp;ldquo;abcdef&amp;rdquo; str[:3] = ”abc“&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;stat[n]&lt;/strong&gt;表示子串 str[n:] 能不能用字典中的单词表示&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;假设字符串长度是 L，那么字符下标从 0 到 L-1，定义 stat[L] = True （因为 str[L:] 是空字符串）&lt;/p&gt;

&lt;p&gt;这道题的目标是计算 stat[0]，为了计算 stat[n]，我们有如下&lt;strong&gt;递归方程&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stat[n] = 
{ dict.contains( str[n:n+1] ) &amp;amp;&amp;amp; stat[n+1] } ||
{ dict.contains( str[n:n+2] ) &amp;amp;&amp;amp; stat[n+2] } ||
...
{ dict.contains( str[n:L] ) &amp;amp;&amp;amp; stat[L] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中花括号括起来的部分 &lt;code&gt;dict.contains( str[n:n+m] ) &amp;amp;&amp;amp; stat[n+m]&lt;/code&gt; 表示：子串 str[n:] 的前 m 个字符组成的子字符串是字典中的单词，并且，子串 str[n+m:] 可以被字典中的单词组成&lt;/p&gt;

&lt;p&gt;只要有任意一个 m 满足上述语句，就可以说 stat[n] 为 True！&lt;/p&gt;

&lt;p&gt;对于&lt;strong&gt;递归思想&lt;/strong&gt;来说，我们&lt;strong&gt;从等式左边到右边&lt;/strong&gt;，不去管函数具体怎么解决子问题的，只是&lt;strong&gt;给出如何把问题分解为更小的子问题的方法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;所以一个递归方法去解这道题就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;bool stat(n) {
    if n = L { return True }

    for i = n+1..L {
        #依次计算每一个花括号，任何一个为 True 就返回 True
        if dict.contains(str[n:i]) &amp;amp;&amp;amp; stat(i) 
            return True
    }

    #所有花括号都是 False，返回 False
    return False
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这跟你写的那个递归方法是一样的，只不过我参数里用的并不是一个真正的字符串，而是用一个数字表示当前子字符串是从那个下标开始的。&lt;/p&gt;

&lt;p&gt;递归方法的一个问题就是&lt;strong&gt;重复计算&lt;/strong&gt;，比如 str=&amp;ldquo;aaaaab&amp;rdquo;, dict = [&amp;ldquo;a&amp;rdquo;, &amp;ldquo;aa&amp;rdquo;, &amp;ldquo;aaa&amp;rdquo;, &amp;ldquo;aaaa&amp;rdquo;, &amp;ldquo;aaaaa&amp;rdquo;] 这个问题，当你计算 stat(&amp;ldquo;aaaaab&amp;rdquo;) 和 stat(&amp;ldquo;aaaab&amp;rdquo;) 的时候都要去计算 stat(&amp;ldquo;aaab&amp;rdquo;)，字符串越长，递归调用层数越深，这个问题越明显。&lt;/p&gt;

&lt;p&gt;如何解决重复计算的问题，一个直观的方法就是，每当我计算完一个 stat(n) 的值的时候，我把 stat(n) 缓存下来，下次再需要计算 stat(n) 的时候我直接返回，而不去计算。这种思想用递归写是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;boole stat_cache[L]; #缓存 stat[n] 的结果
boole stat_calced[L]; #标识 stat[n] 是否已计算
bool stat(n) {
    if n = L { return True }

    if stat_calced[n] { return stat_cache[n] }

    stat_calced[n] = True

    for i = n+1..L {
        #依次计算每一个花括号，任何一个为 True 就返回 True
        if dict.contains(str[n:i]) &amp;amp;&amp;amp; stat(i) 
            stat_cache[n] = True
            return True
    }

    #所有花括号都是 False，返回 False
    stat_cache[n] = False
    return False
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我没有试过，这种方法应该已经可以解决超时的问题了，但是这种方法还是会出现多层函数调用栈，而且需要一个额外的 stat_calced 数组，怎么办嘞？&lt;/p&gt;

&lt;p&gt;我们再去看看那个递归方程，发现要计算 stat[n] 的值，我们需要知道 stat[n+1]&amp;hellip;stat[L] 的值，这次我们换个方向思考，从&lt;strong&gt;等式右边到左边&lt;/strong&gt;，先把右边需要用到的都计算好，然后再计算 stat[n]，先尝试解决子问题，进而解决更大的问题，这就是&lt;strong&gt;动态规划的方法&lt;/strong&gt;，在这里，递归方程被称为&lt;strong&gt;状态转移方程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;已知计算 stat[n] 需要 stat[n+1]..stat[L]，而计算 stat[n+1] 需要 stat[n+2]..stat[L]，一步步退下来，我们从 stat[L] 开始，一步步往前算。当然，递归也好，动态规划也好，都需要一个&lt;strong&gt;根&lt;/strong&gt;，就像数学归纳法中的 base 一样，这一题中我们的根就是 stat[L] = True&lt;/p&gt;

&lt;p&gt;所以我们的代码应该是这个样子的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for n = L-1 .. 0 { #loop1
    #假设所有花括号都是 False
    stat[n] = False
    for i = n+1..L { #loop2
        #依次计算每一个花括号，任何一个为 True 就返回 True
        if dict.contains(str[n:i]) &amp;amp;&amp;amp; stat(i) 
            stat[n] = True
            break
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在上述代码中，loop1 相当于递归方法中的函数调用，都是对 n 做轮询，不同的是递归是从 0 到 L-1 轮询，而这里是从 L-1 到 0 来轮询。而 loop2 和递归函数中的循环是一模一样的。&lt;/p&gt;

&lt;p&gt;总结一下，递归的思想是这样的，我要算 stat[n]，那我就直接开始算 stat[n]（递归调用从stat(0)开始，直接尝试计算 stat[0] ），算到算不下去了（发现计算 stat[0] 需要 stat[1] ），那就把当前的执行压栈，然后去算 stat[1]。而动态规划的思想是这样的，我先观察，发现 stat[0] 需要 stat[1]，而 stat[1] 又需要 stat[2]，最终发现 stat[L] 不依赖任何人，直接是 True，那么这时候知道了 stat[L] 我就可以算 stat[L-1]，进而可以算 stat[L-2]，然后一步步算出 stat[0]。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>printf_in_c</title>
      <link>/post/2014-04-04-printf-in-c/</link>
      <pubDate>Fri, 04 Apr 2014 21:48:15 +0800</pubDate>
      
      <guid>/post/2014-04-04-printf-in-c/</guid>
      <description>&lt;p&gt;这两天讨论起 c 中&lt;code&gt;*p++&lt;/code&gt;的行为，特意写了个小程序想要验证一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;main () {
	int a[3] = {0xdeaa, 0xdeab, 0xdeac};
	int *p = a;
	int *p1 = a;
	int *p2 = a;
	
	printf(&amp;quot;%x, %x, %x\n&amp;quot;,  (int)(*p++), (int)(*(p1++)), (int)(++(*p2)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;p&gt;我期待的输出结果是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0xdeaa, 0xdeaa, 0xdeab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而实际的输出却是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0xdeab, 0xdeab, 0xdeaa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完完全全相反啊妈蛋！我心目中的&lt;code&gt;*p++&lt;/code&gt;应该是先执行&lt;code&gt;p++&lt;/code&gt;，然后返回未增加之前 p 的值 pp，之后对 pp 进行解引用，最终返回&lt;code&gt;*pp&lt;/code&gt;的值，而 p 应该等于 pp+4。执行效果等价于&lt;code&gt;(*p); p++&lt;/code&gt;，但是从输出结果看来仿佛是&lt;code&gt;p++; (*p)&lt;/code&gt;，肯定是哪里不对。&lt;/p&gt;

&lt;p&gt;观察发现 a[0]+1 的值和 a[1] 相等，都是 0xdeab，因此事实上并不能知道输出的 0xdeab 到底是怎么来的，所以首先把数组 a 的初始值改成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a[3] = {0xdea0, 0xdea5, 0xdeaa};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次的输出是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0xdea1, 0xdea1, 0xdea0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，看来并不如想像的那样，仿佛&lt;code&gt;*p++&lt;/code&gt;被执行成了&lt;code&gt;(*p)++&lt;/code&gt;了。但这是不对的，而且就算是后者，也应该是先返回 *p 的值，然后再加对 p 所指向的内存加 1。而且毫无疑问第一个输出&lt;code&gt;*p++&lt;/code&gt;会影响第二个输出&lt;code&gt;*(p1++)&lt;/code&gt;的结果，所以事实并不是这样。不如来看下汇编吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;00000000004004f4 &amp;lt;main&amp;gt;:
  4004f4:   55                      push   %rbp
  4004f5:   48 89 e5                mov    %rsp,%rbp
  4004f8:   48 83 ec 30             sub    $0x30,%rsp
  4004fc:   c7 45 d0 a0 de 00 00    movl   $0xdea0,-0x30(%rbp) // a[0]
  400503:   c7 45 d4 a5 de 00 00    movl   $0xdea5,-0x2c(%rbp) // a[1]
  40050a:   c7 45 d8 aa de 00 00    movl   $0xdeaa,-0x28(%rbp) // a[2]
  400511:   48 8d 45 d0             lea    -0x30(%rbp),%rax    
  400515:   48 89 45 f8             mov    %rax,-0x8(%rbp)     // p
  400519:   48 8d 45 d0             lea    -0x30(%rbp),%rax    
  40051d:   48 89 45 f0             mov    %rax,-0x10(%rbp)    // p1
  400521:   48 8d 45 d0             lea    -0x30(%rbp),%rax
  400525:   48 89 45 e8             mov    %rax,-0x18(%rbp)    // p2
  400529:   48 8b 45 e8             mov    -0x18(%rbp),%rax    // rax = p2
  40052d:   8b 00                   mov    (%rax),%eax         // eax = *p2 = 0xdea0
  40052f:   8d 50 01                lea    0x1(%rax),%edx      // edx = eax + 1
  400532:   48 8b 45 e8             mov    -0x18(%rbp),%rax    // rax = p2
  400536:   89 10                   mov    %edx,(%rax)
  400538:   48 8b 45 e8             mov    -0x18(%rbp),%rax
  40053c:   8b 08                   mov    (%rax),%ecx
  40053e:   48 8b 45 f0             mov    -0x10(%rbp),%rax
  400542:   8b 10                   mov    (%rax),%edx
  400544:   48 83 45 f0 04          addq   $0x4,-0x10(%rbp)
  400549:   48 8b 45 f8             mov    -0x8(%rbp),%rax
  40054d:   8b 00                   mov    (%rax),%eax
  40054f:   48 83 45 f8 04          addq   $0x4,-0x8(%rbp)
  400554:   89 c6                   mov    %eax,%esi
  400556:   bf 5c 06 40 00          mov    $0x40065c,%edi
  40055b:   b8 00 00 00 00          mov    $0x0,%eax
  400560:   e8 8b fe ff ff          callq  4003f0 &amp;lt;printf@plt&amp;gt;
  400561:   c9                      leaveq 
  400562:   c3                      retq   
  400563:   90                      nop
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ds-tree</title>
      <link>/post/2014-03-31-ds-tree/</link>
      <pubDate>Mon, 31 Mar 2014 21:21:33 +0800</pubDate>
      
      <guid>/post/2014-03-31-ds-tree/</guid>
      <description>

&lt;h2 id=&#34;binary-search-tree:668551676aee55c1093deeefc0b62506&#34;&gt;Binary Search Tree&lt;/h2&gt;

&lt;h3 id=&#34;avl-tree:668551676aee55c1093deeefc0b62506&#34;&gt;AVL Tree&lt;/h3&gt;

&lt;p&gt;查询较快，适用于&lt;strong&gt;一次构造、多次查询&lt;/strong&gt;的需求。&lt;/p&gt;

&lt;h3 id=&#34;red-black-tree:668551676aee55c1093deeefc0b62506&#34;&gt;Red-Black Tree&lt;/h3&gt;

&lt;p&gt;相比平衡二叉树，红黑树在平衡性上限制并不严格，因此红黑树的修改操作（插入、删除）性能更优，但是查询操作稍慢。&lt;/p&gt;

&lt;h4 id=&#34;insertion:668551676aee55c1093deeefc0b62506&#34;&gt;Insertion&lt;/h4&gt;

&lt;p&gt;插入时首先找到要替换的叶子结点，用一个红色结点来代替，该红色结点的值即为要插入的值，节点的两个子节点为黑色的 NIL。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;property 3&lt;/strong&gt; (叶子结点均为黑色) 总是成立。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;property 4&lt;/strong&gt; (红色结点的两个孩子都是黑色节点) 下列情况可能会不成立：添加一个红色结点，把一个黑色结点变成红色，旋转&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;property 5&lt;/strong&gt; (从根到叶子结点的所有路径上包含的黑色结点的数量相同) 下列情况可能会不成立：添加黑色结点，改变结点颜色，旋转&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note: N, 当前节点; P, N 的父节点; G, N 的祖父; U, N 的叔叔（P 的兄弟）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case 1:&lt;/strong&gt; N 为根, 改变其颜色为黑；&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void insert_case1(struct node *n)
{
 if (n-&amp;gt;parent == NULL)
  n-&amp;gt;color = BLACK;
 else
  insert_case2(n);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case 2:&lt;/strong&gt; P 为黑色，所有限制均满足，不需要变化；&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void insert_case2(struct node *n)
{
if (n-&amp;gt;parent-&amp;gt;color == BLACK)
  return; /* Tree is still valid */
else
  insert_case3(n);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case 3:&lt;/strong&gt; P 和 U 都是红色，则改变 P 和 U 为黑色，同时把 G 变成红色。此时 G 可能违反了限制2和4，需要递归的调整&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void marnsert_case3(struct node *n)
{
struct node *u = uncle(n), *g;

if ((u != NULL) &amp;amp;&amp;amp; (u-&amp;gt;color == RED)) {
  n-&amp;gt;parent-&amp;gt;color = BLACK;
  u-&amp;gt;color = BLACK;
  g = grandparent(n);
  g-&amp;gt;color = RED;
  insert_case1(g);
} else {
  insert_case4(n);
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case 4:&lt;/strong&gt; P 是红色而 U 是黑色，且 N 是 P 的右子结点，则对 P 坐一次左旋操作，转为 Case 5；&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void insert_case4(struct node *n)
{
 struct node *g = grandparent(n);
 
 if ((n == n-&amp;gt;parent-&amp;gt;right) &amp;amp;&amp;amp; (n-&amp;gt;parent == g-&amp;gt;left)) {
  rotate_left(n-&amp;gt;parent);
 
 /*
 * rotate_left can be the below because of already having *g =  grandparent(n) 
 *
 * struct node *saved_p=g-&amp;gt;left, *saved_left_n=n-&amp;gt;left;
 * g-&amp;gt;left=n; 
 * n-&amp;gt;left=saved_p;
 * saved_p-&amp;gt;right=saved_left_n;
 * 
 * and modify the parent&#39;s nodes properly
 */
 
  n = n-&amp;gt;left; 
 
 } else if ((n == n-&amp;gt;parent-&amp;gt;left) &amp;amp;&amp;amp; (n-&amp;gt;parent == g-&amp;gt;right)) {
  rotate_right(n-&amp;gt;parent);
 
 /*
 * rotate_right can be the below to take advantage of already having *g =  grandparent(n) 
 *
 * struct node *saved_p=g-&amp;gt;right, *saved_right_n=n-&amp;gt;right;
 * g-&amp;gt;right=n; 
 * n-&amp;gt;right=saved_p;
 * saved_p-&amp;gt;left=saved_right_n;
 * 
 */
 
  n = n-&amp;gt;right; 
 }
 insert_case5(n);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case 5:&lt;/strong&gt; P 是红色而 U 是黑色，且 N 是 P 的左子结点，则对 G 进行一次右旋操作，并把 G 标为红色，把 P 标为黑色。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void insert_case5(struct node *n)
{
struct node *g = grandparent(n);

n-&amp;gt;parent-&amp;gt;color = BLACK;
g-&amp;gt;color = RED;
if (n == n-&amp;gt;parent-&amp;gt;left)
  rotate_right(g);
else
  rotate_left(g);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;removal:668551676aee55c1093deeefc0b62506&#34;&gt;Removal&lt;/h4&gt;

&lt;h3 id=&#34;left-leaning-red-black-tree-llrb:668551676aee55c1093deeefc0b62506&#34;&gt;Left-Leaning Red–Black Tree (LLRB)&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Linux 下 c 的扩展内联汇编</title>
      <link>/post/2014-03-05-c-asm/</link>
      <pubDate>Wed, 05 Mar 2014 19:54:09 +0800</pubDate>
      
      <guid>/post/2014-03-05-c-asm/</guid>
      <description>

&lt;p&gt;简单总结了一下自己看到用到的一些内联汇编的知识点，并不是一个完整的总结，以后对内联汇编有了新的了解会慢慢扩充。&lt;/p&gt;

&lt;p&gt;详细细节可以参考 gcc 关与扩展内联汇编的 &lt;a href=&#34;http://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm&#34;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;格式说明:f467db7656345f29d7121e6fc1e20d0c&#34;&gt;格式说明&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;__asm__　__volatile__(&amp;quot;Instruction List&amp;quot; : Output : Input : Clobber/Modify)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;冒号的使用原则（*O, I, C 分别指代 Output, Input, Clobber/Modify*）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;C 为空，第三个冒号必须省略&lt;/li&gt;
&lt;li&gt;O、I 为空时，前边的冒号（第一、二个）可选择性省略&lt;/li&gt;
&lt;li&gt;O，I，C 中任何一个不为空，则之前的冒号均必须保留，如只有 I 不为空时，O 和 I 之前的冒号必须保留，只有 C 不为空时三个冒号都必须保留&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;合法的调用包括&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__asm__(&amp;quot; &amp;quot; : : : &amp;quot;memory&amp;quot;);
__asm__(&amp;quot; &amp;quot; : :);
__asm__(&amp;quot;mov %1, %%eax&amp;quot; : &amp;quot;=a&amp;quot;(var_a));
__asm__(&amp;quot;mov %1, %%eax&amp;quot; : &amp;quot;=a&amp;quot;(var_a) :);
__asm__(&amp;quot;mov %%edx, %%eax&amp;quot; : &amp;quot;=a&amp;quot;(var_a) : &amp;quot;d&amp;quot;(var_d));
__asm__(&amp;quot;mov %%edx, %%eax&amp;quot; : &amp;quot;=a&amp;quot;(var_a) : : &amp;quot;ebx&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面分别介绍指令列表、输出、输入和修改声明这四个部分。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;指令列表:f467db7656345f29d7121e6fc1e20d0c&#34;&gt;指令列表&lt;/h2&gt;

&lt;p&gt;基本上和 .S 文件的格式是一样的，不同的是要加个引号。需要注意的是每一行中只能有一个指令，如果一行中包含多条指令，则必须用 &lt;code&gt;;&lt;/code&gt; 或换行符隔开。注意字符串中的换行符会被asm识别，但字符串以外、代码中的不会，参见一下示例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 换行符在字符串内，不需显示添加换行符
__asm__(&amp;quot;mov %edx, %eax
         mov %ebx, %edx&amp;quot;)

// 换行符在字符串外，需显示添加换行符
__asm__(&amp;quot;mov %edx, %eax\n&amp;quot;
        &amp;quot;mov %ebx, %edx&amp;quot;)

// 没有换行符，使用 ; 分隔
__asm__(&amp;quot;mov %edx, %eax; mov %ebx, %edx&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于指令中百分号的使用，当使用了冒号时，指令中&lt;strong&gt;必须&lt;/strong&gt;使用 &lt;code&gt;%%&lt;/code&gt; 来作为寄存器前缀；当没有使用冒号时，&lt;strong&gt;必须&lt;/strong&gt;使用 &lt;code&gt;%&lt;/code&gt; 作为寄存器前缀。&lt;/p&gt;

&lt;h2 id=&#34;输出:f467db7656345f29d7121e6fc1e20d0c&#34;&gt;输出&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__asm__(&amp;quot;mov %%edx, %%eax&amp;quot; : &amp;quot;=a&amp;quot;(var_a) : &amp;quot;d&amp;quot;(var_d));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出部分 &lt;code&gt;&amp;quot;=a&amp;quot;(var_a)&lt;/code&gt; 的意思是把寄存器 &lt;em&gt;%eax&lt;/em&gt; 中的值放入变量 &lt;em&gt;var_a&lt;/em&gt; 中，由输出操作数（Operand） &lt;code&gt;var_a&lt;/code&gt; 和 操作数约束（Constraint） &lt;code&gt;&amp;quot;=a&amp;quot;&lt;/code&gt; 两部分组成。&lt;/p&gt;

&lt;p&gt;其中，操作数制定了输出向哪个 c 变量，该例中即 *var_a*；操作约束中的修饰符（Modifier） “=” 表明输出操作数在指令中是只写的，并且只作为输出。常用的修饰符还有“+”，表明操作数可读可写，既作输入又作输出，而约束中的“a”表征寄存器 *%eax*。&lt;/p&gt;

&lt;p&gt;详细的输出约束参见 GCC 文档 &lt;a href=&#34;http://gcc.gnu.org/onlinedocs/gcc/Constraints.html#Constraints&#34;&gt;6.42 Constraints for asm Operands&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果有多个输出，需要用 “,” 将这些输出分隔开，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;asm (&amp;quot;cpuid&amp;quot;
	:&amp;quot;=a&amp;quot; (_eax),
	 &amp;quot;=b&amp;quot; (_ebx),
	 &amp;quot;=c&amp;quot; (_ecx),
	 &amp;quot;=d&amp;quot; (_edx)
	:&amp;quot;a&amp;quot; (op));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;输入:f467db7656345f29d7121e6fc1e20d0c&#34;&gt;输入&lt;/h2&gt;

&lt;p&gt;输入约束的基本意义与输出相同，不过不包含修饰符。&lt;/p&gt;

&lt;p&gt;输入的操作数部分可以是表达式。&lt;/p&gt;

&lt;h2 id=&#34;修改声明:f467db7656345f29d7121e6fc1e20d0c&#34;&gt;修改声明&lt;/h2&gt;

&lt;p&gt;声明在这段汇编中哪些寄存器的值会改变，以及是否会修改内存。在一些情况下，这对与 gcc 编译、优化程序而言非常重要，比如我们在汇编中修改了一个既不是输入也不是输出的寄存器，如果不显示声明的话 gcc 会认为这段汇编之后该寄存器的值不变，导致程序出错。&lt;/p&gt;

&lt;h2 id=&#34;参考:f467db7656345f29d7121e6fc1e20d0c&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/index.html&#34;&gt;Linux 中 x86 的内联汇编 - IBM&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/latifrons/archive/2009/09/17/1568198.html&#34;&gt;C语言ASM汇编内嵌语法&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://andyhuzhill.github.io/ARM/GCC/ASM/2012/09/25/gcc-inline-assemly/&#34;&gt;ARM体系下的GCC内联汇编&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Notes on iOS Security Whitepaper</title>
      <link>/post/2014-03-03-ios-security/</link>
      <pubDate>Mon, 03 Mar 2014 19:56:09 +0800</pubDate>
      
      <guid>/post/2014-03-03-ios-security/</guid>
      <description>

&lt;p&gt;This notes is based on &lt;em&gt;iOS Security - February 2014&lt;/em&gt;, origin link can be found &lt;a href=&#34;http://images.apple.com/iphone/business/docs/iOS_Security_Feb14.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This paper gives a brief description of iOS security, including hardware security features and how iOS leverages these features.&lt;/p&gt;

&lt;h2 id=&#34;system-security:bf9b580f36e32014f4603d11adf690ee&#34;&gt;System Security&lt;/h2&gt;

&lt;h3 id=&#34;secure-boot-chain:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Secure Boot Chain&lt;/h3&gt;

&lt;p&gt;ROM is sealed with public key of Apple Root CA, and will verify the Low-Level Bootloader (LLB) before load it.&lt;/p&gt;

&lt;p&gt;For devices with an A7 processor, the &lt;em&gt;Secure Enclave&lt;/em&gt; coprocessor also utilizes a secure boot process that ensures its separate software is verified and signed by Apple.&lt;/p&gt;

&lt;p&gt;Verification failure will enter &lt;strong&gt;recovery mode&lt;/strong&gt;, if Boot ROM is not even able to load or verify LLB, it enters &lt;strong&gt;DFU (Device Firmware Update) mode&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;system-software-authorization:bf9b580f36e32014f4603d11adf690ee&#34;&gt;System Software Authorization&lt;/h3&gt;

&lt;p&gt;GOAL: prevent the devices from being downgraded.&lt;/p&gt;

&lt;p&gt;Need iTunes to upgrade, when upgrading, iTunes (or the device) would send&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;a list cryptographic measurements of each installation bundle to be installed&lt;/li&gt;
&lt;li&gt;nonce&lt;/li&gt;
&lt;li&gt;device&amp;rsquo;s unique ID (ECID)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;to Apple installation authorization server.&lt;/p&gt;

&lt;p&gt;If upgrade request is permitted, server would add ECID to the measurement and signs the result.&lt;/p&gt;

&lt;p&gt;Device would check each item loaded from disk at boot time.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;secure-enclave:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Secure Enclave&lt;/h3&gt;

&lt;p&gt;There are two kinds of processors, &lt;em&gt;application processor (A7)&lt;/em&gt; and &lt;em&gt;Secure Enclave&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is Secure Enclave?&lt;/strong&gt;
A coprocessor fabricated in the Apple A7 chip, has its OWN &lt;em&gt;secure boot&lt;/em&gt; and &lt;em&gt;personalized software update&lt;/em&gt;, &lt;em&gt;encrypted memory&lt;/em&gt; and &lt;em&gt;hardware random number generator&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What does Secure Enclave do?&lt;/strong&gt;
It provides all cryptographic operations for Data Protection key management and maintains the integrity of Data Protection, it is also responsible for processing fingerprint data, determining if there is a match, and enabling access or purchase on behalf of the user.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How Secure Enclave communicate with app processor?&lt;/strong&gt;
Communication is isolated to an interrupt-driven mailbox and shared memory data buffers.&lt;/p&gt;

&lt;p&gt;Each Secure Enclave is provisioned during fabrication with its own &lt;em&gt;UID (Unique ID)&lt;/em&gt;, not known to Apple, not accessible to other parts of the system. Note that this UID is NOT SAME with that fused into application processor.&lt;/p&gt;

&lt;p&gt;Create an ephemeral key tangled with UID to encrypt Secure Enclave&amp;rsquo;s portion of the device&amp;rsquo;s memory space.&lt;/p&gt;

&lt;p&gt;Data saved to file system by Secure Enclave is encrypted with a key tangled with UID and an anti-replay counter.&lt;/p&gt;

&lt;p&gt;Utilizes System Software Authorization to ensure the integrity of its software and prevent downgrade.&lt;/p&gt;

&lt;h4 id=&#34;some-questions:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Some Questions&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;How secure boot of Secure Enclave is achieved?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Where the ephemeral key is stored? How about the key and anti-replay counter used to encrypt data written to file system by Secure Enclave?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;touch-id:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Touch ID&lt;/h3&gt;

&lt;p&gt;80*80 pixel, 500 ppi &lt;a href=&#34;http://en.wikipedia.org/wiki/Raster_scan&#34;&gt;raster scan&lt;/a&gt;, temporarily stored in Secure Enclave, data out from Touch ID sensor is encrypted, A7 can only forward it to Secure Enclave but never read its content.&lt;/p&gt;

&lt;p&gt;User&amp;rsquo;s fingerprint map never leaves ip5s.&lt;/p&gt;

&lt;h4 id=&#34;safe-communicate-with-secure-enclave:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Safe communicate with Secure Enclave&lt;/h4&gt;

&lt;p&gt;Touch ID can only talk to Secure Enclave through application processor.  Communication between the A7 and the
Touch ID sensor takes place over a &lt;a href=&#34;http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus&#34;&gt;serial peripheral interface bus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There is a &lt;em&gt;device&amp;rsquo;s key&lt;/em&gt; that is build into the Touch ID sensor and Secure Enclave (should differ from Enclave&amp;rsquo;s UID and device UID in application processor). To communicate with Enclave, Touch ID first negotiates with Enclave for a session key, which process should be protected by the device&amp;rsquo;s key. Touch ID then sends the encrypted scan result to Enclave.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The session key exchange uses AES key wrapping with both sides providing a random key that establishes the session key and uses AES-CCM transport encryption&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;process-of-unlocking-an-iphone:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Process of unlocking an iPhone&lt;/h4&gt;

&lt;p&gt;On regular A7 processor, Data Protection &lt;em&gt;class keys&lt;/em&gt; are discarded, and regenerated when user unlock the device with passcode.&lt;/p&gt;

&lt;p&gt;With Touch ID, the keys are wrapped with a key given to Touch ID subsystem, Touch ID will provide the key for unwrapping if it recognizes the user&amp;rsquo;s fingerprint (details refer to section &lt;em&gt;File Data Protection&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;simple-conclusion:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Simple Conclusion&lt;/h3&gt;

&lt;p&gt;The following features are most critical for iOS system security&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UID in Secure Enclave&lt;/li&gt;
&lt;li&gt;dedicated secure CPU&lt;/li&gt;
&lt;li&gt;unbreakable ROM&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;encryption-and-data-protection:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Encryption and Data Protection&lt;/h2&gt;

&lt;p&gt;Focus on the protection of data stored on the device.&lt;/p&gt;

&lt;h3 id=&#34;hardware-security-features:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Hardware Security Features&lt;/h3&gt;

&lt;p&gt;Apple&amp;rsquo;s devices involves some hardware support for security, these includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Dedicated hardware AES 256 crypto engine&lt;/em&gt; built into DMA path between Flash and Main Memory&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Hardware SHA-1&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Fused UID&lt;/em&gt;, in application processor, unique to each device, software and firmware cannot read UID, can only get the results of encryption or decryption operations&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Fused GID&lt;/em&gt;, common to a class of devices, used as an additional level of protection when delivering system software during installation and restore&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Integrating these keys into the silicon helps prevent them from being tampered with or bypassed, or accessed outside the AES engine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A hardware &lt;em&gt;random number generator (RNG)&lt;/em&gt; to create all cryptographic keys (except those used in Secure Enclave)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Effaceable Storage&lt;/em&gt; for securely erasing saved keys&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;file-data-protection:bf9b580f36e32014f4603d11adf690ee&#34;&gt;File Data Protection&lt;/h3&gt;

&lt;p&gt;GOAL: Protect data stored in flash memory.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Data Protection allows the device to respond to common events such as incoming phone calls, but also enables a high level of encryption for sensitive data&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Managing a &lt;strong&gt;hierarchy of keys&lt;/strong&gt;; built on hardware encryption; encrypted every file stored into the flash.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Data Protection is controlled on a per-file basis by assigning each file to a class; accessibility is determined by whether the class keys have been unlocked&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Create a new 260-bit key (per-file key) for EACH file on the data partition, &lt;em&gt;hardware AES engine&lt;/em&gt; uses these keys to encrypt files when written to flash memory using AES CBC mode.&lt;/p&gt;

&lt;p&gt;Per-file key is wrapped (by Enclave) with one class key (performed using NIST AES key wrapping, per RFC 3394). The wrapped per-file key is stored in the file’s &lt;em&gt;metadata&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;To open a file: &lt;strong&gt;1.&lt;/strong&gt; decrypt metadata with &lt;em&gt;File System Key&lt;/em&gt; &lt;strong&gt;2.&lt;/strong&gt; unwrapped with class key &lt;strong&gt;3.&lt;/strong&gt; supply the per-file key to hardware AES engine.&lt;/p&gt;

&lt;p&gt;Use a random &lt;em&gt;File System Key&lt;/em&gt; to encrypt the metadata of all files in the file system. This file system key is created when iOS first installed or when the device is wiped by a user. The key is stored in Effaceable Storage to be quickly erased.&lt;/p&gt;

&lt;p&gt;Once the File System Key is wiped, there should be no way to get the content of all the files.&lt;/p&gt;

&lt;p&gt;The work of key management is done by Secure Enclave, as mentioned in section Secure Enclave.&lt;/p&gt;

&lt;h3 id=&#34;passcodes:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Passcodes&lt;/h3&gt;

&lt;p&gt;Supports &lt;em&gt;four-digit&lt;/em&gt; and &lt;em&gt;arbitrary-length alphanumeric&lt;/em&gt; passcodes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In addition to unlocking the device, a passcode provides the entropy for encryption keys, which are not stored on the device. This means an attacker in possession of a device can’t get access to data in certain protection classes without the passcode.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Passcode is tangled with UID.&lt;/p&gt;

&lt;p&gt;Takes longer and longer for brute-force hack.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Where is this Passcodes stored?&lt;/strong&gt;
Passcodes should be managed by Secure Enclave, and stored in file system after being encrypted by Secure Enclave.&lt;/p&gt;

&lt;h3 id=&#34;data-protection-classes:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Data Protection Classes&lt;/h3&gt;

&lt;p&gt;Basic classes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Complete Protection&lt;/li&gt;
&lt;li&gt;Protected Unless Open&lt;/li&gt;
&lt;li&gt;Protected Until First User Authentication&lt;/li&gt;
&lt;li&gt;No Protection&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;NSFileProtectionComplete&lt;/em&gt; : class key protected with a key derived from Passcode and device UID, auto discard the decrypted class key after the screen is lock. File becomes inaccessible until unlock (either by Passcode or Touch ID).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NSFileProtectionCompleteUnlessOpen&lt;/em&gt; : for files need to be written while locking. Besides per-file key, Data Protection: &lt;strong&gt;1.&lt;/strong&gt; creates another &lt;em&gt;public/private key pair&lt;/em&gt; for the file &lt;strong&gt;2.&lt;/strong&gt; a shared secret is computed using file&amp;rsquo;s private key and this class&amp;rsquo;s public key &lt;strong&gt;3.&lt;/strong&gt; wrap the per-file key with the hash of shared secret &lt;strong&gt;4.&lt;/strong&gt; wrapped per-file key and file&amp;rsquo;s public key are stored in the file&amp;rsquo;s metadata &lt;strong&gt;5.&lt;/strong&gt; wipe the file&amp;rsquo;s private key from memory &lt;strong&gt;6.&lt;/strong&gt; to open the file, the shared secret is re-generated using file&amp;rsquo;s public key and this class&amp;rsquo;s private key, to unwrap per-file key.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NSFileProtectionCompleteUntilFirstUserAuthentication&lt;/em&gt; : behaves in the same way as Complete Protection, only that decrypted class key is not wiped after lock. This is DEFAULT CLASS for all third-party app data.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NSFileProtectionNone&lt;/em&gt; : class key protected only with UID (no Passcode), kept in Effaceable Storage. All the keys needed to decrypt files of this class are stored on the device.&lt;/p&gt;

&lt;p&gt;So in a short &lt;strong&gt;conslusion&lt;/strong&gt;, all the files in iOS devices are encrypted, as there always be a hardware AES between memory and flash, only that stronger protection involves encrypting class key with Passcode, and auto wiping the decrypted key after the device is locked.&lt;/p&gt;

&lt;h3 id=&#34;keychain-data-protection:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Keychain Data Protection&lt;/h3&gt;

&lt;p&gt;GOAL: protect short but sensitive bits of data in apps, such as keys and login tokens.&lt;/p&gt;

&lt;p&gt;Implemented as SQLite database, and there is only one database in the system. The &lt;em&gt;securityd&lt;/em&gt; deamon determines which keychain items each process or app can access.&lt;/p&gt;

&lt;p&gt;The deamon would check app&amp;rsquo;s &amp;ldquo;keychain-access-groups&amp;rdquo; and the &amp;ldquo;application-identifier&amp;rdquo; entitlement. Apps from the same author (have the same access groups prefix allocated to them through the iOS Developer Program) can share Keychain items.&lt;/p&gt;

&lt;p&gt;Similar protect class as file Data Protection.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each keychain class has a “This device only” counterpart, which is always protected with the UID when being copied from the device during a backup, rendering it useless if restored to a different device&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;keybags:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Keybags&lt;/h3&gt;

&lt;p&gt;Manage keys for file and Keychain Data Protection classes, four keybags: &lt;em&gt;System&lt;/em&gt;, &lt;em&gt;Backup&lt;/em&gt;, &lt;em&gt;Escrow&lt;/em&gt;, and &lt;em&gt;iCloud&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;System keybag&lt;/strong&gt; where wrapped class keys are stored, is No Protection class itself. Contents of system keybag are encrypted with a key held in Effaceable Storage. This key is wiped and regenerated each time user change Passcode. System keybag is the ONLY keybag stored on the device.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Backup keybag&lt;/strong&gt; created when an encrypted backup is made by iTunes and stored
on the computer where the device is backed up. The backed-up data is &lt;strong&gt;re-encrypted&lt;/strong&gt; to a new set of keys (a new keybag).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Escrow keybag&lt;/strong&gt; is used for iTunes syncing and mobile device management (MDM). Allows iTunes to sync without requiring the user to enter a passcode and allows an MDM server to remotely clear a user&amp;rsquo;s passcode. Stored on computer. Contains exactly the SAME class keys used on device, protected by a newly created key, which is stored on the device in Protected Until First User Authentication class.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;iCloud Backup keybag&lt;/strong&gt; similar to Backup keybag, all class keys in this keybag are asymmetric.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For all Data Protection classes except No Protection, the encrypted data is read from the device and sent to iCloud. The corresponding class keys are protected by iCloud keys. The keychain class keys are wrapped with a UID-derived key in the same way as an unencrypted iTunes backup.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;app-security:bf9b580f36e32014f4603d11adf690ee&#34;&gt;App Security&lt;/h2&gt;

&lt;p&gt;iOS provides protection to ensure that apps are signed and verified, cannot execute malicious code, and are sandboxed to protect user data at all times.&lt;/p&gt;

&lt;h3 id=&#34;app-code-signing:bf9b580f36e32014f4603d11adf690ee&#34;&gt;App Code Signing&lt;/h3&gt;

&lt;p&gt;Mandatory code signing esing Apple-issued certificate. Developers must join iOS Developer Program and provide their real-world indentity for verification.&lt;/p&gt;

&lt;h3 id=&#34;runtime-process-security:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Runtime Process Security&lt;/h3&gt;

&lt;p&gt;Sandbox. Randomly assigned home directory, can only communicate with APIs.&lt;/p&gt;

&lt;p&gt;Majority of iOS and all third-party apps run as the non-privileged user &amp;ldquo;mobile&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Address space layout randomization (ASLR)&lt;/p&gt;

&lt;p&gt;ARM&amp;rsquo;s Execute Never (XN) feature, which marks memory pages as non-executable.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Memory pages marked as both writable and executable can be used only by apps under tightly controlled conditions: The kernel checks for the presence of the Apple-only dynamic code-signing entitlement.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;data-protection-in-apps:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Data Protection in Apps&lt;/h3&gt;

&lt;p&gt;Data Protection is available for file and database APIs, Protected Until First User Authentication by default.&lt;/p&gt;

&lt;h3 id=&#34;accessories:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Accessories&lt;/h3&gt;

&lt;p&gt;The following process is entirely handled by a integrated circuit that Apple provides to approved accessory manufacturers and is transparent to the accessory.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Check accessory&amp;rsquo;s Apple-provided certificate.&lt;/li&gt;
&lt;li&gt;Send a challenge, which the accessory must answer with a signed response.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;network-security:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Network Security&lt;/h2&gt;

&lt;p&gt;Uses standard networking protocols for authenticated, authorized, and encrypted communications. Integrates proven technologies and the latest standards for both Wi-Fi and cellular data network connections.&lt;/p&gt;

&lt;p&gt;(Refer to the paper for details)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SSL (v3), TLS (v1.0, v1.1, v1.2)&lt;/li&gt;
&lt;li&gt;VPN, supports multiple protocols and authentication methods&lt;/li&gt;
&lt;li&gt;Wi-Fi, industry-standard Wi-Fi protocols&lt;/li&gt;
&lt;li&gt;Bluetooth, Encryption Mode &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;, Service Level 1 connections, multiple Blutooth profiles&lt;/li&gt;
&lt;li&gt;Single Sign-on (I do not know what this SSO is&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;airdrop-security:bf9b580f36e32014f4603d11adf690ee&#34;&gt;AirDrop Security&lt;/h3&gt;

&lt;p&gt;Use Bluetooth Low-Energy (BTLE) and Apple-created peer-to-peer Wi-Fi technology.&lt;/p&gt;

&lt;p&gt;If enabled, a 2048-bit RSA identity is stored on the device, and an AirDrop identity hash is created based on email address and phone number.&lt;/p&gt;

&lt;p&gt;Use TLS connection.&lt;/p&gt;

&lt;h2 id=&#34;internet-security:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Internet Security&lt;/h2&gt;

&lt;p&gt;Explain the security control of iMessage, FaceTime, Siri, iCloud, iCloudKeychain in detail.&lt;/p&gt;

&lt;h3 id=&#34;imessage:bf9b580f36e32014f4603d11adf690ee&#34;&gt;iMessage&lt;/h3&gt;

&lt;p&gt;The contents of messages of iMessage are protected by end-to-end encryption, so no one but the sender and receiver can access them, even Apple cannot.&lt;/p&gt;

&lt;p&gt;Device generates two pairs of keys for iMessage: an RSA 1280-bit key for encryption and an ECDSA 256-bit key for signing. The private keys are stored in device&amp;rsquo;s keychain while the public keys are sent to Apple&amp;rsquo;s directory service (IDS), where they are associated with user&amp;rsquo;s phone number or email address and Apple Push Notification Service (APNs) address.&lt;/p&gt;

&lt;p&gt;To send a message, iMessage first fetches receiver&amp;rsquo;s public keys and APNs addresses from the IDS, then encrypts the content using receiver&amp;rsquo;s public keys, and signs the encrypted messages with the sender&amp;rsquo;s private key, finally, iMessage dispatches each encrypted message to APNs for delivary. Metadata is not encrypted while communication with APNs is encrypted using TLS.&lt;/p&gt;

&lt;p&gt;If the message contains attachments, the attachments are uploaded to iCloud after encryption, the keys to decrypt attackments along with URI to the encrypted attachments are included in the encrypted message.&lt;/p&gt;

&lt;p&gt;For the receiver, each device receives its copy of the message from APNs, and decrypts the message with its own private key. The message can be verified using sender&amp;rsquo;s public key.&lt;/p&gt;

&lt;h2 id=&#34;device-control:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Device Control&lt;/h2&gt;

&lt;p&gt;Policies for Passcode Protection, Configuration Enforcement, Mobile Device Management, Apple Configurator, Device Restrictions, Supervised Only Restrictions and Remote Wipe.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:bf9b580f36e32014f4603d11adf690ee&#34;&gt;Conclusion&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hardware support: UID, Secure Enclave, ROM, Hardware AES, Random Number Generator&lt;/li&gt;
&lt;li&gt;Dedicated Secure Processor, with encrypted memory&lt;/li&gt;
&lt;li&gt;Full Storage Encryption&lt;/li&gt;
&lt;li&gt;Hierarchy of Key Management&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From the document we can see, Apple really takes great efforts in security, and as Apple&amp;rsquo;s hardware and software are tightly combined, they possess the most enviable hardware security features. But to achieve security, Apple sacrifices the ability of third party apps by setting a lot of constrains and providing only a limited APIs.&lt;/p&gt;

&lt;p&gt;Oh! One more thing, all of these protections are useless if your device is rooted.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using theme Greyshade</title>
      <link>/post/2014-02-27-using-theme-greyshade/</link>
      <pubDate>Thu, 27 Feb 2014 14:11:32 +0800</pubDate>
      
      <guid>/post/2014-02-27-using-theme-greyshade/</guid>
      <description>

&lt;p&gt;Sometimes ago I came across a blog &lt;a href=&#34;http://samwize.com/&#34;&gt;samwize&lt;/a&gt;, who uses a slightly
modified theme called &lt;a href=&#34;https://github.com/shashankmehta/greyshade&#34;&gt;Greyshade&lt;/a&gt;, which I
think is very beautiful, so I applied that theme immediately. Saddly this theme does
not support chinese very well, so I made some customization myself.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;font-and-size:cba7168ebdfad8b08cefe70e59616e4b&#34;&gt;Font and Size&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;add new font &amp;ldquo;Microsoft Yahei&amp;rdquo; for Chinese, add font &amp;ldquo;Consolas&amp;rdquo; for monospace&lt;/li&gt;
&lt;li&gt;enlarge the font size of an article&lt;/li&gt;
&lt;li&gt;enlarge the line height to make it comfortable to read Chinese
&lt;/br&gt; may be it is not large enough for Chinese, but I think it is too large for English&lt;/li&gt;
&lt;li&gt;enlarge the font size of meta info of an article&lt;/li&gt;
&lt;li&gt;decrease the font size for archieve view&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;layout:cba7168ebdfad8b08cefe70e59616e4b&#34;&gt;Layout&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;abandon fixed width layout&lt;/li&gt;
&lt;li&gt;change the way meta info is displayed&lt;/li&gt;
&lt;li&gt;display meta info in the article view&lt;/li&gt;
&lt;li&gt;add Next and Prev link in the article view&lt;/li&gt;
&lt;li&gt;change a sharing provider&lt;/li&gt;
&lt;li&gt;remove the shadow below the sharing&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;profile:cba7168ebdfad8b08cefe70e59616e4b&#34;&gt;Profile&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;use a local image instead of that of Gravatar.com, too slow&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I would soon post my modified theme on my Github,
it is sad that I did not modify the style directly on the theme but in my &lt;em&gt;sass/&lt;/em&gt; and &lt;em&gt;source/&lt;/em&gt;,
so I need to patch my modification and merge it into the Greyshade. I would do this later&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vim Efficiency Notes</title>
      <link>/post/2014-02-24-vim-notes/</link>
      <pubDate>Mon, 24 Feb 2014 15:00:00 +0800</pubDate>
      
      <guid>/post/2014-02-24-vim-notes/</guid>
      <description>

&lt;p&gt;关于Vim的一些容易被忽视、却又能提升使用体验和操作效率的操作细节。同时记录Vim中一些（我见到过的）比较实用的配置，分享的同时也给自己留个备忘吧。
一下子总结不完整，慢慢更新。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;基本操作:1f4c62931b7f7b8d6df24780dbe9cdb4&#34;&gt;基本操作&lt;/h2&gt;

&lt;p&gt;基本按照幸福感排序，排在前边的是我觉得用了之后一口气儿上五楼都不累的，稍微靠后一点排的就比较随意了。每一项第一行的*斜体字*是我认为该组合比较有用的场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Ctrl+[ 替代Esc&lt;/strong&gt;，&lt;em&gt;任何时候&lt;/em&gt;&lt;/br&gt;
Ctrl+[ 功能与Esc键完全相同，用这一快捷键的好处就不用解释了，大家都知道按Esc是件多么令人伤神的事情&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;X和x&lt;/strong&gt;，&lt;em&gt;任何时候&lt;/em&gt;&lt;/br&gt;
X 是退格（Backspace），x 是删除（Delete）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Ctrl+e 和 Ctrl+y逐行翻滚页面&lt;/strong&gt;，&lt;em&gt;阅读（代码）&lt;/em&gt;&lt;/br&gt;
这两个组合非常有用，作用分别是维持当前坐标位置不变，页面上滚和下滚一行&lt;/p&gt;

&lt;p&gt;** #和* *&lt;em&gt;，*阅读代码&lt;/em&gt;&lt;/br&gt;
#（shift+3）用来向上搜索当前光标所在单词，*（shift+8）用来向下搜索&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;%&lt;/strong&gt;，&lt;em&gt;阅读代码&lt;/em&gt;&lt;/br&gt;
在相对应的两个括号之间跳转，当一段函数体非常长的时候能方便的从反括号跳至函数/循环/if等结构的开始处&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;+ 和 -&lt;/strong&gt;&lt;/br&gt;
+ 的功能是跳转到下一行行首，与之相对应，- 是跳转到上一行行首&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;J&lt;/strong&gt;&lt;/br&gt;
删除行末换行符，在把多行连接成一行时非常有用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;zz和zt&lt;/strong&gt;，&lt;em&gt;阅读&lt;/em&gt;&lt;/br&gt;
将光标所在行置于屏幕中间/顶部，阅读代码时比较有用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;H，M 和 L&lt;/strong&gt;, &lt;em&gt;代码、文章编辑&lt;/em&gt;&lt;/br&gt;
H，M和L（注意是大写）用来将光标快速移动到当前屏幕的最顶行/中间行/最底行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用m 和` （Esc下边那个按键）进行标记和跳转&lt;/strong&gt;&lt;/br&gt;
先按m，然后随意输入一个字母，就能用该字母标记当前行，之后在当前文件任意位置可以按 ` + 之前标记的字母快速跳转到这一行。在被标记的行按m，加同样的字母可以取消标记，如果连续按两次`，则光标会在当前位置，和上一次的跳转位置之间来回切换&lt;/br&gt;
此外，这里还可以使用*单引号*代替反引号，他们俩的功能是一样一样的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A 和 I&lt;/strong&gt;&lt;/br&gt;
A 是在本行行尾插入，I 是在本行行首插入。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ctrl+a和Ctrl+x&lt;/strong&gt;
将当前光标所在位置处的数字加1/减1，比较好玩儿的命令，一般用不到，不过用到的话确实很方便&lt;/p&gt;

&lt;h2 id=&#34;配置:1f4c62931b7f7b8d6df24780dbe9cdb4&#34;&gt;配置&lt;/h2&gt;

&lt;h4 id=&#34;wildmode-wildmenu:1f4c62931b7f7b8d6df24780dbe9cdb4&#34;&gt;wildmode, wildmenu&lt;/h4&gt;

&lt;p&gt;输入命令&lt;code&gt;:set wildmode=list:longest,full&lt;/code&gt;和&lt;code&gt;:set wildmenu&lt;/code&gt;，在vim窗口下方会出现一条menu，当需要补全的时候（例如&lt;code&gt;:e&lt;/code&gt;命令打开新文件，或者输入&lt;code&gt;:s&lt;/code&gt;后希望模糊搜索所有s开头的vim命令），按Tab键时自动补全时行为会变为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;出现一个list，为当前目录下所有文件，此时可进行并再次按Tab补全&lt;/li&gt;
&lt;li&gt;跳至列表第一个选项，或者（如果第1步中输入了文件开头字母）自动补全当前输入&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;默认行为没有步骤1，直接跳转第一个选项，而且不会显示整体列表，使用起来体验极差。&lt;/p&gt;

&lt;!-- 字符串匹配、替换 --&gt;
</description>
    </item>
    
    <item>
      <title>6.824-lab3-notes</title>
      <link>/post/2014-02-21-6-dot-824-lab3-notes/</link>
      <pubDate>Fri, 21 Feb 2014 14:08:02 +0800</pubDate>
      
      <guid>/post/2014-02-21-6-dot-824-lab3-notes/</guid>
      <description>

&lt;h2 id=&#34;pre-read:6c805deaca0efd9342e0670f4a49bd04&#34;&gt;Pre-read&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pdos.csail.mit.edu/6.824-2013/notes/l05.txt&#34;&gt;[Lecture Notes] Fault Tolerance: Paxos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pdos.csail.mit.edu/6.824-2013/papers/paxos-simple.pdf&#34;&gt;[Paper] Paxos Made Simple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/reading/papers/paxos-simple.html&#34;&gt;My Paxos Notes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Paxos 键值存储系统包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端（ client ）&lt;/li&gt;
&lt;li&gt;kvpaxos 服务器（ server ）&lt;/li&gt;
&lt;li&gt;Paxos 节点（ peers ）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中 Paxos 节点部分以类库的形式运行在服务器之上，在 lab3 的整体模型类似于 &lt;a href=&#34;http://pdos.csail.mit.edu/6.824-2013/papers/paxos-simple.pdf&#34;&gt;Paxos Made Simple&lt;/a&gt; 第三节提到的状态机，其中 proposer、acceptor 和 learner 都是 Paxos 节点，&lt;strong&gt;把整个键值存储服务看成一个状态机&lt;/strong&gt;，它会按照一定的顺序执行客户端发来的所有命令（ Put 请求），每个命令都确定性的把整个状态机向前推进一步。&lt;/p&gt;

&lt;p&gt;在这里，这个状态机是由很多服务器共同构成的，这些服务器之间彼此要&lt;strong&gt;保证执行的命令的顺序完全一致&lt;/strong&gt;，为此，我们维护一个有序序列 *list*，该序列就是所有服务器应当执行命令的顺序。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;在服务器收到一个-put-k-v-请求之后:6c805deaca0efd9342e0670f4a49bd04&#34;&gt;在服务器收到一个 Put(k, v) 请求之后&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;在该序列中寻找到当前最小的空位 *list[n]*，也就是新命令应该存储的位置&lt;/li&gt;
&lt;li&gt;向 Paxos 节点 propose 在该位置上放置 &lt;em&gt;key=&amp;gt;value&lt;/em&gt; 这个命令，注意同时可能有多个服务器尝试向 &lt;em&gt;list[n]&lt;/em&gt; 这个位置放置命令，这时 Paxos 负责协调统一，决定最终放置在 &lt;em&gt;list[n]&lt;/em&gt; 处的命令应该是什么&lt;/li&gt;
&lt;li&gt;对于单个服务器而言，如果最终 Paxos 决定放置在 &lt;em&gt;list[n]&lt;/em&gt; 处的命令与其 propose 的相同，则放置命令成功，对 Put 命令的处理结束；反之，则继续尝试在 &lt;em&gt;list[n+1]&lt;/em&gt; 处放置其 propose 的命令。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;How Put(key, value) and px.Start(seq, v) meet?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Log slot?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(* Paxos).Start(seq int, v interface{})&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(* Paxos).Status(seq int) (decided bool, v interface{})&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;part-b:6c805deaca0efd9342e0670f4a49bd04&#34;&gt;Part B&lt;/h2&gt;

&lt;p&gt;在 Part B 中，要在 Paxos 的基础之上实现一个键值存储系统，改系统所能处理的异常情况包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Part B 中存储系统的结构依然包括客户端、服务端，与 Lab2 中不同的是服务端彼此之间利用 Paxos 来达成共识，因此在该部分中 Paxos 是运行在存储系统服务端之下的辅助系统。下文中提到的客户端、服务端均指存储系统的客户端河服务端。&lt;/p&gt;

&lt;p&gt;###基本工作原理&lt;/p&gt;

&lt;p&gt;服务器本地保存一个请求队列，收到客户端的请求先缓存起来，每次服务器&lt;strong&gt;只处理队列头的请求&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;每个Put请求都要添加一段随机的身份标识，当一个客户端向多个服务器发送请求的时候请求不会被重复处理。&lt;/p&gt;

&lt;p&gt;服务器维护一个列表，表示已经达成共识的消息日志（操作历史），当服务器处理一个请求的时候，尝试添加改请求到列表下一个位置，并通过 Paxos 与其他服务器达成共识。为了解决客户端重复请求的情况，服务器应当先检查本地是否包含改身份标识的操作，确认为新操作之后再进行添加请求。当该请求添加成功之后，处理缓存中下一个请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何确定消息应该添加的位置？&lt;/strong&gt;
由于 Paxos 在收到 decide 信息的时候并不会主动通知上层，因此当请求到来的时候，服务器端保存的消息日志可能只有 n 个 slot，然而底层的 Paxos 达成共识的已经有 n+m 个了。所以服务器在处理请求队列时应当：&lt;strong&gt;1.&lt;/strong&gt; 先同 Paxos 同步信息 &lt;strong&gt;2.&lt;/strong&gt; 根据请求的身份标识判断是否是重复请求 &lt;strong&gt;3.&lt;/strong&gt; 调用 Paxos.Start &lt;strong&gt;4.&lt;/strong&gt; 轮询 Paxos.Status &lt;strong&gt;5.&lt;/strong&gt; 请求占位成功，则返回，失败则返回第1步重新执行。&lt;/p&gt;

&lt;p&gt;服务器端维护的消息日志与 Paxos 节点中维护的消息列表是相对应的，内容也是一致的。不过服务端列表是完整的，而且包含了语义信息，而 Paxos 作为服务系统，并不了解列表中值的具体意义，而且 Paxos 中维护的列表内容是作为缓冲而存在的，一旦服务器同步了 Paxos 列表中的信息，就可以通过 Paxos.Done 来清空 Paxos 中缓存的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Get请求直接从本地读取数据返回？&lt;/strong&gt;
也当成一个操作，请求共识，根据最终决定的操作顺序返回相应的值。&lt;/p&gt;

&lt;p&gt;一种可能的问题：客户端向服务器A发送了Put(a)=1的请求之后，又向服务器B发送Put(a)=2请求。因为Paxos请求并没有一个时间戳，所以可能出现发往B的请求先于发往A的请求达成了共识，造成&lt;strong&gt;客户端的不一致&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Notes on Paxos Made Simple</title>
      <link>/post/2014-02-12-paxos/</link>
      <pubDate>Wed, 12 Feb 2014 16:21:02 +0800</pubDate>
      
      <guid>/post/2014-02-12-paxos/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://pdos.csail.mit.edu/6.824-2013/papers/paxos-simple.pdf&#34;&gt;Origin paper link&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;problem:6bec04965a0098d4a556c94eb1c1658c&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;safety requirements&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Only a value that has been proposed may be chosen&lt;/li&gt;
&lt;li&gt;Only a single value is chosen, and&lt;/li&gt;
&lt;li&gt;A process never learns that a value has been chosen unless it
acutally has been&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;three agents: &lt;em&gt;proposers&lt;/em&gt;(P), &lt;em&gt;acceptors&lt;/em&gt;(A), and &lt;em&gt;learners&lt;/em&gt;(L).&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;use customary asynchronous, non-Byzantine model, in which:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Agents operate at arbitrary speed, may fail by stopping, and may
restart&lt;/li&gt;
&lt;li&gt;Messages can take arbitrarily long to be delivered, can be duplicated,
and can be lost, but they are not corrupted.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;choosing-a-value:6bec04965a0098d4a556c94eb1c1658c&#34;&gt;Choosing a Value&lt;/h3&gt;

&lt;p&gt;Single acceptor, simple but unsatisfacroty, suffer from failure
of this single acceptor.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Majority of the agents?&lt;/strong&gt;
Literally understand as more than half of acceptors.&lt;/p&gt;

&lt;p&gt;To ensure that only a single value is chosen, we can let a large
enough set consist of &lt;strong&gt;any majority of the agents&lt;/strong&gt;. Because any two
majorities have at least one acceptor in common, this works if an
acceptor can accept at most one value.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;P1. An acceptor must accept the first proposal that it receives.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This ensure that the value got chosen if there is only one value
proposed. But raises the problem when more than two values are
proposed and each got same amount of acceptors(3 values, each &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; of
all acceptors).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Acceptor must be allowed to accept more than one proposals&lt;/strong&gt;
Though there can be only one value that got chosen, but each acceptor indeed could accept more than one proposals.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proposal number is global? or for each acceptor? How to achieve global?&lt;/strong&gt;
It should be global.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;P2. If a proposal with value &lt;em&gt;v&lt;/em&gt; is chosen, then every higher-numbered
proposal that is chosen has value &lt;em&gt;v&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;P2 guarantees the crucial safety property that only a single value is chosen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;P2a. If a proposal with value &lt;em&gt;v&lt;/em&gt; is chosen, then every higher-numbered
proposal accepted by any acceptor has value &lt;em&gt;v&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;P1 may conficts P2a in some situations.
Suppose a proposal was chosen with some particular acceptor &lt;em&gt;c&lt;/em&gt; never
having received any proposal. A new proposer &amp;ldquo;wakes up&amp;rdquo; then and
issues a higher-numbered proposal with a different value. P1 requires
&lt;em&gt;c&lt;/em&gt; to accept this proposal, violating P2a.&lt;/p&gt;

&lt;p&gt;Maintaining both P1 and P2a requires strengthening P2a to:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;P2b . If a proposal with value &lt;em&gt;v&lt;/em&gt; is chosen, then every higher-numbered
proposal issued by any proposer has value &lt;em&gt;v&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Difference between concepts &lt;em&gt;chosen&lt;/em&gt;, &lt;em&gt;accept&lt;/em&gt; and &lt;em&gt;issue&lt;/em&gt;?&lt;/strong&gt; &lt;em&gt;Chosen&lt;/em&gt; is a global state that a value &lt;em&gt;v&lt;/em&gt; has been accepted by majority of acceptors, the whole system can only choose one value. &lt;em&gt;Accept&lt;/em&gt; is the behavior of a single acceptor, the acceptor can change its mind to accept another newer proposal at any time. &lt;em&gt;Issue&lt;/em&gt; is the behavior of a single proposer, if a value &lt;em&gt;v&lt;/em&gt; is &lt;em&gt;chosen&lt;/em&gt; (globally accepted), then all proposers would make compromise to propose &lt;em&gt;v&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Given that &lt;strong&gt;any two sets of majaority acceptors must have at least one acceptor in common&lt;/strong&gt;. We want the following invariance meet:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;P2c. For any &lt;em&gt;v&lt;/em&gt; and &lt;em&gt;n&lt;/em&gt;, if a proposal with value &lt;em&gt;v&lt;/em&gt; and number &lt;em&gt;n&lt;/em&gt; is
issued, then there is a set &lt;em&gt;S&lt;/em&gt; consisting of a majority of
acceptors such that
either (a) no acceptor in &lt;em&gt;S&lt;/em&gt; has accepted any proposal numbered less
than &lt;em&gt;n&lt;/em&gt;, or (b) &lt;em&gt;v&lt;/em&gt; is the value of the highest-numbered proposal
among all proposals numbered less than &lt;em&gt;n&lt;/em&gt; accepted by the acceptors
in &lt;em&gt;S&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To maintain the invariance of P2c, a proposer that wants to issue a
proposal numbered &lt;em&gt;n&lt;/em&gt; must learn the highest-numbered proposal with
number less than &lt;em&gt;n&lt;/em&gt; that has been or will be accepted by each
acceptor in some majority of acceptors.&lt;/p&gt;

&lt;p&gt;It is hard to predict future acceptances, instead, the proposer controls
it by extracting a &lt;strong&gt;promise&lt;/strong&gt; that the acceptors won&amp;rsquo;t accept any more
proposals numbered less than &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Note that P2c guaranteed that &lt;strong&gt;if a value &lt;em&gt;v&lt;/em&gt; is chosen, then the highest-numbered proposal must have value *v&lt;/strong&gt;*.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algorithm for a proposer to issue proposals&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A proposer choses &lt;em&gt;n&lt;/em&gt;, sends a request to each acceptors in some
set, asking:

&lt;ol&gt;
&lt;li&gt;Promise it won&amp;rsquo;t accept a proposal numbered less than &lt;em&gt;n&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The proposal with highest number less than &lt;em&gt;n&lt;/em&gt; that it has accepted.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;The proposer can issue a proposal with number &lt;em&gt;n&lt;/em&gt; and &lt;em&gt;v&lt;/em&gt; if it
receives responses from a majority of the acceptors, where &lt;em&gt;v&lt;/em&gt; is the
value of the highest-numbered proposal among the responses, or is any
value if responders reported no proposals.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The request in step 1 is a &lt;em&gt;prepare&lt;/em&gt; request, and that in step 2 is
an &lt;em&gt;accept&lt;/em&gt; request.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How an acceptor responds to requests?&lt;/strong&gt;
It can always respond to a &lt;em&gt;prepare&lt;/em&gt; request, and it can respond to an
&lt;em&gt;accept&lt;/em&gt; request iff it has not promised not to.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;P1a. An acceptor can accept a proposal numbered &lt;em&gt;n&lt;/em&gt; iff it has not
responded to a prepare request having a number greater than &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An acceptor needs to remember only the highest-numbered proposal that
it has ever accepted and the number of the highest-numbered prepare
request to which it has responded.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note that the proposer can always abandon a proposal and forget all about it—as long as it never tries to issue another proposal with the same number. What if a proposer got a promise but never issued?&lt;/strong&gt;
Just like a network package lose. Will be eventually replaced by
other proposals.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Phase 1.&lt;/strong&gt;
&lt;strong&gt;(a)&lt;/strong&gt; A proposer selects a proposal number &lt;em&gt;n&lt;/em&gt; and sends a &lt;em&gt;prepare&lt;/em&gt;
request with number &lt;em&gt;n&lt;/em&gt; to a majority of acceptors.
&lt;strong&gt;(b)&lt;/strong&gt; If an acceptor receives a &lt;em&gt;prepare&lt;/em&gt; request with number &lt;em&gt;n&lt;/em&gt; greater
than that of any &lt;em&gt;prepare&lt;/em&gt; request to which it has already responded,
then it responds to the request with a promise not to accept any more
proposals numbered less than &lt;em&gt;n&lt;/em&gt; and with the highest-numbered proposal
(if any) that it has accepted.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Phase 2.&lt;/strong&gt;
&lt;strong&gt;(a)&lt;/strong&gt; If the proposer receives a response to its &lt;em&gt;prepare&lt;/em&gt; requests
(numbered &lt;em&gt;n&lt;/em&gt;) from a majority of acceptors, then it sends an &lt;em&gt;accept&lt;/em&gt;
request to each of those acceptors for a proposal numbered &lt;em&gt;n&lt;/em&gt; with a
value &lt;em&gt;v&lt;/em&gt; , where &lt;em&gt;v&lt;/em&gt; is the value of the highest-numbered proposal
among the responses, or is any value if the responses reported no
proposals.
&lt;strong&gt;(b)&lt;/strong&gt; If an acceptor receives an &lt;em&gt;accept&lt;/em&gt; request for a proposal numbered
&lt;em&gt;n&lt;/em&gt;, it accepts the proposal unless it has already responded to a
&lt;em&gt;prepare&lt;/em&gt; request having a number greater than &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Optimization&lt;/strong&gt;: abandon a proposal if some proposers has begun trying to
issue a higher-numbered one.&lt;/p&gt;

&lt;h3 id=&#34;learning-a-chosen-value:6bec04965a0098d4a556c94eb1c1658c&#34;&gt;Learning a Chosen Value&lt;/h3&gt;

&lt;p&gt;Acceptors return responds to &lt;em&gt;accept&lt;/em&gt; requests to all the learners,
the number of responds that required equals to the product of the number
of acceptors and the number of learners.&lt;/p&gt;

&lt;p&gt;Acceptors could return only to a set of distinguished learners, these
learners will inform other learners.&lt;/p&gt;

&lt;h3 id=&#34;progress:6bec04965a0098d4a556c94eb1c1658c&#34;&gt;Progress&lt;/h3&gt;

&lt;p&gt;It’s easy to construct a scenario in which two proposers each keep
issuing a sequence of proposals with increasing numbers, none of which
are ever chosen.&lt;/p&gt;

&lt;p&gt;To guarantee progress, a distinguished proposer must be selected as the
only one to try issuing proposals.&lt;/p&gt;

&lt;p&gt;Result of &lt;a href=&#34;http://dl.acm.org/citation.cfm?id=214121&#34;&gt;Fischer, Lynch, and Patterson&lt;/a&gt; shows a reliable algorithm
to electing a proposer must use either randomness or real time.&lt;/p&gt;

&lt;h3 id=&#34;implementation:6bec04965a0098d4a556c94eb1c1658c&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://dl.acm.org/citation.cfm?id=279229&#34;&gt;The part-time parliament&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;No two proposals are ever issued with the same number?&lt;/strong&gt;
Different proposers choose their numbers from disjoint sets of numbers,
each proposer remembers (in stable storage) the highest-numbered
proposal it has tried to issue.&lt;/p&gt;

&lt;h2 id=&#34;my-summary:6bec04965a0098d4a556c94eb1c1658c&#34;&gt;My Summary&lt;/h2&gt;

&lt;p&gt;Behavior of &lt;em&gt;Proposer&lt;/em&gt;, &lt;em&gt;Acceptor&lt;/em&gt; and &lt;em&gt;Learner&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;proposer:6bec04965a0098d4a556c94eb1c1658c&#34;&gt;Proposer&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;sends prepare request &lt;em&gt;n&lt;/em&gt; to all acceptors&lt;/li&gt;
&lt;li&gt;after receives responds from majority of acceptors, choose a value &lt;em&gt;v&lt;/em&gt; according to responds

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;v&lt;/em&gt; should be the value of the highest-numberd proposal in those responds&lt;/li&gt;
&lt;li&gt;if none of responds returns any proposal, use arbitrary value&lt;/li&gt;
&lt;li&gt;if any responds contains an error or a proposal whose number is bigger than &lt;em&gt;n&lt;/em&gt;, go to next step&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;repick a bigger &lt;em&gt;n&lt;/em&gt; and repeat step 1 &amp;amp; 2 until a value is chosen&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;acceptor:6bec04965a0098d4a556c94eb1c1658c&#34;&gt;Acceptor&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Acceptor should know the highest-numbered proposal it accepted &lt;em&gt;APa&lt;/em&gt; and the highest-numbered proposal it responsed &lt;em&gt;APr&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Upon receiving a prepare request &lt;em&gt;P&lt;/em&gt;, compare &lt;em&gt;P.n&lt;/em&gt; with &lt;em&gt;APr.n&lt;/em&gt;

&lt;ol&gt;
&lt;li&gt;if &lt;em&gt;P.n&lt;/em&gt; &amp;gt; &lt;em&gt;APr.n&lt;/em&gt;, respond a promise and &lt;em&gt;APa&lt;/em&gt;, then change &lt;em&gt;APr&lt;/em&gt; to &lt;em&gt;P&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;if &lt;em&gt;P.n&lt;/em&gt; &amp;lt;= &lt;em&gt;APr.n&lt;/em&gt;, respond with some error or &lt;em&gt;APr&lt;/em&gt;?&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Upon receiving a accept request &lt;em&gt;P&lt;/em&gt;

&lt;ol&gt;
&lt;li&gt;if &lt;em&gt;P.n&lt;/em&gt; &amp;gt;= &lt;em&gt;APr.n&lt;/em&gt;, accept it by making &lt;em&gt;APa&lt;/em&gt; equals to &lt;em&gt;P&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;if &lt;em&gt;P.n&lt;/em&gt; &amp;lt; &lt;em&gt;APr.n&lt;/em&gt;, abondon it&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;learner:6bec04965a0098d4a556c94eb1c1658c&#34;&gt;Learner&lt;/h3&gt;

&lt;p&gt;TODO&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.824 Lab2 Notes</title>
      <link>/post/2014-02-08-6-dot-824-lab2-notes/</link>
      <pubDate>Sat, 08 Feb 2014 15:53:24 +0800</pubDate>
      
      <guid>/post/2014-02-08-6-dot-824-lab2-notes/</guid>
      <description>

&lt;p&gt;Lab2要实现一个分布式键-值存储服务（key/value storage service），依然使用primary/backup的架构，支持&lt;strong&gt;Put(key, value)&lt;/strong&gt;和&lt;strong&gt;Get(key)&lt;/strong&gt;两种操作，所有的键-值都存储在P的内存中，不写入硬盘，在正常运行中要保证P/B的状态一致。此外，这个lab要求实现P/B的动态分配，所以在B能正常工作之前要先与P进行状态同步，而且服务器在挂掉之后可能恢复运行，成为新的B。为了使所有人（客户端、所有的服务器）看到的状态（即P/B分别是谁）一致，lab2中引入了视图服务（viewservice）作为一个控制服务器（master server），视图服务负责监控所有键-值服务器的连接状态，在P或B挂掉之后动态的指定新的。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;part-a:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Part A&lt;/h2&gt;

&lt;p&gt;这一部分要实现视图服务，代码文件在/viewservice/文件夹下，命名规则与lab1相同。在partA中，Client的代码已经完整的给出了，我们需要实现的仅仅是Server部分。&lt;/p&gt;

&lt;p&gt;视图服务要实现两个RPC&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ping(Me, Viewnum)&lt;/strong&gt; 键-值服务器通过该方法告诉视图服务：“我还活着，我所知道的当前的视图号是Viewnum”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Get()&lt;/strong&gt; 键-值服务器服务器或其客户端通过该方法向视图服务询问当前最新的视图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中视图的定义在*common.go*文件中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type View struct {
	Viewnum uint
	Primary string
	Backup  string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个&lt;strong&gt;视图（View）&lt;/strong&gt;表征了当前整个键-值存储服务的状态，它表示当前的主要服务器P是Primary，备份服务器B是Backup。每个视图还对应一个视图号（Viewnum），在视图服务初始化的时候视图号为0，以后每次视图发生变化（变更Primary或Backup）该值都会增加1。最开始的时候我以为视图服务要维护视图变更的历史，后来发现这其实是不需要的，视图服务只需要保存当前的视图就可以了。&lt;/p&gt;

&lt;p&gt;视图服务要维护一个包含当前所有键-值服务器的列表，这些服务器中，一个是P，一个是B，其他的都是I（idle，空闲服务器）。所有的键-值服务器每隔100ms（由常量PingInterval定义）就要Ping一下视图服务，如果一个服务器连续5个（由常量DeadPings定义）PingInterval内都没有Ping视图服务，则视图服务&lt;strong&gt;认为该服务器挂掉&lt;/strong&gt;。为了检测距离上一次某个服务器Ping视图服务过了多久，我在视图服务中存储了每个服务器最后一次Ping的时间。&lt;/p&gt;

&lt;p&gt;视图服务在当前视图被P确认之前是不会对视图进行更多的修改的，P确认当前视图的方式是发送一个包含当前视图号的Ping请求（也就是说P已经知道了当前的最新状态）。因此视图服务需要知道当前视图是否被确认了。&lt;/p&gt;

&lt;p&gt;该lab还有另外一个要求，我并没有在文档中看到（也可能是我漏看了=~=），但是在最后一个测试用例中定义了，即为确认当前视图的服务器不能成为P，测试原文是“Uninitialized server can&amp;rsquo;t become primary”，刚开始不清出初始化什么意思，看了测试代码才知道是要对当前的视图进行确认。为了过这一个测试必须知道每个服务器是否初始化了，所以我在记录每个服务器最后一次Ping时间的地方，同时记录了最后一个Ping的视图号。&lt;/p&gt;

&lt;p&gt;总的来讲，视图服务器端我所维护的信息如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ClientInfo struct {
	name         string    // client&#39;s name
	last_ping    time.Time // Time of last Ping
	last_viewnum uint      // Viewnum of last Ping
	idle         bool      // whether this client is idle
	dead         bool      // whether this client is dead
}

type ViewServer struct {
	mu   sync.Mutex
	l    net.Listener
	dead bool
	me   string

	// Your declarations here.
	current_view      View
	acked             bool // current view is acked by P
	primary_restarted bool // P has restarted within DeadPings * PingInterval

	clients map[string]*ClientInfo // list of k/v servers
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现方面，主要需要实现的函数只有两个，Ping和tick，其中tick是一个私有方法，每隔PingInterval这么久视图服务器就会调用一次该方法。在我的实现中，我选择在Ping中修改服务器列表信息，而在tick中修改视图信息，当然，因为视图的变动而导致的服务器列表信息的变更也是在Tick中实现的。&lt;/p&gt;

&lt;p&gt;以上实现的一个结论就是视图服务视图的更新并不是及时的，这点应该是符合文档的描述的，文档中给了一个例子，但是因为解释的并不是特别清楚所以我并没能一下弄明白这个例子：&lt;/p&gt;

&lt;pre&gt;
Viewnum Primary Backup     Event
--------------------------------
0       none    none
                           server S1 sends Ping(0), which returns view 0
1       S1      none
                           server S2 sends Ping(0), which returns view 1
                             (no view change yet since S1 hasn&#39;t acked)
                           server S1 sends Ping(1), which returns view 1 or 2
2       S1      S2
                           server S1 sends Ping(2), which returns view 2
                           server S1 stops sending Pings
3       S2      none
                           server S2 sends Ping(3), which returns view 3
&lt;/pre&gt;

&lt;!--Viewnum | Primary | Backup | Event
------- | ------- | ------ | ---------
0 |none| none |
  |    |      | server S1 sends Ping(0), which returns view 0
1 | S1 | none |
  |    |      | server S2 sends Ping(0), which returns view 1 (no view change yet since S1 hasn&#39;t acked)
  |    |      | server S1 sends Ping(1), which returns view 1 or 2
2 | S1 |  S2  |
  |    |      | server S1 sends Ping(2), which returns view 2
  |    |      | server S1 stops sending Pings
3 | S2 | none |
  |    |      | server S2 sends Ping(3), which returns view 3
--&gt;

&lt;p&gt;S1向视图服务发送了Ping(0)请求之后服务器并不是立刻更新到视图1的，而是等到下一次tick执行的时候才检查当前视图能否更新，并空闲服务器列表中选出S1作为P。在tick执行之前，S1可能发送了多次Ping(0)给视图服务器，然而只有当tick执行之后，S1发送的Ping(0)请求才会返回view 1。&lt;/p&gt;

&lt;p&gt;文档对这个例子的解释并不完整，比如server S1 sends Ping(0), which returns view 0之后下一次出现S1就是server S1 sends Ping(1), which returns view 1 or 2，最开始看的时候我并不是很理解为啥S1收到view 0的返回值，下次会发送Ping(1)，其实是文档中把返回view 1的那次Ping(0)给省略掉了。这也解释了为啥S1发送Ping(1)会返回view 1 or 2，其实是第一次S1 Ping(1)的时候视图服务只是确认了view 1，还没有转换到view 2，但在确认之后的下一次tick中，视图服务会从空闲服务列表中拎出来一个S2作为B，切换到view 2，这时S1再发送Ping(1)就会返回view 2。&lt;/p&gt;

&lt;p&gt;而在view 2向view 3的切换过程中，S2也不是直接发送了Ping(3)，而是先发送Ping(2)，视图服务返回view 3，S2才知道自己当选了P，并向视图服务发送Ping(3)的。&lt;/p&gt;

&lt;h2 id=&#34;part-b:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Part B&lt;/h2&gt;

&lt;p&gt;这一部分基本思路借鉴Lab1，不再大段总结了，大概阐述下每个函数应该做什么，然后记录下遇到的一些问题。&lt;/p&gt;

&lt;h3 id=&#34;functionality:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Functionality&lt;/h3&gt;

&lt;p&gt;本部分说明各个函数的设计功能，采用函数所在位置（服务端、客户端）加函数命的方式来定位到具体的每个函数。首先客户端、服务端的变量结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Clerk struct {
	vs    *viewservice.Clerk  // 视图服务
	cview viewservice.View    // 当前视图
}

type PBServer struct {
	mu         sync.Mutex
	l          net.Listener
	dead       bool // for testing
	unreliable bool // for testing
	me         string
	vs         *viewservice.Clerk

	// Your declarations here.
	cview  viewservice.View   // 当前视图
	db     map[string]string  // 数据库
	role   string             // 改服务器的角色P/B/I
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外我在原有的常量基础上新增了一个&lt;code&gt;ErrFwdToPrimary&lt;/code&gt;，表示发送了一个Forward请求给当前的P。&lt;/p&gt;

&lt;h4 id=&#34;client-get-put:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Client - Get/Put&lt;/h4&gt;

&lt;p&gt;这两个函数实现基本结构是一样的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;判断当前客户端看到的视图是否包含P，不包含的话更新当前视图&lt;/li&gt;
&lt;li&gt;向服务端发送请求&lt;/li&gt;
&lt;li&gt;1. 如果服务端没有返回或返回ErrWrongServer，更新视图再次进行步骤2

&lt;ol&gt;
&lt;li&gt;如果服务端返回成功，返回结果&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;server-get:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - Get&lt;/h4&gt;

&lt;p&gt;本函数处理客户端发来的Get请求&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;判断自己是不是P，不是返回ErrWrongServer&lt;/li&gt;
&lt;li&gt;根据参数中的Key读取相应的Value，如果Key存在则返回Value，否则返回ErrNoKey&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;server-put:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - Put&lt;/h4&gt;

&lt;p&gt;本函数处理客户端发来的Put请求&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;判断自己是不是P，不是返回ErrWrongServer&lt;/li&gt;
&lt;li&gt;如果存在B，Forward请求至B。否则跳至步骤4&lt;/li&gt;
&lt;li&gt;如果B返回ErrFwdToPrimary，则取消Put操作，并返回ErrWrongServer&lt;/li&gt;
&lt;li&gt;更新本地数据库，返回OK&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;server-forward:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - Forward&lt;/h4&gt;

&lt;p&gt;本函数处理从P发向B的Fwd请求&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果自己是P，返回ErrFwdToPrimary&lt;/li&gt;
&lt;li&gt;如果自己是I，返回ErrWrongServer&lt;/li&gt;
&lt;li&gt;更新数据库，返回OK&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;server-sync:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - Sync&lt;/h4&gt;

&lt;p&gt;本函数处理P发向B的同步请求，在I成为B之后，P会先同B进行一次同步，把自己的数据库复制给B一份，然后再把接下来的Put请求Forward给B&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;更新当前视图&lt;/li&gt;
&lt;li&gt;如果自己是P或者I，返回ErrWrongServer&lt;/li&gt;
&lt;li&gt;用参数中的数据库覆盖本地的数据库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在步骤1中之所以要先更新视图，因为一种可能的情况是P拿到了最新的视图，向B发送Sync请求，但B此时尚未更新，依然认为自己是I，就直接返回ErrWrongServer了。考虑到Sync请求相比Put、Forward而言要少很多，每次Sync都更新下视图是不会成为瓶颈的。&lt;/p&gt;

&lt;h4 id=&#34;server-tick:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - tick&lt;/h4&gt;

&lt;p&gt;本函数在服务端每隔一段时间执行一次，功能实现非常简单，调用updateView()函数。&lt;/p&gt;

&lt;h4 id=&#34;server-updateview:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - updateView&lt;/h4&gt;

&lt;p&gt;其实完全可以把我这个函数中的内容放在tick里，不过我最初为了把更新当前视图这个功能单独拉出来所以写了这么个函数&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从视图服务获得最新的视图&lt;/li&gt;
&lt;li&gt;如果当前视图和最新视图一致，直接返回&lt;/li&gt;
&lt;li&gt;更新服务器的role属性&lt;/li&gt;
&lt;li&gt;如果我是P，而新视图中存在B，则进行一次Sync&lt;/li&gt;
&lt;li&gt;更新当前视图&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;问题笔记:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;问题笔记&lt;/h3&gt;

&lt;h4 id=&#34;什么时候需要向视图服务询问当前的视图:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;什么时候需要向视图服务询问当前的视图？&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;每个tick需要&lt;/li&gt;
&lt;li&gt;当P从B那里收到Err&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当B发现自己成了P，然而之前的P依然向他发送请求的时候，拒绝处理该请求；当P发现同步请求被B拒绝之后，知道自己已经不是P了，询问视图服务&lt;/p&gt;

&lt;h4 id=&#34;b如何区分来自client的put和来自p的put:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;B如何区分来自Client的Put和来自P的Put？&lt;/h4&gt;

&lt;p&gt;使用不同的接口: &lt;code&gt;Put&lt;/code&gt; &lt;code&gt;Forward&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Client是否需要添加Version信息?&lt;/p&gt;

&lt;h4 id=&#34;如何同步状态:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;如何同步状态&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sync(db map[string]string)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;bug-in-viewservice:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;BUG in viewservice&lt;/h4&gt;

&lt;pre&gt;
Tick() [/var/tmp/824-1000/pb-15185-basic-1]

----role:PRIMARY, view:{V:1, P:/var/tmp/824-1000/pb-15185-basic-1, B:}

Tick() [/var/tmp/824-1000/pb-15185-basic-1]

----role:PRIMARY, view:{V:2, P:/var/tmp/824-1000/pb-15185-basic-1, B:/var/tmp/824-1000/pb-15185-basic-1}
&lt;/pre&gt;

&lt;p&gt;viewservice会把P和B设成同一个Server&lt;/p&gt;

&lt;p&gt;clients list中S1会变成idle，原因是，在tick将S1设成P，但P未ack之前，S1 time out了，所以在之后的tick中会将S1设成idle&amp;amp;dead，但是因为还没有ack，所以server不会将idle&amp;amp;dead的S1从Primary中剔除出去，而是一直等待，直到S1回复运行之后再次正常的Ping，但是此时S1已经被设置成了idle，所以会被选来做B&lt;/p&gt;

&lt;p&gt;这跟我之前考虑到的一个bug类似，同样在S1被选为P，但尚未ack的时候，S1发生了一次crash，并快速恢复了，这时server会检测到一个primary_restarted，但是因为没有ack，所以不会handle，一直要等到S1 ack了之后才会handle，这时S1已经重启了，其内存数据已经丢失&lt;/p&gt;

&lt;h4 id=&#34;syncargs:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;SyncArgs&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;map[string]string&lt;/code&gt; 是指针，不能作为RPC的参数传递。目前使用多个Forward请求来实现Sync，但这样效率极低，对性能影响较大。&lt;/p&gt;

&lt;p&gt;难道是因为我map变量是小写开头的，导致没有export？ client、server因为是同一份文件，编译时没有出现错误。把SyncArgs改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type SyncArgs struct {
    DB map[string]string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过Sync进行同步了，果然是这个原因！&lt;/p&gt;

&lt;h4 id=&#34;primary-would-not-respond-get-after-crash:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Primary would not respond Get after crash&lt;/h4&gt;

&lt;p&gt;在Get中直接添加对当前身份的判断（pb.role）即可通过测试，但是一个问题是在视图服务判定S1不再是P，但S1收到该视图之前，S1依然认为自己是P，这种简单判断会在这个极段的时间内出现问题&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 13</title>
      <link>/post/2014-01-26-nebula-level13/</link>
      <pubDate>Sun, 26 Jan 2014 21:54:12 +0800</pubDate>
      
      <guid>/post/2014-01-26-nebula-level13/</guid>
      <description>

&lt;h3 id=&#34;about:d770d09b6be1c937de3594898fdf59fe&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level13&lt;/em&gt; account with the password &lt;em&gt;level13&lt;/em&gt; . Files for this level can be found in /home/flag13.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;source-code:d770d09b6be1c937de3594898fdf59fe&#34;&gt;Source code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#define FAKEUID 1000

int main(int argc, char **argv, char **envp)
{
	int c;
	char token[256];

	if(getuid() != FAKEUID) {
		printf(&amp;quot;Security failure detected. UID %d started us, we expect %d\n&amp;quot;, getuid(), FAKEUID);
		printf(&amp;quot;The system administrators will be notified of this violation\n&amp;quot;);
		exit(EXIT_FAILURE);
	}

	// snip, sorry :)

	printf(&amp;quot;your token is %s\n&amp;quot;, token);

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;solution:d770d09b6be1c937de3594898fdf59fe&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;There is no way for me to be uid 1000, but this executable which contains the token is right here, we cannot be stopped by a simple &lt;code&gt;if&lt;/code&gt; branch.&lt;/p&gt;

&lt;p&gt;Disassemble the executable &lt;em&gt;flag13&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level13@nebula:~$ objdump -D /home/flag13/flag13 &amp;gt; /home/level13/flag13.asm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go to the instruction corresponding to the last &lt;em&gt;printf()&lt;/em&gt; in the c code, I thought I could read the password out directly from the memory location where &lt;em&gt;token&lt;/em&gt; is stored. Turned out that &lt;em&gt;token&lt;/em&gt; is calculated with mass of code. Well, as I cannot read the password directly, I could always change the execution flow and let the program print that out.&lt;/p&gt;

&lt;p&gt;```text flag13.asm
080484c4 &lt;main&gt;:
 80484c4:       55                      push   %ebp
 80484c5:       89 e5                   mov    %esp,%ebp
 80484c7:       57                      push   %edi
 80484c8:       53                      push   %ebx
 80484c9:       83 e4 f0                and    $0xfffffff0,%esp
 80484cc:       81 ec 30 01 00 00       sub    $0x130,%esp
 80484d2:       8b 45 0c                mov    0xc(%ebp),%eax
 80484d5:       89 44 24 1c             mov    %eax,0x1c(%esp)
 80484d9:       8b 45 10                mov    0x10(%ebp),%eax
 80484dc:       89 44 24 18             mov    %eax,0x18(%esp)
 80484e0:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
 80484e6:       89 84 24 2c 01 00 00    mov    %eax,0x12c(%esp)
 80484ed:       31 c0                   xor    %eax,%eax
 80484ef:       e8 cc fe ff ff          call   80483c0 &lt;a href=&#34;mailto:getuid@plt&#34;&gt;getuid@plt&lt;/a&gt;
 80484f4:       3d e8 03 00 00          cmp    $0x3e8,%eax
 80484f9:       74 36                   je     8048531 &lt;main+0x6d&gt;
 80484fb:       e8 c0 fe ff ff          call   80483c0 &lt;a href=&#34;mailto:getuid@plt&#34;&gt;getuid@plt&lt;/a&gt;
 8048500:       ba d0 86 04 08          mov    $0x80486d0,%edx
 8048505:       c7 44 24 08 e8 03 00    movl   $0x3e8,0x8(%esp)
&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
This is the snippet of function *main()*, note that line 16 compare *%eax* (which is the return value of function call *getuid()*) with *0x3e8*, and line 17 will jump to memory location 0x8048531 if they are equal.

In a normal execution, these are apparantly not equal, but we could make it equal with *gdb*.

1. copy *flag13* into /home/level13
1. start it with *gdb*
1. set a break point at 0x80484f4, which is the instruction to compare
1. run the program
1. modify %eax to 1000 at the break point
1. continue run the program

``` bash
# start flag13 with gdb
level13@nebula:~$ gdb flag13
# set break point and run
(gdb) b *0x80484f4 
Breakpoint 1 at 0x80484f4
(gdb) run
Starting program: /home/level13/flag13
# reach break point, let&#39;s take a look at where we are
Breakpoint 1, 0x080484f4 in main ()
(gdb) disassemble
Dump of assembler code for function main:
   0x080484e0 &amp;lt;+28&amp;gt;:    mov    %gs:0x14,%eax
   0x080484e6 &amp;lt;+34&amp;gt;:    mov    %eax,0x12c(%esp)
   0x080484ed &amp;lt;+41&amp;gt;:    xor    %eax,%eax
   0x080484ef &amp;lt;+43&amp;gt;:    call   0x80483c0 &amp;lt;getuid@plt&amp;gt;
=&amp;gt; 0x080484f4 &amp;lt;+48&amp;gt;:    cmp    $0x3e8,%eax
   0x080484f9 &amp;lt;+53&amp;gt;:    je     0x8048531 &amp;lt;main+109&amp;gt;
   0x080484fb &amp;lt;+55&amp;gt;:    call   0x80483c0 &amp;lt;getuid@plt&amp;gt;
# here we print the registers out, %eax is 1014
(gdb) i r
eax            0x3f6    1014
ecx            0xbffff804       -1073743868
...
# change %eax
(gdb) set $eax=1000
(gdb) i r
eax            0x3e8    1000
ecx            0xbffff804       -1073743868
...
# continue execution 
(gdb) continue
Continuing.
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
[Inferior 1 (process 31018) exited with code 063]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;em&gt;su&lt;/em&gt; to &lt;em&gt;flag13&lt;/em&gt; with the token.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>